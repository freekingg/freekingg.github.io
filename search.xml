<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ECMAScript6 实用笔记</title>
    <url>/2020/03/29/ECMAScript6-%E5%AE%9E%E7%94%A8%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p> 1、目前常用的版本是ECMAScript3.0，后来改了名字叫ECMAScript5</p>
<blockquote>
<p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。<br>ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现</p>
</blockquote>
<p> 2、ECMAScript6的特点：</p>
<blockquote>
<ul>
<li>ES6增添了许多必要的特性，例如模块和类，块级作用域，常量与变量</li>
</ul>
</blockquote>
<p>3、浏览器的支持程度</p>
<blockquote>
<ul>
<li><a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">http://kangax.github.io/compat-table/es6/</a></li>
</ul>
</blockquote>
<p>4、可以通过Babel转码器把ES6写的代码转成ES5的，就不用担心运行环境是否支持<br>5、chrome下使用ES6为保证可以正常使用大部分语法，需要使用严格模式，即在js开始部分加上’use strict’<br>6、在firefox下使用ES6为保证可以正常使用大部分语法，需要知道测试版本，即在script标签的type属性中加上“application/javascript;version=1.7”属性值</p>
<a id="more"></a>

<h2 id="二、let"><a href="#二、let" class="headerlink" title="二、let"></a>二、let</h2><blockquote>
<p><strong>let 声明变量的关键字</strong><br>1、在相同的作用域内，let不能重复声明一个变量（不同的作用域内除外）<br>2、let声明的变量不会被预解析<br>3、暂时性死区</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>        <span class="comment">//严格模式，即在js开始部分加上'use strict'</span></span><br><span class="line"><span class="built_in">console</span>.log(a);		<span class="comment">//undefined let声明的变量不会被预解析</span></span><br><span class="line"><span class="keyword">var</span> a=<span class="number">12</span>;</span><br><span class="line"><span class="keyword">var</span> a=<span class="string">'kaivon'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log(b);		//报错	不能提前使用</span></span><br><span class="line"><span class="keyword">let</span> b=<span class="number">20</span>;</span><br><span class="line"><span class="comment">//let b=30;			//报错 let不能重复声明一个变量（不同的作用域内除外）</span></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> str=<span class="string">'kaivon'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、块级作用域"><a href="#三、块级作用域" class="headerlink" title="三、块级作用域"></a>三、块级作用域</h2><blockquote>
<p>块级作用域批是的是一对大括号就是一个作用域<br>块级作用域可以直接写一对大括号，以后就不用写自执行函数了</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a=<span class="number">12</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a=<span class="number">20</span>;</span><br><span class="line">   <span class="built_in">console</span>.log(a);</span><br><span class="line"> &#125;</span><br><span class="line">  fn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、const-常量"><a href="#四、const-常量" class="headerlink" title="四、const 常量"></a>四、const 常量</h2><blockquote>
<p><strong>const 声明一个常量，一旦声明后就不能修改了</strong><br>1、如果声明后再去修改的话就会报错<br>2、只声明不赋值也会报错<br>3、只能先声明后使用，不会被提前解析<br>4、不能重复声明一个常量<br><strong>注意：const声明的对象中的属性是可以修改的</strong></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line">			</span><br><span class="line"><span class="keyword">var</span> a=<span class="number">12</span>;</span><br><span class="line">a=<span class="string">'kaivon'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str=<span class="string">'kaivon'</span>;</span><br><span class="line"><span class="comment">//str=12;		//报错  声明后再去修改的话就会报错</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str);</span><br><span class="line"></span><br><span class="line"><span class="comment">//const b;			//报错	只声明不赋值也会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//console.log(c);	//报错	只能先声明后使用，不会被提前解析</span></span><br><span class="line"><span class="keyword">const</span> c=<span class="number">20</span>;</span><br><span class="line"><span class="comment">//const c='kaivon';	//报错	不能重复声明一个常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个对象后，可以对它里面的属性进行修改</span></span><br><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">	name:<span class="string">'kaivon'</span>	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.name=<span class="string">'陈学辉'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//const声明的对象中的属性是可以修改的</span></span><br></pre></td></tr></table></figure>
<h2 id="五、数组解构赋值"><a href="#五、数组解构赋值" class="headerlink" title="五、数组解构赋值"></a>五、数组解构赋值</h2><p><strong>解构赋值:</strong></p>
<blockquote>
<p>按照一定的模式，从数组或者对象中把数据拿出来，对变量进行赋值</p>
</blockquote>
<p><strong>数组解构赋值:</strong></p>
<blockquote>
<p>等号左边与右边必需都是数组，数组的解构赋值要一一对应。如果对应不上的话就是undefined</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">/*var a=1;  //传统声明变量</span></span><br><span class="line"><span class="comment">var b=2;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> [a,b,c]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];  <span class="comment">//可以使用数组进行批量声明变量</span></span><br><span class="line"><span class="built_in">console</span>.log(a,b,c);		<span class="comment">//1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x,,y,z]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];   <span class="comment">//数组的解构赋值要一一对应。如果对应不上的话就是undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(x,y,z);		<span class="comment">//1 3 undefined </span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> [a,[b,c]]=[<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>]];</span><br><span class="line"> <span class="built_in">console</span>.log(a,b,c);		<span class="comment">//1 2 3  可以嵌套</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//可以用来调换两个值</span></span><br><span class="line"> <span class="keyword">var</span> n1=<span class="number">10</span>;</span><br><span class="line"> <span class="keyword">var</span> n2=<span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> [n1,n2]=[n2,n1];</span><br><span class="line"> <span class="built_in">console</span>.log(n1,n2);		<span class="comment">//15 10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//也可以用来取函数的返回值</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> 	<span class="keyword">return</span> [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>];</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> [d,e,f]=fn();</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(e);		<span class="comment">//green</span></span><br></pre></td></tr></table></figure>
<h2 id="六、对象解构赋值"><a href="#六、对象解构赋值" class="headerlink" title="六、对象解构赋值"></a>六、对象解构赋值</h2><p><strong>解构赋值:</strong></p>
<blockquote>
<p>按照一定的模式，从数组或者对象中把数据拿出来，对变量进行赋值</p>
</blockquote>
<p><strong>对象解构赋值:</strong></p>
<blockquote>
<p>等号左边与右边必需都是对象，名字要一一对应，顺序不需要对应，对应不上的值结果是undefined</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line">			</span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	name:<span class="string">'kaivon'</span>,</span><br><span class="line">	QQ:<span class="number">356985332</span>,</span><br><span class="line">	language:[<span class="string">'css'</span>,<span class="string">'html'</span>,<span class="string">'js'</span>],</span><br><span class="line">	work:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'js'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;name,work,QQ,age&#125;=obj; <span class="comment">//等号左边与右边必需都是对象，名字要一一对应</span></span><br><span class="line"><span class="built_in">console</span>.log(name,work,QQ,age);<span class="comment">//kaivon 356985332 js undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用它来取一个对象的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		c1:<span class="string">'red'</span>,</span><br><span class="line">		c2:<span class="string">'green'</span>,</span><br><span class="line">		c3:<span class="string">'blue'</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;c1,c2,c3&#125;=fn();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c2);		<span class="comment">//green</span></span><br></pre></td></tr></table></figure>
<h2 id="七、字符串的扩展方法"><a href="#七、字符串的扩展方法" class="headerlink" title="七、字符串的扩展方法"></a>七、字符串的扩展方法</h2><blockquote>
<ul>
<li>includes(s) 字符串里面是否包含某个字符，参数是一个字符</li>
</ul>
</blockquote>
<ul>
<li>startsWidth(s) 字符串的开始位置的字符是否是参数的，参数是一个字符</li>
<li>endsWidth(s) 字符串的结束位置的字符是否是参数的，参数是一个字符</li>
</ul>
<p><strong>以上的几个方法都返回一个布尔值,包含有true,不包括为false</strong></p>
<ul>
<li>repeat(num) 复制字符串，参数为数字，表示复制的次数。参数必需是一个正数，其它的就会报错<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">'kaivon'</span>;   <span class="comment">//声明个字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">'i'</span>));			<span class="comment">//true 字符串里面包含 'i'</span></span><br><span class="line"><span class="built_in">console</span>.log(str.includes(<span class="string">'b'</span>));			<span class="comment">//false 字符串里面不包含 'b'</span></span><br><span class="line"><span class="built_in">console</span>.log(str.startsWith(<span class="string">'k'</span>));		<span class="comment">//true  开始位置包含'k'</span></span><br><span class="line"><span class="built_in">console</span>.log(str.endsWith(<span class="string">'n'</span>));			<span class="comment">//true  结束位置包含'n'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.repeat(<span class="number">3</span>));				<span class="comment">//kaivonkaivonkaivon 复制三次</span></span><br><span class="line"><span class="comment">//console.log(str.repeat(-1));				//报错 参数必需是一个正数，其它的就会报错</span></span><br><span class="line"><span class="comment">//console.log(str.repeat(Infinity));		//报错 参数必需是一个正数，其它的就会报错</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="八、模板字符串"><a href="#八、模板字符串" class="headerlink" title="八、模板字符串"></a>八、模板字符串</h2><p><strong>模板字符串：字符串及数据的拼接方式</strong></p>
<blockquote>
<p>1、字符串需要用一对反引号包起来，它可以定义多行字符串，只用一对反引号<br> 2、要拼进去的数据需要放在${}里面<br> 3、大括号里还可以进行运算<br> 4、大括号里还可以调用函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	title:‘心情‘,</span><br><span class="line">	content:’今天很爽，吃了饭，睡了觉，还打了豆豆‘</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> text=<span class="built_in">document</span>.getElementById(<span class="string">"text"</span>);</span><br><span class="line"><span class="comment">//text.innerHTML='&lt;h1&gt;'+obj.title+'&lt;/h1&gt;&lt;p&gt;'+obj.content+'&lt;/p&gt;'; //常规的拼接方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">'那么问题来了，豆豆爽么？'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要拼进去的数据需要放在$&#123;&#125;里面</span></span><br><span class="line"><span class="keyword">var</span> str1=<span class="string">`&lt;h1&gt;<span class="subst">$&#123;obj.title&#125;</span>&lt;/h1&gt;  </span></span><br><span class="line"><span class="string">			&lt;p&gt;<span class="subst">$&#123;obj.content&#125;</span>&lt;/p&gt;`</span>;</span><br><span class="line">			</span><br><span class="line"><span class="comment">//大括号里还可以进行运算</span></span><br><span class="line"><span class="keyword">var</span> str2=<span class="string">`&lt;h1&gt;<span class="subst">$&#123;obj.title+<span class="string">'+1'</span>&#125;</span>&lt;/h1&gt;    </span></span><br><span class="line"><span class="string">			&lt;p&gt;<span class="subst">$&#123;obj.content&#125;</span>&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str3=<span class="string">`&lt;h1&gt;<span class="subst">$&#123;obj.title+<span class="string">'+1'</span>&#125;</span>&lt;/h1&gt;</span></span><br><span class="line"><span class="string">			&lt;p&gt;<span class="subst">$&#123;obj.content+fn()&#125;</span>&lt;/p&gt;`</span>;    <span class="comment">//大括号里还可以调用函数</span></span><br><span class="line">			</span><br><span class="line"><span class="comment">//text.innerHTML=str1;</span></span><br><span class="line"><span class="comment">//text.innerHTML=str2;</span></span><br><span class="line"><span class="comment">//text.innerHTML=str3;</span></span><br></pre></td></tr></table></figure>

<h2 id="九、Math对象的扩展方法"><a href="#九、Math对象的扩展方法" class="headerlink" title="九、Math对象的扩展方法"></a>九、Math对象的扩展方法</h2><p><strong>Math.trunc(num): 去除小数部分，是直接把小数部分去掉</strong></p>
<blockquote>
<p>1、对于非数值，先调用Number方法把它转成数字<br>2、对于空值和无法转成数字的值，结果是NaN</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">12.74</span>));			<span class="comment">//12</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="number">0.5</span>));			<span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="string">'36.01'</span>));		<span class="comment">//36</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.trunc(<span class="string">'kaivon'</span>));		<span class="comment">//NaN</span></span><br></pre></td></tr></table></figure>

<p><strong>Math.sign(num): 判断一个数是正数还是负数还是0</strong></p>
<blockquote>
<p>1、参数为正数，返回1<br>2、参数为负数，返回-1<br>3、参数为0，返回0<br>4、参数为-0，返回-0<br>5、参数为其它值，返回NaN</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Math.sign(5));				&#x2F;&#x2F;1</span><br><span class="line">console.log(Math.sign(-5));				&#x2F;&#x2F;-1</span><br><span class="line">console.log(Math.sign(0));				&#x2F;&#x2F;0</span><br><span class="line">console.log(Math.sign(-0));				&#x2F;&#x2F;-0</span><br><span class="line">console.log(Math.sign(&#39;kaivon&#39;));		&#x2F;&#x2F;NaN</span><br></pre></td></tr></table></figure>
<h2 id="十、数组的扩展方法"><a href="#十、数组的扩展方法" class="headerlink" title="十、数组的扩展方法"></a>十、数组的扩展方法</h2><h3 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a><strong>Array.from()</strong></h3><blockquote>
<p>把类数组转成真正的数组 任何有length属性的对象都可以用这个方法转真正数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">	&lt;li&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">	&lt;li&gt;&lt;/</span>li&gt;</span><br><span class="line">	&lt;li&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">	&lt;li&gt;&lt;/</span>li&gt;</span><br><span class="line">	&lt;li&gt;&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">var</span> lis=<span class="built_in">document</span>.querySelectorAll(<span class="string">"li"</span>);</span><br><span class="line"><span class="comment">//console.log(lis);</span></span><br><span class="line"><span class="keyword">var</span> newLis=[].slice.call(lis); <span class="comment">//利用以前的方法将类数组转换为数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> newLis=<span class="built_in">Array</span>.from(lis);     <span class="comment">//Array.from() 把类数组转成真正的数组</span></span><br><span class="line"><span class="built_in">console</span>.log(newLis);			<span class="comment">//[li, li, li, li, li]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">'kaivon'</span>;</span><br><span class="line"><span class="keyword">var</span> newStr=<span class="built_in">Array</span>.from(str);     <span class="comment">//任何有length属性的对象都可以用这个方法转真正数组</span></span><br><span class="line"><span class="built_in">console</span>.log(newStr);			<span class="comment">//["k", "a", "i", "v", "o", "n"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象身上只要有length属性就可以调用Array.from()把对象转成数组,对象中的key必需是从0开始的数字才能转</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj=&#123;</span><br><span class="line">	<span class="number">0</span>:<span class="string">'red'</span>,</span><br><span class="line">	<span class="number">1</span>:<span class="string">'green'</span>,</span><br><span class="line">	<span class="number">2</span>:<span class="string">'blue'</span>,</span><br><span class="line">	<span class="number">3</span>:<span class="string">'yellow'</span>,</span><br><span class="line">	length:<span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(obj)); <span class="comment">// ['red','green','blue','yellow']</span></span><br></pre></td></tr></table></figure>
<h3 id="Array-of"><a href="#Array-of" class="headerlink" title="Array.of()"></a><strong>Array.of()</strong></h3><blockquote>
<p>把一组数值转成真正的数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Array</span>());		<span class="comment">//[]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>));		<span class="comment">//[, , ,]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));	<span class="comment">//[1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>));		<span class="comment">//[1]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));	<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong>filter</strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//假定有一个对象数组(A),获取数组中指定类型的对象放到B数组中 </span></span><br><span class="line"><span class="keyword">var</span> porducts = [</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">"cucumber"</span>,<span class="attr">type</span>:<span class="string">"vegetable"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">"banana"</span>,<span class="attr">type</span>:<span class="string">"fruit"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">"celery"</span>,<span class="attr">type</span>:<span class="string">"vegetable"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">"orange"</span>,<span class="attr">type</span>:<span class="string">"fruit"</span>&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">var</span> filteredProducts = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; porducts.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(porducts[i].type === <span class="string">"fruit"</span>)&#123;</span><br><span class="line">      filteredProducts.push(porducts[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 filter</span></span><br><span class="line"><span class="keyword">var</span> filtered2 = porducts.filter(<span class="function"><span class="keyword">function</span>(<span class="params">product</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> product.type === <span class="string">"vegetable"</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// * 假定有一个对象数组(A),过滤掉不满足以下条件的对象</span></span><br><span class="line"><span class="comment">// * 条件: 蔬菜 数量大于0,价格小于10</span></span><br><span class="line"><span class="keyword">var</span> products = [</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">"cucumber"</span>,<span class="attr">type</span>:<span class="string">"vegetable"</span>,<span class="attr">quantity</span>:<span class="number">0</span>,<span class="attr">price</span>:<span class="number">1</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">"banana"</span>,<span class="attr">type</span>:<span class="string">"fruit"</span>,<span class="attr">quantity</span>:<span class="number">10</span>,<span class="attr">price</span>:<span class="number">16</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">"celery"</span>,<span class="attr">type</span>:<span class="string">"vegetable"</span>,<span class="attr">quantity</span>:<span class="number">30</span>,<span class="attr">price</span>:<span class="number">8</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>:<span class="string">"orange"</span>,<span class="attr">type</span>:<span class="string">"fruit"</span>,<span class="attr">quantity</span>:<span class="number">3</span>,<span class="attr">price</span>:<span class="number">6</span>&#125;</span><br><span class="line">];</span><br><span class="line">products = products.filter(<span class="function"><span class="keyword">function</span>(<span class="params">product</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> product.type === <span class="string">"vegetable"</span> </span><br><span class="line">    &amp;&amp; product.quantity &gt; <span class="number">0</span> </span><br><span class="line">    &amp;&amp; product.price &lt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// * 假定有两个数组(A,B),根据A中id值,过滤掉B数组不符合的数据</span></span><br><span class="line"> <span class="keyword">var</span> comments = [</span><br><span class="line">    &#123;<span class="attr">postId</span>:<span class="number">4</span>,<span class="attr">content</span>:<span class="string">"Angular4"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">postId</span>:<span class="number">2</span>,<span class="attr">content</span>:<span class="string">"Vue.js"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">postId</span>:<span class="number">3</span>,<span class="attr">content</span>:<span class="string">"Node.js"</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">postId</span>:<span class="number">4</span>,<span class="attr">content</span>:<span class="string">"React.js"</span>&#125;,</span><br><span class="line"> ];</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">commentsForPost</span>(<span class="params">post,comments</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> comments.filter(<span class="function"><span class="keyword">function</span>(<span class="params">comment</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> comment.postId === post.id;</span><br><span class="line">    &#125;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="built_in">console</span>.log(commentsForPost(post,comments));</span><br></pre></td></tr></table></figure>

<h3 id="Array-includes"><a href="#Array-includes" class="headerlink" title="Array.includes"></a><strong>Array.includes</strong></h3><blockquote>
<p>(数据,起始位置)    查找数组中有没有某个数据</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>,<span class="string">'yellow'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="string">'red'</span>));		<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="string">'pink'</span>));		<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.includes(<span class="string">'green'</span>,<span class="number">2</span>));	<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历相关"><a href="#遍历相关" class="headerlink" title="遍历相关"></a><strong>遍历相关</strong></h3><blockquote>
<ul>
<li>for in        循环，能够直接读取键名</li>
</ul>
</blockquote>
<ul>
<li>for of        循环，能够直接读取键值<ul>
<li>它不光可以遍历数组或者对象，只要有遍历接口的对象都可以用它</li>
</ul>
</li>
<li>keys()        存储了数组的所有键名</li>
<li>values()        存储了数组的所有键值</li>
<li>entries()        存储了数组的所有键值对<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">var</span> color=[<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'blue'</span>,<span class="string">'yellow'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//for in</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> attr <span class="keyword">in</span> color)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(attr);	<span class="comment">//0 1 2 3 直接读取键名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for of</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> color)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value);	<span class="comment">//red green blue yellow 直接读取键值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串也可以使用for of</span></span><br><span class="line"><span class="keyword">var</span> str=<span class="string">'kaivon'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> value <span class="keyword">of</span> str)&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(value);		<span class="comment">//k a i v o n 只要有遍历接口的对象都可以用它</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历keys</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">of</span> color.keys())&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(key);		<span class="comment">//0 1 2 3 存储了数组的所有键名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历values</span></span><br><span class="line"><span class="comment">/*for(var value of color.values())&#123;  存储了数组的所有键值</span></span><br><span class="line"><span class="comment">	console.log(value);		//red green blue yellow	提示一下，chrom还不支持</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历entries</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> [key,value] <span class="keyword">of</span> color.entries())&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(key,value);	<span class="comment">//0 "red"	 1 "green"	2 "blue"		3 "yellow"  存储了数组的所有键值对</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="map遍历"><a href="#map遍历" class="headerlink" title="map遍历"></a>map遍历</h3><blockquote>
<p>遍历数据或者对象，并映射新对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//场景1</span></span><br><span class="line"><span class="comment">//假定有一个数值数组(A),将A数组中的值以双倍的形式放到B数组 </span></span><br><span class="line"> <span class="keyword">var</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"> <span class="keyword">var</span> doubledNumbers = [];</span><br><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)&#123;</span><br><span class="line">  doubledNumbers.push(numbers[i] * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 map</span></span><br><span class="line"><span class="keyword">var</span> doubled = numbers.map(<span class="function"><span class="keyword">function</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> number * <span class="number">2</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//场景1</span></span><br><span class="line"><span class="comment">//假定有一个对象数组(A),将A数中对象某个属性的值存储到B数组中</span></span><br><span class="line"><span class="keyword">var</span> cars = [</span><br><span class="line">  &#123;<span class="attr">model</span>:<span class="string">"Buick"</span>,<span class="attr">price</span>:<span class="string">"CHEAP"</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">model</span>:<span class="string">"BMW"</span>,<span class="attr">price</span>:<span class="string">"expensive"</span>&#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> prices = cars.map(<span class="function"><span class="keyword">function</span>(<span class="params">car</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> car.price;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="十一、函数参数默认值"><a href="#十一、函数参数默认值" class="headerlink" title="十一、函数参数默认值"></a>十一、函数参数默认值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">	b=b||<span class="string">'kaivon'</span>;  <span class="comment">//以往设置默认参数方法</span></span><br><span class="line">	<span class="built_in">console</span>.log(a,b);</span><br><span class="line">&#125;</span><br><span class="line">fn(<span class="string">'hello'</span>);		<span class="comment">//hello kaivon</span></span><br><span class="line">fn(<span class="string">'hello'</span>,<span class="string">'moto'</span>);	<span class="comment">//hello moto</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参数变量是默认声明的，不能用let或者const再次声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params">a=<span class="number">20</span>,b=<span class="number">10</span></span>)</span>&#123;    <span class="comment">//直接将默认参数写在函数括号中</span></span><br><span class="line">	<span class="comment">//console.log(a,b);		//20 10</span></span><br><span class="line">	<span class="comment">//let a=12;				//报错</span></span><br><span class="line">	<span class="built_in">console</span>.log(a+b);       <span class="comment">//30</span></span><br><span class="line">&#125;</span><br><span class="line">fn2();			<span class="comment">//30</span></span><br><span class="line">fn2(<span class="number">23</span>,<span class="number">45</span>);		<span class="comment">//68</span></span><br></pre></td></tr></table></figure>
<h2 id="十二、箭头函数"><a href="#十二、箭头函数" class="headerlink" title="十二、箭头函数"></a>十二、箭头函数</h2><blockquote>
<p><strong>语法：</strong><br>1、function用var、let、const来表示<br>2、参数要写在第一个等号后面</p>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>1、如果没有参数，需要写一对空的小括号</li>
</ul>
</blockquote>
<ul>
<li>2、只有一个参数，那就直接写，不用加括号</li>
<li>3、参数有多个，需要加一个小括号，参数用逗号隔开<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">/*function fn1()&#123;</span></span><br><span class="line"><span class="comment">	console.log('kaivon');</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">fn1();*/</span> <span class="comment">//常规写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1=<span class="function"><span class="params">()</span>=&gt;</span><span class="built_in">console</span>.log(<span class="string">'kaivon'</span>);  <span class="comment">//es5写法 如果没有参数，需要写一对空的小括号</span></span><br><span class="line">fn1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn2=<span class="function"><span class="params">a</span>=&gt;</span><span class="built_in">console</span>.log(a);  <span class="comment">//只有一个参数，那就直接写，不用加括号</span></span><br><span class="line">fn2(<span class="string">'kaivon'</span>);			<span class="comment">//kaivon</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn3=<span class="function">(<span class="params">a,b</span>)=&gt;</span>&#123;      <span class="comment">//参数有多个，需要加一个小括号，参数用逗号隔开</span></span><br><span class="line">	<span class="keyword">let</span> result=a+b;</span><br><span class="line">	<span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line">fn3(<span class="number">1</span>,<span class="number">2</span>);		<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<h2 id="十三、对象的简洁表示法"><a href="#十三、对象的简洁表示法" class="headerlink" title="十三、对象的简洁表示法"></a>十三、对象的简洁表示法</h2>属性与方法都可以简洁表示 , 当属性与值的变量同名时。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="comment">/*function fn()&#123;</span></span><br><span class="line"><span class="comment">	var x=10;</span></span><br><span class="line"><span class="comment">	var y=20;</span></span><br><span class="line"><span class="comment">	function sum()&#123;</span></span><br><span class="line"><span class="comment">		return x+y;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	return &#123;x:x,y:y,sum:sum&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">console.log(fn());*/</span>        <span class="comment">//常规获取函数内部变量及方法</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;              <span class="comment">//ES6获取函数内部变量及方法</span></span><br><span class="line">	<span class="keyword">var</span> x=<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">var</span> y=<span class="number">20</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x+y;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		x,</span><br><span class="line">		y,</span><br><span class="line">		sum()&#123;</span><br><span class="line">			<span class="keyword">return</span> x+y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn());</span><br><span class="line"><span class="built_in">console</span>.log(fn().sum())			<span class="comment">//30</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'Jane'</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name,</span><br><span class="line">  age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: name,</span><br><span class="line">  age: age</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="十四、属性名表达式"><a href="#十四、属性名表达式" class="headerlink" title="十四、属性名表达式"></a>十四、属性名表达式</h2></li>
<li><em>可以把表达式放在中括号里作为属性名*</em><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> key=<span class="string">'interest'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj=&#123;</span><br><span class="line">	name:<span class="string">'kaivon'</span>,</span><br><span class="line">	[key]:<span class="string">'打豆豆'</span>,</span><br><span class="line">	[<span class="string">'show'</span>]()&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure>
<h2 id="十五、Object-is"><a href="#十五、Object-is" class="headerlink" title="十五、Object.is()"></a>十五、Object.is()</h2></li>
<li><em>比较两个值是否相等，与===的结果一样，但是还是有一些区别*</em><blockquote>
<ul>
<li>返回的结果是一个布尔值<br>区别:</li>
</ul>
</blockquote>
<ul>
<li>1、+0与-0比较的结果为false</li>
<li>2、NaN与NaN比较的结果为true<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="string">'kaivon'</span>,<span class="string">'kaivon'</span>));		<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(+<span class="number">0</span>===<span class="number">-0</span>);			<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(+<span class="number">0</span>,<span class="number">-0</span>));	<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span>===<span class="literal">NaN</span>);			<span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>,<span class="literal">NaN</span>));	<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h2 id="十六、Object-is"><a href="#十六、Object-is" class="headerlink" title="十六、Object.is()"></a>十六、Object.is()</h2></li>
</ul>
</li>
<li><em>将一个对象身上的属性复制到另一个对象身上*</em><blockquote>
<ul>
<li>至少需要两个参数</li>
</ul>
</blockquote>
<ul>
<li>1、第一个参数为合并后的对象</li>
<li>2、从第二个参数开始往后就是所有要合并的对象</li>
<li>3、如果有同名的属性，后面会把前面覆盖了</li>
<li>4、如果有嵌套的对象，是覆盖并不是添加</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">var</span> obj1=&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=&#123;<span class="attr">b</span>:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj3=&#123;<span class="attr">a</span>:<span class="number">4</span>,<span class="attr">c</span>:<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(obj1,obj2,obj3);</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">//&#123;a:1,b:2,c:3&#125;  //如果有同名的属性，后面会把前面覆盖了</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//封装个函数</span></span><br><span class="line"><span class="keyword">const</span> merge=<span class="function">(<span class="params">target,...souce</span>)=&gt;</span>&#123;</span><br><span class="line">	<span class="built_in">Object</span>.assign(target,...souce);</span><br><span class="line">	<span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(merge(obj1,obj2,obj3));		<span class="comment">//Object &#123;a: 4, b: 2, c: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有嵌套的对象，是覆盖并不是添加</span></span><br><span class="line"><span class="keyword">var</span> obj4=&#123;</span><br><span class="line">	d:&#123;</span><br><span class="line">		e:<span class="number">5</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj5=&#123;</span><br><span class="line">	d:&#123;</span><br><span class="line">		f:<span class="number">6</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(merge(&#123;&#125;,obj4,obj5)); <span class="comment">//&#123;a: 4, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="十七、Set数据结构"><a href="#十七、Set数据结构" class="headerlink" title="十七、Set数据结构"></a>十七、Set数据结构</h2><p><strong>Set 数据结构，类似数组。所有的数据都是唯一的，没有重复的值。它本身是一个构造函数</strong></p>
<blockquote>
<ul>
<li>size    数据的长度</li>
</ul>
</blockquote>
<ul>
<li>add()        添加一个数据</li>
<li>deleate()    删除一个数据</li>
<li>has()        查找某条数据，返回一个布尔值</li>
<li>clear()    删除所有数据<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">set</span>=new Set([1,3,4,5,4,3,2]);</span><br><span class="line"><span class="keyword">set</span>.add(6);     //在数据结构中添加 6 </span><br><span class="line"><span class="keyword">set</span>.delete(1);  //在数据结构中删除 1</span><br><span class="line">console.log(<span class="keyword">set</span>.has(5));    //true 在数据结构中查找是否有 5</span><br><span class="line"><span class="keyword">set</span>.clear();    //删除所有数据内容</span><br><span class="line">console.log(<span class="keyword">set</span>,<span class="keyword">set</span>.size);			//Set &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>&#125; <span class="number">5</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="十八、-展开运算符"><a href="#十八、-展开运算符" class="headerlink" title="十八、 展开运算符"></a>十八、 展开运算符</h2><p><strong>在ES6中用…来表示展开运算符，它可以将数组方法或者对象进行展开。先来看一个例子它是如何使用的。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [...arr1, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="comment">// 这样，arr2 就变成了[1, 2, 3, 10, 20, 30];</span></span><br></pre></td></tr></table></figure>
<p>当然，展开对象数据也是可以得到类似的结果</p>
<p>```<br>const obj1 = {<br>  a: 1,<br>  b: 2,<br>  c: 3<br>}</p>
<p>const obj2 = {<br>  …obj1,<br>  d: 4,<br>  e: 5,<br>  f: 6<br>}</p>
<p>// 结果类似于 const obj2 = Object.assign({}, obj1, {d: 4})</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome插件开发-极速入门教程（必看）</title>
    <url>/2020/03/30/Chrome%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91-%E4%B8%80/</url>
    <content><![CDATA[<h1 id="1、写在前面"><a href="#1、写在前面" class="headerlink" title="1、写在前面"></a>1、写在前面</h1><p>Chrome插件是一个用Web技术开发、用来增强浏览器功能的软件,Chrome浏览器扩展开发算是相当简单的，基本只要掌握HTML+CSS+Javascript，即可快速开发一个属于你的Chrome插件！它其实就是一个由HTML、CSS、JS、图片等资源组成的一个.crx后缀的压缩包.</p>
<h1 id="2-学习Chrome插件开发有什么意义"><a href="#2-学习Chrome插件开发有什么意义" class="headerlink" title="2. 学习Chrome插件开发有什么意义"></a>2. 学习Chrome插件开发有什么意义</h1><p>增强浏览器功能，轻松实现属于自己的“定制版”浏览器，等等。</p>
<p>Chrome插件提供了很多实用API供我们使用，包括但不限于：</p>
<ul>
<li>书签控制；</li>
<li>下载控制；</li>
<li>窗口控制；</li>
<li>标签控制；</li>
<li>网络请求控制，</li>
<li>各类事件监听；</li>
<li>自定义原生菜单；</li>
<li>完善的通信机制；</li>
<li>等等；</li>
</ul>
<p><strong>详细目录</strong><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200404113340.png" alt=""></p>
<p><strong>demo部分截图：</strong><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200404113442.png" alt=""></p>
<h1 id="3-为什么是Chrome插件而不是Firefox插件"><a href="#3-为什么是Chrome插件而不是Firefox插件" class="headerlink" title="3. 为什么是Chrome插件而不是Firefox插件"></a>3. 为什么是Chrome插件而不是Firefox插件</h1><ul>
<li>Chrome占有率更高，更多人用；</li>
<li>开发更简单；</li>
<li>应用场景更广泛，Firefox插件只能运行在Firefox上，而Chrome除了Chrome浏览器之外，还可以运行在所有webkit内核的国产浏览器，比如360极速浏览器、360安全浏览器、搜狗浏览器、QQ浏览器等等；</li>
<li>除此之外，Firefox浏览器也对Chrome插件的运行提供了一定的支持；</li>
</ul>
<h1 id="4-开发与调试"><a href="#4-开发与调试" class="headerlink" title="4. 开发与调试"></a>4. 开发与调试</h1><p>Chrome插件没有严格的项目结构要求，只要保证本目录有一个manifest.json即可，也不需要专门的IDE，普通的web开发工具即可。<br>从右上角菜单-&gt;更多工具-&gt;扩展程序可以进入 插件管理页面，也可以直接在地址栏输入 chrome://extensions 访问。</p>
<p><img src="http://image.liuxianan.com/201706/20170620_195047_992_5668.png" alt="此处输入图片的描述"></p>
<p>勾选开发者模式即可以文件夹的形式直接加载插件，否则只能安装.crx格式的文件。Chrome要求插件必须从它的Chrome应用商店安装，其它任何网站下载的都无法直接安装，所以，其实我们可以把crx文件解压，然后通过开发者模式直接加载。</p>
<p>开发中，代码有任何改动都必须重新加载插件，只需要在插件管理页按下Ctrl+R即可，以防万一最好还把页面刷新一下。</p>
<h1 id="5-核心介绍"><a href="#5-核心介绍" class="headerlink" title="5. 核心介绍"></a>5. 核心介绍</h1><h2 id="5-1-manifest-json"><a href="#5-1-manifest-json" class="headerlink" title="5.1 manifest.json"></a>5.1 manifest.json</h2><p>这是一个Chrome插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，manifest_version、name、version3个是必不可少的，description和icons是推荐的。</p>
<p>下面给出的是一些常见的配置项，均有中文注释，完整的配置文档请戳 <a href="https://developer.chrome.com/extensions/manifest" target="_blank" rel="noopener">这里</a> 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 清单文件的版本，这个必须写，而且必须是2</span></span><br><span class="line">	<span class="string">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="comment">// 插件的名称</span></span><br><span class="line">	<span class="string">"name"</span>: <span class="string">"demo"</span>,</span><br><span class="line">	<span class="comment">// 插件的版本</span></span><br><span class="line">	<span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">	<span class="comment">// 插件描述</span></span><br><span class="line">	<span class="string">"description"</span>: <span class="string">"简单的Chrome扩展demo"</span>,</span><br><span class="line">	<span class="comment">// 图标，一般偷懒全部用一个尺寸的也没问题</span></span><br><span class="line">	<span class="string">"icons"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"16"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="string">"48"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="string">"128"</span>: <span class="string">"img/icon.png"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 会一直常驻的后台JS或后台页面</span></span><br><span class="line">	<span class="string">"background"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 2种指定方式，如果指定JS，那么会自动生成一个背景页</span></span><br><span class="line">		<span class="string">"page"</span>: <span class="string">"background.html"</span></span><br><span class="line">		<span class="comment">//"scripts": ["js/background.js"]</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 浏览器右上角图标设置，browser_action、page_action、app必须三选一</span></span><br><span class="line">	<span class="string">"browser_action"</span>: </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"default_icon"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="comment">// 图标悬停时的标题，可选</span></span><br><span class="line">		<span class="string">"default_title"</span>: <span class="string">"这是一个示例Chrome插件"</span>,</span><br><span class="line">		<span class="string">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 当某些特定页面打开才显示的图标</span></span><br><span class="line">	<span class="comment">/*"page_action":</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		"default_icon": "img/icon.png",</span></span><br><span class="line"><span class="comment">		"default_title": "我是pageAction",</span></span><br><span class="line"><span class="comment">		"default_popup": "popup.html"</span></span><br><span class="line"><span class="comment">	&#125;,*/</span></span><br><span class="line">	<span class="comment">// 需要直接注入页面的JS</span></span><br><span class="line">	<span class="string">"content_scripts"</span>: </span><br><span class="line">	[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//"matches": ["http://*/*", "https://*/*"],</span></span><br><span class="line">			<span class="comment">// "&lt;all_urls&gt;" 表示匹配所有地址</span></span><br><span class="line">			<span class="string">"matches"</span>: [<span class="string">"&lt;all_urls&gt;"</span>],</span><br><span class="line">			<span class="comment">// 多个JS按顺序注入</span></span><br><span class="line">			<span class="string">"js"</span>: [<span class="string">"js/jquery-1.8.3.js"</span>, <span class="string">"js/content-script.js"</span>],</span><br><span class="line">			<span class="comment">// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式</span></span><br><span class="line">			<span class="string">"css"</span>: [<span class="string">"css/custom.css"</span>],</span><br><span class="line">			<span class="comment">// 代码注入的时间，可选值： "document_start", "document_end", or "document_idle"，最后一个表示页面空闲时，默认document_idle</span></span><br><span class="line">			<span class="string">"run_at"</span>: <span class="string">"document_start"</span></span><br><span class="line">		&#125;,</span><br><span class="line">		<span class="comment">// 这里仅仅是为了演示content-script可以配置多个规则</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">"matches"</span>: [<span class="string">"*://*/*.png"</span>, <span class="string">"*://*/*.jpg"</span>, <span class="string">"*://*/*.gif"</span>, <span class="string">"*://*/*.bmp"</span>],</span><br><span class="line">			<span class="string">"js"</span>: [<span class="string">"js/show-image-content-size.js"</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">	<span class="comment">// 权限申请</span></span><br><span class="line">	<span class="string">"permissions"</span>:</span><br><span class="line">	[</span><br><span class="line">		<span class="string">"contextMenus"</span>, <span class="comment">// 右键菜单</span></span><br><span class="line">		<span class="string">"tabs"</span>, <span class="comment">// 标签</span></span><br><span class="line">		<span class="string">"notifications"</span>, <span class="comment">// 通知</span></span><br><span class="line">		<span class="string">"webRequest"</span>, <span class="comment">// web请求</span></span><br><span class="line">		<span class="string">"webRequestBlocking"</span>,</span><br><span class="line">		<span class="string">"storage"</span>, <span class="comment">// 插件本地存储</span></span><br><span class="line">		<span class="string">"http://*/*"</span>, <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">		<span class="string">"https://*/*"</span> <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">	],</span><br><span class="line">	<span class="comment">// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span></span><br><span class="line">	<span class="string">"web_accessible_resources"</span>: [<span class="string">"js/inject.js"</span>],</span><br><span class="line">	<span class="comment">// 插件主页，这个很重要，不要浪费了这个免费广告位</span></span><br><span class="line">	<span class="string">"homepage_url"</span>: <span class="string">"https://www.baidu.com"</span>,</span><br><span class="line">	<span class="comment">// 覆盖浏览器默认页面</span></span><br><span class="line">	<span class="string">"chrome_url_overrides"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 覆盖浏览器默认的新标签页</span></span><br><span class="line">		<span class="string">"newtab"</span>: <span class="string">"newtab.html"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// Chrome40以前的插件配置页写法</span></span><br><span class="line">	<span class="string">"options_page"</span>: <span class="string">"options.html"</span>,</span><br><span class="line">	<span class="comment">// Chrome40以后的插件配置页写法，如果2个都写，新版Chrome只认后面这一个</span></span><br><span class="line">	<span class="string">"options_ui"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"page"</span>: <span class="string">"options.html"</span>,</span><br><span class="line">		<span class="comment">// 添加一些默认的样式，推荐使用</span></span><br><span class="line">		<span class="string">"chrome_style"</span>: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="comment">// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字</span></span><br><span class="line">	<span class="string">"omnibox"</span>: &#123; <span class="string">"keyword"</span> : <span class="string">"go"</span> &#125;,</span><br><span class="line">	<span class="comment">// 默认语言</span></span><br><span class="line">	<span class="string">"default_locale"</span>: <span class="string">"zh_CN"</span>,</span><br><span class="line">	<span class="comment">// devtools页面入口，注意只能指向一个HTML文件，不能是JS文件</span></span><br><span class="line">	<span class="string">"devtools_page"</span>: <span class="string">"devtools.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-content-scripts"><a href="#5-2-content-scripts" class="headerlink" title="5.2 content-scripts"></a>5.2 content-scripts</h2><p>所谓content-scripts，其实就是Chrome插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助content-scripts我们可以实现通过配置的方式轻松向指定页面注入JS和CSS（如果需要动态注入，可以参考下文），最常见的比如：广告屏蔽、页面CSS定制，等等。</p>
<p>示例配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 需要直接注入页面的JS</span></span><br><span class="line">	<span class="string">"content_scripts"</span>: </span><br><span class="line">	[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//"matches": ["http://*/*", "https://*/*"],</span></span><br><span class="line">			<span class="comment">// "&lt;all_urls&gt;" 表示匹配所有地址</span></span><br><span class="line">			<span class="string">"matches"</span>: [<span class="string">"&lt;all_urls&gt;"</span>],</span><br><span class="line">			<span class="comment">// 多个JS按顺序注入</span></span><br><span class="line">			<span class="string">"js"</span>: [<span class="string">"js/jquery-1.8.3.js"</span>, <span class="string">"js/content-script.js"</span>],</span><br><span class="line">			<span class="comment">// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式</span></span><br><span class="line">			<span class="string">"css"</span>: [<span class="string">"css/custom.css"</span>],</span><br><span class="line">			<span class="comment">// 代码注入的时间，可选值： "document_start", "document_end", or "document_idle"，最后一个表示页面空闲时，默认document_idle</span></span><br><span class="line">			<span class="string">"run_at"</span>: <span class="string">"document_start"</span></span><br><span class="line">		&#125;</span><br><span class="line">	],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特别注意，如果没有主动指定run_at为document_start（默认为document_idle），下面这种代码是不会生效的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'我被执行了！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>content-scripts和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过injected js来实现。content-scripts不能访问绝大部分chrome.xxx.api，除了下面这4种：</p>
<ul>
<li>chrome.extension(getURL , inIncognitoContext , lastError , onRequest , sendRequest)</li>
<li>chrome.i18n</li>
<li>chrome.runtime(connect , getManifest , getURL , id , onConnect , onMessage , sendMessage)</li>
<li>chrome.storage</li>
</ul>
<p>其实看到这里不要悲观，这些API绝大部分时候都够用了，非要调用其它API的话，你还可以通过通信来实现让background来帮你调用（关于通信，后文有详细介绍）。</p>
<p>好了，Chrome插件给我们提供了这么强大的JS注入功能，剩下的就是发挥你的想象力去玩弄浏览器了。</p>
<h2 id="5-3-background"><a href="#5-3-background" class="headerlink" title="5.3 background"></a>5.3 background</h2><p>后台（姑且这么翻译吧），是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。</p>
<p>background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置CORS。</p>
<blockquote>
<p>经过测试，其实不止是background，所有的直接通过chrome-extension://id/xx.html这种方式打开的网页都可以无限制跨域。</p>
</blockquote>
<p>配置中，background可以通过page指定一张网页，也可以通过scripts直接指定一个JS，Chrome会自动为这个JS生成一个默认的网页：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 会一直常驻的后台JS或后台页面</span></span><br><span class="line">	<span class="string">"background"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 2种指定方式，如果指定JS，那么会自动生成一个背景页</span></span><br><span class="line">		<span class="string">"page"</span>: <span class="string">"background.html"</span></span><br><span class="line">		<span class="comment">//"scripts": ["js/background.js"]</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-event-pages"><a href="#5-4-event-pages" class="headerlink" title="5.4 event-pages"></a>5.4 event-pages</h2><p>这里顺带介绍一下event-pages，它是一个什么东西呢？鉴于background生命周期太长，长时间挂载后台可能会影响性能，所以Google又弄一个event-pages，在配置文件上，它与background的唯一区别就是多了一个persistent参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"background"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"scripts"</span>: [<span class="string">"event-page.js"</span>],</span><br><span class="line">		<span class="string">"persistent"</span>: <span class="literal">false</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有content-script向它发送消息，等等。</p>
<p>除了配置文件的变化，代码上也有一些细微变化，个人这个简单了解一下就行了，一般情况下background也不会很消耗性能的。</p>
<h2 id="5-5-popup"><a href="#5-5-popup" class="headerlink" title="5.5 popup"></a>5.5 popup</h2><p>popup是点击browser_action或者page_action图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。</p>
<p><img src="http://image.liuxianan.com/201706/20170619_161102_335_9254.png" alt="此处输入图片的描述"></p>
<p>popup可以包含任意你想要的HTML内容，并且会自适应大小。可以通过default_popup字段来指定popup页面，也可以调用setPopup()方法。</p>
<p>配置方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"browser_action"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"default_icon"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="comment">// 图标悬停时的标题，可选</span></span><br><span class="line">		<span class="string">"default_title"</span>: <span class="string">"这是一个示例Chrome插件"</span>,</span><br><span class="line">		<span class="string">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，由于单击图标打开popup，焦点离开又立即关闭，所以popup页面的生命周期一般很短，需要长时间运行的代码千万不要写在popup里面。</p>
<p>在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同，popup中可以直接通过chrome.extension.getBackgroundPage()获取background的window对象。</p>
<h2 id="5-6-injected-script"><a href="#5-6-injected-script" class="headerlink" title="5.6 injected-script"></a>5.6 injected-script</h2><p>这里的injected-script是我给它取的，指的是通过DOM操作的方式向页面注入的一种JS。为什么要把这种JS单独拿出来讨论呢？又或者说为什么需要通过这种方式注入JS呢？</p>
<p>这是因为content-script有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用content-script中的代码（包括直接写onclick和addEventListener2种方式都不行），但是，“在页面上添加一个按钮并调用插件的扩展API”是一个很常见的需求，那该怎么办呢？其实这就是本小节要讲的。</p>
<p>在content-script中通过DOM方式向页面注入inject-script代码示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向页面注入JS</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">injectCustomJs</span>(<span class="params">jsPath</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	jsPath = jsPath || <span class="string">'js/inject.js'</span>;</span><br><span class="line">	<span class="keyword">var</span> temp = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">	temp.setAttribute(<span class="string">'type'</span>, <span class="string">'text/javascript'</span>);</span><br><span class="line">	<span class="comment">// 获得的地址类似：chrome-extension://ihcokhadfjfchaeagdoclpnjdiokfakg/js/inject.js</span></span><br><span class="line">	temp.src = chrome.extension.getURL(jsPath);</span><br><span class="line">	temp.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 放在页面不好看，执行完后移除掉</span></span><br><span class="line">		<span class="keyword">this</span>.parentNode.removeChild(<span class="keyword">this</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="built_in">document</span>.head.appendChild(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你以为这样就行了？执行一下你会看到如下报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Denying load <span class="keyword">of</span> chrome-extension:<span class="comment">//efbllncjkjiijkppagepehoekjojdclc/js/inject.js. Resources must be listed in the web_accessible_resources manifest key in order to be loaded by pages outside the extension.</span></span><br></pre></td></tr></table></figure>
<p>意思就是你想要在web中直接访问插件中的资源的话必须显示声明才行，配置文件中增加如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的</span></span><br><span class="line">	<span class="string">"web_accessible_resources"</span>: [<span class="string">"js/inject.js"</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于inject-script如何调用content-script中的代码，后面我会在专门的一个消息通信章节详细介绍。</p>
<h2 id="5-7-homepage-url"><a href="#5-7-homepage-url" class="headerlink" title="5.7 homepage_url"></a>5.7 homepage_url</h2><p>开发者或者插件主页设置，一般会在如下2个地方显示：<br><img src="http://image.liuxianan.com/201705/20170531_105821_586_0442.png" alt="此处输入图片的描述"></p>
<p><img src="http://image.liuxianan.com/201705/20170531_105907_256_9087.png" alt="此处输入图片的描述"></p>
<h1 id="6-Chrome插件的8种展示形式"><a href="#6-Chrome插件的8种展示形式" class="headerlink" title="6. Chrome插件的8种展示形式"></a>6. Chrome插件的8种展示形式</h1><h2 id="6-1-browserAction-浏览器右上角"><a href="#6-1-browserAction-浏览器右上角" class="headerlink" title="6.1. browserAction(浏览器右上角)"></a>6.1. browserAction(浏览器右上角)</h2><p>通过配置browser_action可以在浏览器的右上角增加一个图标，一个browser_action可以拥有一个图标，一个tooltip，一个badge和一个popup。</p>
<p>示例配置如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"browser_action"</span>:</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"default_icon"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">	<span class="string">"default_title"</span>: <span class="string">"这是一个示例Chrome插件"</span>,</span><br><span class="line">	<span class="string">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-1-1-图标"><a href="#6-1-1-图标" class="headerlink" title="6.1.1. 图标"></a>6.1.1. 图标</h3><p>browser_action图标推荐使用宽高都为19像素的图片，更大的图标会被缩小，格式随意，一般推荐png，可以通过manifest中default_icon字段配置，也可以调用setIcon()方法。</p>
<h3 id="6-1-2-tooltip"><a href="#6-1-2-tooltip" class="headerlink" title="6.1.2. tooltip"></a>6.1.2. tooltip</h3><p>修改browser_action的manifest中default_title字段，或者调用setTitle()方法。</p>
<h3 id="6-1-3-badge"><a href="#6-1-3-badge" class="headerlink" title="6.1.3. badge"></a>6.1.3. badge</h3><p>所谓badge就是在图标上显示一些文本，可以用来更新一些小的扩展状态提示信息。因为badge空间有限，所以只支持4个以下的字符（英文4个，中文2个）。badge无法通过配置文件来指定，必须通过代码实现，设置badge文字和颜色可以分别使用setBadgeText()和setBadgeBackgroundColor()。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chrome.browserAction.setBadgeText(&#123;<span class="attr">text</span>: <span class="string">'new'</span>&#125;);</span><br><span class="line">chrome.browserAction.setBadgeBackgroundColor(&#123;<span class="attr">color</span>: [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="http://image.liuxianan.com/201705/20170531_171447_912_1165.png" alt="此处输入图片的描述"></p>
<h2 id="6-2-pageAction-地址栏右侧"><a href="#6-2-pageAction-地址栏右侧" class="headerlink" title="6.2 pageAction(地址栏右侧)"></a>6.2 pageAction(地址栏右侧)</h2><p>pageAction和普通的browserAction一样也是放在浏览器右上角，只不过没有点亮时是灰色的，点亮了才是彩色的，灰色时无论左键还是右键单击都是弹出选项：</p>
<p><img src="https://camo.githubusercontent.com/56178ef13350d7b5ae9e6e46f4d908c3472b1182/687474703a2f2f696d6167652e6c69757869616e616e2e636f6d2f3230313730352f32303137303533315f3130343033385f3230385f393335322e676966" alt="此处输入图片的描述"></p>
<p>调整之后的pageAction我们可以简单地把它看成是可以置灰的browserAction。</p>
<ul>
<li>chrome.pageAction.show(tabId) 显示图标；</li>
<li>chrome.pageAction.hide(tabId) 隐藏图标；</li>
</ul>
<p>示例 : (只有打开百度才显示图标)：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"page_action"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"default_icon"</span>: <span class="string">"img/icon.png"</span>,</span><br><span class="line">		<span class="string">"default_title"</span>: <span class="string">"我是pageAction"</span>,</span><br><span class="line">		<span class="string">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"permissions"</span>: [<span class="string">"declarativeContent"</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// background.js</span></span><br><span class="line">chrome.runtime.onInstalled.addListener(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	chrome.declarativeContent.onPageChanged.removeRules(<span class="literal">undefined</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		chrome.declarativeContent.onPageChanged.addRules([</span><br><span class="line">			&#123;</span><br><span class="line">				conditions: [</span><br><span class="line">					<span class="comment">// 只有打开百度才显示pageAction</span></span><br><span class="line">					<span class="keyword">new</span> chrome.declarativeContent.PageStateMatcher(&#123;<span class="attr">pageUrl</span>: &#123;<span class="attr">urlContains</span>: <span class="string">'baidu.com'</span>&#125;&#125;)</span><br><span class="line">				],</span><br><span class="line">				actions: [<span class="keyword">new</span> chrome.declarativeContent.ShowPageAction()]</span><br><span class="line">			&#125;</span><br><span class="line">		]);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>效果图：</p>
<p><img src="https://camo.githubusercontent.com/ab5bc8d6a1af7a271b30d38da70620bfc8042618/687474703a2f2f696d6167652e6c69757869616e616e2e636f6d2f3230313730352f32303137303533315f3137343031385f3534315f303435312e676966" alt="此处输入图片的描述"></p>
<h2 id="6-3-右键菜单"><a href="#6-3-右键菜单" class="headerlink" title="6.3 右键菜单"></a>6.3 右键菜单</h2><p>通过开发Chrome插件可以自定义浏览器的右键菜单，主要是通过chrome.contextMenusAPI实现，右键菜单可以出现在不同的上下文，比如普通页面、选中的文字、图片、链接，等等</p>
<h3 id="6-3-1-最简单的右键菜单示例"><a href="#6-3-1-最简单的右键菜单示例" class="headerlink" title="6.3.1 最简单的右键菜单示例"></a>6.3.1 最简单的右键菜单示例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;<span class="string">"permissions"</span>: [<span class="string">"contextMenus"</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// background.js</span></span><br><span class="line">chrome.contextMenus.create(&#123;</span><br><span class="line">	title: <span class="string">"测试右键菜单"</span>,</span><br><span class="line">	onclick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="string">'您点击了右键菜单！'</span>);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>效果：<br><img src="https://camo.githubusercontent.com/67a5d42b91c9a67b6caeae075c854764805c967f/687474703a2f2f696d6167652e6c69757869616e616e2e636f6d2f3230313730352f32303137303533315f3134353935375f3138335f303532372e706e67" alt="此处输入图片的描述"></p>
<p>添加右键百度搜索</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// manifest.json</span></span><br><span class="line">&#123;<span class="string">"permissions"</span>: [<span class="string">"contextMenus"</span>， <span class="string">"tabs"</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// background.js</span></span><br><span class="line">chrome.contextMenus.create(&#123;</span><br><span class="line">	title: <span class="string">'使用度娘搜索：%s'</span>, <span class="comment">// %s表示选中的文字</span></span><br><span class="line">	contexts: [<span class="string">'selection'</span>], <span class="comment">// 只有当选中文字时才会出现此右键菜单</span></span><br><span class="line">	onclick: <span class="function"><span class="keyword">function</span>(<span class="params">params</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 注意不能使用location.href，因为location是属于background的window对象</span></span><br><span class="line">		chrome.tabs.create(&#123;<span class="attr">url</span>: <span class="string">'https://www.baidu.com/s?ie=utf-8&amp;wd='</span> + <span class="built_in">encodeURI</span>(params.selectionText)&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>效果如下：<br><img src="https://camo.githubusercontent.com/8e2153a9c14a4ddf7b745708fd364ecfedb18d99/687474703a2f2f696d6167652e6c69757869616e616e2e636f6d2f3230313730352f32303137303533315f3136303335385f3230325f373234382e706e67" alt="此处输入图片的描述"></p>
<h3 id="6-3-2-右键菜单语法说明"><a href="#6-3-2-右键菜单语法说明" class="headerlink" title="6.3.2 右键菜单语法说明"></a>6.3.2 右键菜单语法说明</h3><p>这里只是简单列举一些常用的，完整API参见：<a href="https://developer.chrome.com/extensions/contextMenus" target="_blank" rel="noopener">https://developer.chrome.com/extensions/contextMenus</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chrome.contextMenus.create(&#123;</span><br><span class="line">	type: <span class="string">'normal'</span>， <span class="comment">// 类型，可选：["normal", "checkbox", "radio", "separator"]，默认 normal</span></span><br><span class="line">	title: <span class="string">'菜单的名字'</span>, <span class="comment">// 显示的文字，除非为“separator”类型否则此参数必需，如果类型为“selection”，可以使用%s显示选定的文本</span></span><br><span class="line">	contexts: [<span class="string">'page'</span>], <span class="comment">// 上下文环境，可选：["all", "page", "frame", "selection", "link", "editable", "image", "video", "audio"]，默认page</span></span><br><span class="line">	onclick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;, <span class="comment">// 单击时触发的方法</span></span><br><span class="line">	parentId: <span class="number">1</span>, <span class="comment">// 右键菜单项的父菜单项ID。指定父菜单项将会使此菜单项成为父菜单项的子菜单</span></span><br><span class="line">	documentUrlPatterns: <span class="string">'https://*.baidu.com/*'</span> <span class="comment">// 只在某些页面显示此右键菜单</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 删除某一个菜单项</span></span><br><span class="line">chrome.contextMenus.remove(menuItemId)；</span><br><span class="line"><span class="comment">// 删除所有自定义右键菜单</span></span><br><span class="line">chrome.contextMenus.removeAll();</span><br><span class="line"><span class="comment">// 更新某一个菜单项</span></span><br><span class="line">chrome.contextMenus.update(menuItemId, updateProperties);</span><br></pre></td></tr></table></figure>
<p>###6.4. override(覆盖特定页面)<br>使用<code>override</code>页可以将Chrome默认的一些特定页面替换掉，改为使用扩展提供的页面。</p>
<p>扩展可以替代如下页面：</p>
<ul>
<li>历史记录：从工具菜单上点击历史记录时访问的页面，或者从地址栏直接输入 chrome://history</li>
<li>新标签页：当创建新标签的时候访问的页面，或者从地址栏直接输入 chrome://newtab</li>
<li>书签：浏览器的书签，或者直接输入 chrome://bookmarks</li>
</ul>
<p>注意：</p>
<ul>
<li>一个扩展只能替代一个页面；</li>
<li>不能替代隐身窗口的新标签页；</li>
<li>网页必须设置title，否则用户可能会看到网页的URL，造成困扰；</li>
</ul>
<p>下面的截图是默认的新标签页和被扩展替换掉的新标签页。<br><img src="https://camo.githubusercontent.com/82756ac32496b5fe4519594ea29fbc0b7fdb4eed/687474703a2f2f696d6167652e6c69757869616e616e2e636f6d2f3230313730352f32303137303533315f3138303332365f3438375f333339362e706e67" alt="此处输入图片的描述"></p>
<p>代码（注意，一个插件只能替代一个默认页，以下仅为演示）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"chrome_url_overrides"</span>:</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">"newtab"</span>: <span class="string">"newtab.html"</span>,</span><br><span class="line">	<span class="string">"history"</span>: <span class="string">"history.html"</span>,</span><br><span class="line">	<span class="string">"bookmarks"</span>: <span class="string">"bookmarks.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-5-option-选项页"><a href="#6-5-option-选项页" class="headerlink" title="6.5 option(选项页)"></a>6.5 option(选项页)</h3><p>所谓<code>options</code>页，就是插件的设置页面，有2个入口，一个是右键图标有一个“选项”菜单，还有一个在插件管理页面：<br><img src="https://camo.githubusercontent.com/9d6cb6e53162c53752211e57e73e0e1579dd162f/687474703a2f2f696d6167652e6c69757869616e616e2e636f6d2f3230313730362f32303137303632315f3137303034365f3834365f353532392e706e67" alt="此处输入图片的描述"></p>
<p><img src="https://camo.githubusercontent.com/fd33f6c8c1cb6486d56b0cb81c68d5661bc50475/687474703a2f2f696d6167652e6c69757869616e616e2e636f6d2f3230313730362f32303137303632315f3131353930325f3139365f393133302e706e67" alt="此处输入图片的描述"></p>
<p>在Chrome40以前，options页面和其它普通页面没什么区别，Chrome40以后则有了一些变化。</p>
<p>我们先看老版的 <a href="https://developer.chrome.com/extensions/options" target="_blank" rel="noopener">options</a>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// Chrome40以前的插件配置页写法</span></span><br><span class="line">	<span class="string">"ptions_page"</span>: <span class="string">"options.html"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个页面里面的内容就随你自己发挥了，配置之后在插件管理页就会看到一个选项按钮入口，点进去就是打开一个网页，没啥好讲的。</p>
<p>效果:</p>
<p><img src="http://image.liuxianan.com/201706/20170621_115705_433_5886.png" alt="此处输入图片的描述"></p>
<p>再来看新版的<a href="https://developer.chrome.com/extensions/optionsV2" target="_blank" rel="noopener">optionsV2：</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">	<span class="string">"options_ui"</span>:</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="string">"page"</span>: <span class="string">"options.html"</span>,</span><br><span class="line">		<span class="comment">// 添加一些默认的样式，推荐使用</span></span><br><span class="line">		<span class="string">"chrome_style"</span>: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>options.html</code> 的代码我们没有任何改动，只是配置文件改了，之后效果如下：</p>
<p><img src="http://image.liuxianan.com/201706/20170621_115809_750_1163.png" alt="此处输入图片的描述"></p>
<p>看起来是不是高大上了？</p>
<p>几点注意：</p>
<ul>
<li>为了兼容，建议2种都写，如果都写了，Chrome40以后会默认读取新版的方式；</li>
<li>新版options中不能使用alert；</li>
<li>数据存储建议用chrome.storage，因为会随用户自动同步；<h3 id="6-5-omnibox"><a href="#6-5-omnibox" class="headerlink" title="6.5 omnibox"></a>6.5 omnibox</h3><code>omnibox</code>是向用户提供搜索建议的一种方式。先来看个gif图以便了解一下这东西到底是个什么鬼：<br><img src="https://camo.githubusercontent.com/f3a8c96d3e0cc02ebccb3c2b815284e7087c1ed3/687474703a2f2f696d6167652e6c69757869616e616e2e636f6d2f3230313730362f32303137303632315f3135353435355f3938305f353335392e676966" alt="此处输入图片的描述"></li>
</ul>
<p>注册某个关键字以触发插件自己的搜索建议界面，然后可以任意发挥了。</p>
<p>首先，配置文件如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字</span></span><br><span class="line">	<span class="string">"omnibox"</span>: &#123; <span class="string">"keyword"</span> : <span class="string">"go"</span> &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后background.js中注册监听事件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// omnibox 演示</span></span><br><span class="line">chrome.omnibox.onInputChanged.addListener(<span class="function">(<span class="params">text, suggest</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'inputChanged: '</span> + text);</span><br><span class="line">	<span class="keyword">if</span>(!text) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span>(text == <span class="string">'美女'</span>) &#123;</span><br><span class="line">		suggest([</span><br><span class="line">			&#123;<span class="attr">content</span>: <span class="string">'中国'</span> + text, <span class="attr">description</span>: <span class="string">'你要找“中国美女”吗？'</span>&#125;,</span><br><span class="line">			&#123;<span class="attr">content</span>: <span class="string">'日本'</span> + text, <span class="attr">description</span>: <span class="string">'你要找“日本美女”吗？'</span>&#125;,</span><br><span class="line">			&#123;<span class="attr">content</span>: <span class="string">'泰国'</span> + text, <span class="attr">description</span>: <span class="string">'你要找“泰国美女或人妖”吗？'</span>&#125;,</span><br><span class="line">			&#123;<span class="attr">content</span>: <span class="string">'韩国'</span> + text, <span class="attr">description</span>: <span class="string">'你要找“韩国美女”吗？'</span>&#125;</span><br><span class="line">		]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(text == <span class="string">'微博'</span>) &#123;</span><br><span class="line">		suggest([</span><br><span class="line">			&#123;<span class="attr">content</span>: <span class="string">'新浪'</span> + text, <span class="attr">description</span>: <span class="string">'新浪'</span> + text&#125;,</span><br><span class="line">			&#123;<span class="attr">content</span>: <span class="string">'腾讯'</span> + text, <span class="attr">description</span>: <span class="string">'腾讯'</span> + text&#125;,</span><br><span class="line">			&#123;<span class="attr">content</span>: <span class="string">'搜狐'</span> + text, <span class="attr">description</span>: <span class="string">'搜索'</span> + text&#125;,</span><br><span class="line">		]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		suggest([</span><br><span class="line">			&#123;<span class="attr">content</span>: <span class="string">'百度搜索 '</span> + text, <span class="attr">description</span>: <span class="string">'百度搜索 '</span> + text&#125;,</span><br><span class="line">			&#123;<span class="attr">content</span>: <span class="string">'谷歌搜索 '</span> + text, <span class="attr">description</span>: <span class="string">'谷歌搜索 '</span> + text&#125;,</span><br><span class="line">		]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当用户接收关键字建议时触发</span></span><br><span class="line">chrome.omnibox.onInputEntered.addListener(<span class="function">(<span class="params">text</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'inputEntered: '</span> + text);</span><br><span class="line">	<span class="keyword">if</span>(!text) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">var</span> href = <span class="string">''</span>;</span><br><span class="line">	<span class="keyword">if</span>(text.endsWith(<span class="string">'美女'</span>)) href = <span class="string">'http://image.baidu.com/search/index?tn=baiduimage&amp;ie=utf-8&amp;word='</span> + text;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(text.startsWith(<span class="string">'百度搜索'</span>)) href = <span class="string">'https://www.baidu.com/s?ie=UTF-8&amp;wd='</span> + text.replace(<span class="string">'百度搜索 '</span>, <span class="string">''</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(text.startsWith(<span class="string">'谷歌搜索'</span>)) href = <span class="string">'https://www.google.com.tw/search?q='</span> + text.replace(<span class="string">'谷歌搜索 '</span>, <span class="string">''</span>);</span><br><span class="line">	<span class="keyword">else</span> href = <span class="string">'https://www.baidu.com/s?ie=UTF-8&amp;wd='</span> + text;</span><br><span class="line">	openUrlCurrentTab(href);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentTabId</span>(<span class="params">callback</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrome.tabs.query(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(callback) callback(tabs.length ? tabs[<span class="number">0</span>].id: <span class="literal">null</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前标签打开某个链接</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">openUrlCurrentTab</span>(<span class="params">url</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	getCurrentTabId(<span class="function"><span class="params">tabId</span> =&gt;</span> &#123;</span><br><span class="line">		chrome.tabs.update(tabId, &#123;<span class="attr">url</span>: url&#125;);</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-6-桌面通知"><a href="#6-6-桌面通知" class="headerlink" title="6.6 桌面通知"></a>6.6 桌面通知</h3><p>Chrome提供了一个chrome.notificationsAPI以便插件推送桌面通知，暂未找到chrome.notifications和HTML5自带的Notification的显著区别及优势。</p>
<p>在后台JS中，无论是使用chrome.notifications还是Notification都不需要申请权限（HTML5方式需要申请权限），直接使用即可。</p>
<p>最简单的通知：</p>
<p><img src="https://camo.githubusercontent.com/5198a4fe43e6c8fa790a604d9fc80fcf8ccfe299/687474703a2f2f696d6167652e6c69757869616e616e2e636f6d2f3230313730352f32303137303533315f3139333633335f3336395f303237342e706e67" alt="此处输入图片的描述"></p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chrome.notifications.create(<span class="literal">null</span>, &#123;</span><br><span class="line">	type: <span class="string">'basic'</span>,</span><br><span class="line">	iconUrl: <span class="string">'img/icon.png'</span>,</span><br><span class="line">	title: <span class="string">'这是标题'</span>,</span><br><span class="line">	message: <span class="string">'您刚才点击了自定义右键菜单！'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="7-五种类型的JS对比"><a href="#7-五种类型的JS对比" class="headerlink" title="7. 五种类型的JS对比"></a>7. 五种类型的JS对比</h1><p>Chrome插件的JS主要可以分为这5类：<code>injected script</code>、<code>content-script</code>、<code>popup js</code>、<code>background js</code>和<code>devtools js</code>，</p>
<h3 id="7-1-权限对比"><a href="#7-1-权限对比" class="headerlink" title="7.1. 权限对比"></a>7.1. 权限对比</h3><table>
<thead>
<tr>
<th align="center">JS种类</th>
<th align="center">可访问的API</th>
<th align="center">DOM访问情况</th>
<th align="center">JS访问情况</th>
<th align="center">直接跨域</th>
</tr>
</thead>
<tbody><tr>
<td align="center">injected script</td>
<td align="center">和普通JS无任何差别，不能访问任何扩展API</td>
<td align="center">可以</td>
<td align="center">可以</td>
<td align="center">不可以</td>
</tr>
<tr>
<td align="center">content script</td>
<td align="center">只能访问 extension、runtime等部分API</td>
<td align="center">可以</td>
<td align="center">不可以</td>
<td align="center">不可以</td>
</tr>
<tr>
<td align="center">popup js</td>
<td align="center">可访问绝大部分API，除了devtools系列</td>
<td align="center">不可直接访问</td>
<td align="center">不可以</td>
<td align="center">不可以</td>
</tr>
<tr>
<td align="center">background js</td>
<td align="center">可访问绝大部分API，除了devtools系列</td>
<td align="center">不可直接访问</td>
<td align="center">不可以</td>
<td align="center">不可以</td>
</tr>
<tr>
<td align="center">devtools js</td>
<td align="center">只能访问 devtools、extension、runtime等部分API</td>
<td align="center">可以</td>
<td align="center">可以</td>
<td align="center">不可以</td>
</tr>
</tbody></table>
<h1 id="8-消息通信"><a href="#8-消息通信" class="headerlink" title="8. 消息通信"></a>8. 消息通信</h1><p>通信主页：<a href="https://developer.chrome.com/extensions/messaging" target="_blank" rel="noopener">https://developer.chrome.com/extensions/messaging</a><br>前面我们介绍了Chrome插件中存在的5种JS，那么它们之间如何互相通信呢？下面先来系统概况一下，然后再分类细说。需要知道的是，popup和background其实几乎可以视为一种东西，因为它们可访问的API都一样、通信机制一样、都可以跨域。</p>
<h2 id="8-1-互相通信概览"><a href="#8-1-互相通信概览" class="headerlink" title="8.1 互相通信概览"></a>8.1 互相通信概览</h2><p>注：<code>-</code>表示不存在或者无意义，或者待验证。<br>|  -  | injected-script   |  content-script  |  popup-js  | background-js  |<br>| :—–:  |:—:  |:—:  |:—:  |:—:  |<br>| injected-script | - |window.postMessage | - |-|<br>| content-script | window.postMessage |- | chrome.runtime.sendMessage chrome.runtime.connect |chrome.runtime.sendMessage chrome.runtime.connect|<br>| popup-js | - |chrome.tabs.sendMessage chrome.tabs.connect | - |chrome.extension. getBackgroundPage()|<br>|background-js|-|chrome.tabs.sendMessage chrome.tabs.connect|chrome.extension.getViews|-|<br>|devtools-js|chrome.devtools. inspectedWindow.eval|-|chrome.runtime.sendMessage    |chrome.runtime.sendMessage    |</p>
<h2 id="8-2-通信详细介绍"><a href="#8-2-通信详细介绍" class="headerlink" title="8.2 通信详细介绍"></a>8.2 通信详细介绍</h2><h3 id="8-2-1-popup和background"><a href="#8-2-1-popup和background" class="headerlink" title="8.2.1 popup和background"></a>8.2.1 popup和background</h3><p>popup可以直接调用background中的JS方法，也可以直接访问background的DOM：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// background.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	alert(<span class="string">'我是background！'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// popup.js</span></span><br><span class="line"><span class="keyword">var</span> bg = chrome.extension.getBackgroundPage();</span><br><span class="line">bg.test(); <span class="comment">// 访问bg的函数</span></span><br><span class="line">alert(bg.document.body.innerHTML); <span class="comment">// 访问bg的DOM</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>小插曲，今天碰到一个情况，发现popup无法获取background的任何方法，找了半天才发现是因为background的js报错了，而你如果不主动查看background的js的话，是看不到错误信息的，特此提醒。</p>
</blockquote>
<p>至于background访问popup如下（前提是popup已经打开）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> views = chrome.extension.getViews(&#123;<span class="attr">type</span>:<span class="string">'popup'</span>&#125;);</span><br><span class="line"><span class="keyword">if</span>(views.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(views[<span class="number">0</span>].location.href);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-2-2-popup或者bg向content主动发送消息"><a href="#8-2-2-popup或者bg向content主动发送消息" class="headerlink" title="8.2.2 popup或者bg向content主动发送消息"></a>8.2.2 popup或者bg向content主动发送消息</h3><p>background.js或者popup.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessageToContentScript</span>(<span class="params">message, callback</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrome.tabs.query(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		chrome.tabs.sendMessage(tabs[<span class="number">0</span>].id, message, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(callback) callback(response);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line">sendMessageToContentScript(&#123;<span class="attr">cmd</span>:<span class="string">'test'</span>, <span class="attr">value</span>:<span class="string">'你好，我是popup！'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'来自content的回复：'</span>+response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>content-script.js</code> 接收：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// console.log(sender.tab ?"from a content script:" + sender.tab.url :"from the extension");</span></span><br><span class="line">	<span class="keyword">if</span>(request.cmd == <span class="string">'test'</span>) alert(request.value);</span><br><span class="line">	sendResponse(<span class="string">'我收到了你的消息！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>双方通信直接发送的都是JSON对象，不是JSON字符串，所以无需解析，很方便（当然也可以直接发送字符串）。</p>
<blockquote>
<p>网上有些老代码中用的是chrome.extension.onMessage，没有完全查清二者的区别(貌似是别名)，但是建议统一使用chrome.runtime.onMessage。</p>
</blockquote>
<h3 id="8-2-3-content-script主动发消息给后台"><a href="#8-2-3-content-script主动发消息给后台" class="headerlink" title="8.2.3 content-script主动发消息给后台"></a>8.2.3 content-script主动发消息给后台</h3><p>content-script.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chrome.runtime.sendMessage(&#123;<span class="attr">greeting</span>: <span class="string">'你好，我是content-script呀，我主动发消息给后台！'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'收到来自后台的回复：'</span> + response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>background.js 或者 popup.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听来自content-script的消息</span></span><br><span class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'收到来自content-script的消息：'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(request, sender, sendResponse);</span><br><span class="line">	sendResponse(<span class="string">'我是后台，我已收到你的消息：'</span> + <span class="built_in">JSON</span>.stringify(request));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<ul>
<li>content_scripts向popup主动发消息的前提是popup必须打开！否则需要利用background作中转；</li>
<li>如果background和popup同时监听，那么它们都可以同时收到消息，但是只有一个可以sendResponse，一个先发送了，那么另外一个再发送就无效；</li>
</ul>
<h3 id="8-2-4-injected-script和content-script"><a href="#8-2-4-injected-script和content-script" class="headerlink" title="8.2.4 injected script和content-script"></a>8.2.4 injected script和content-script</h3><p>content-script和页面内的脚本（injected-script自然也属于页面内的脚本）之间唯一共享的东西就是页面的DOM元素，有2种方法可以实现二者通讯：</p>
<ul>
<li>可以通过window.postMessage和window.addEventListener来实现二者消息通讯；</li>
<li>通过自定义DOM事件来实现；</li>
</ul>
<p>第一种方法（推荐）：<br><code>injected-script</code>中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage(&#123;<span class="string">"test"</span>: <span class="string">'你好！'</span>&#125;, <span class="string">'*'</span>);</span><br></pre></td></tr></table></figure>
<p><code>content script</code>中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(e.data);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<p>第二种方法：<br><code>injected-script</code>中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> customEvent = <span class="built_in">document</span>.createEvent(<span class="string">'Event'</span>);</span><br><span class="line">customEvent.initEvent(<span class="string">'myCustomEvent'</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fireCustomEvent</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">	hiddenDiv = <span class="built_in">document</span>.getElementById(<span class="string">'myCustomEventDiv'</span>);</span><br><span class="line">	hiddenDiv.innerText = data</span><br><span class="line">	hiddenDiv.dispatchEvent(customEvent);</span><br><span class="line">&#125;</span><br><span class="line">fireCustomEvent(<span class="string">'你好，我是普通JS！'</span>);</span><br></pre></td></tr></table></figure>
<p><code>content-script.js</code>中：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> hiddenDiv = <span class="built_in">document</span>.getElementById(<span class="string">'myCustomEventDiv'</span>);</span><br><span class="line"><span class="keyword">if</span>(!hiddenDiv) &#123;</span><br><span class="line">	hiddenDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">	hiddenDiv.style.display = <span class="string">'none'</span>;</span><br><span class="line">	<span class="built_in">document</span>.body.appendChild(hiddenDiv);</span><br><span class="line">&#125;</span><br><span class="line">hiddenDiv.addEventListener(<span class="string">'myCustomEvent'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> eventData = <span class="built_in">document</span>.getElementById(<span class="string">'myCustomEventDiv'</span>).innerText;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'收到自定义事件消息：'</span> + eventData);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="8-3-长连接和短连接"><a href="#8-3-长连接和短连接" class="headerlink" title="8.3 长连接和短连接"></a>8.3 长连接和短连接</h3><p>其实上面已经涉及到了，这里再单独说明一下。Chrome插件中有2种通信方式，一个是短连接（chrome.tabs.sendMessage和chrome.runtime.sendMessage），一个是长连接（chrome.tabs.connect和chrome.runtime.connect）。</p>
<p>短连接的话就是挤牙膏一样，我发送一下，你收到了再回复一下，如果对方不回复，你只能重新发，而长连接类似WebSocket会一直建立连接，双方可以随时互发消息。</p>
<p>短连接上面已经有代码示例了，这里只讲一下长连接。</p>
<p>popup.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getCurrentTabId(<span class="function">(<span class="params">tabId</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> port = chrome.tabs.connect(tabId, &#123;<span class="attr">name</span>: <span class="string">'test-connect'</span>&#125;);</span><br><span class="line">	port.postMessage(&#123;<span class="attr">question</span>: <span class="string">'你是谁啊？'</span>&#125;);</span><br><span class="line">	port.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">		alert(<span class="string">'收到消息：'</span>+msg.answer);</span><br><span class="line">		<span class="keyword">if</span>(msg.answer &amp;&amp; msg.answer.startsWith(<span class="string">'我是'</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			port.postMessage(&#123;<span class="attr">question</span>: <span class="string">'哦，原来是你啊！'</span>&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>content-script.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听长连接</span></span><br><span class="line">chrome.runtime.onConnect.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">port</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(port);</span><br><span class="line">	<span class="keyword">if</span>(port.name == <span class="string">'test-connect'</span>) &#123;</span><br><span class="line">		port.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'收到长连接消息：'</span>, msg);</span><br><span class="line">			<span class="keyword">if</span>(msg.question == <span class="string">'你是谁啊？'</span>) port.postMessage(&#123;<span class="attr">answer</span>: <span class="string">'我是你爸！'</span>&#125;);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h1 id="9-其它补充"><a href="#9-其它补充" class="headerlink" title="9. 其它补充"></a>9. 其它补充</h1><h2 id="9-1-动态注入或执行JS"><a href="#9-1-动态注入或执行JS" class="headerlink" title="9.1 动态注入或执行JS"></a>9.1 动态注入或执行JS</h2><p>虽然在background和popup中无法直接访问页面DOM，但是可以通过chrome.tabs.executeScript来执行脚本，从而实现访问web页面的DOM（注意，这种方式也不能直接访问页面JS）。</p>
<p>示例manifest.json配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"name"</span>: <span class="string">"动态JS注入演示"</span>,</span><br><span class="line">	...</span><br><span class="line">	<span class="string">"permissions"</span>: [</span><br><span class="line">		<span class="string">"tabs"</span>, <span class="string">"http://*/*"</span>, <span class="string">"https://*/*"</span></span><br><span class="line">	],</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JS：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态执行JS代码</span></span><br><span class="line">chrome.tabs.executeScript(tabId, &#123;<span class="attr">code</span>: <span class="string">'document.body.style.backgroundColor="red"'</span>&#125;);</span><br><span class="line"><span class="comment">// 动态执行JS文件</span></span><br><span class="line">chrome.tabs.executeScript(tabId, &#123;<span class="attr">file</span>: <span class="string">'some-script.js'</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="9-2-动态注入CSS"><a href="#9-2-动态注入CSS" class="headerlink" title="9.2 动态注入CSS"></a>9.2 动态注入CSS</h2><p>示例manifest.json配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"name"</span>: <span class="string">"动态CSS注入演示"</span>,</span><br><span class="line">	...</span><br><span class="line">	<span class="string">"permissions"</span>: [</span><br><span class="line">		<span class="string">"tabs"</span>, <span class="string">"http://*/*"</span>, <span class="string">"https://*/*"</span></span><br><span class="line">	],</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JS代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 动态执行CSS代码，TODO，这里有待验证</span></span><br><span class="line">chrome.tabs.insertCSS(tabId, &#123;<span class="attr">code</span>: <span class="string">'xxx'</span>&#125;);</span><br><span class="line"><span class="comment">// 动态执行CSS文件</span></span><br><span class="line">chrome.tabs.insertCSS(tabId, &#123;<span class="attr">file</span>: <span class="string">'some-style.css'</span>&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="9-3-获取当前窗口ID"><a href="#9-3-获取当前窗口ID" class="headerlink" title="9.3 获取当前窗口ID"></a>9.3 获取当前窗口ID</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chrome.windows.getCurrent(<span class="function"><span class="keyword">function</span>(<span class="params">currentWindow</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'当前窗口ID：'</span> + currentWindow.id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="9-4-获取当前标签页ID"><a href="#9-4-获取当前标签页ID" class="headerlink" title="9.4 获取当前标签页ID"></a>9.4 获取当前标签页ID</h2><p>一般有2种方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentTabId</span>(<span class="params">callback</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrome.tabs.query(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(callback) callback(tabs.length ? tabs[<span class="number">0</span>].id: <span class="literal">null</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取当前选项卡id的另一种方法，大部分时候都类似，只有少部分时候会不一样（例如当窗口最小化时）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentTabId2</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrome.windows.getCurrent(<span class="function"><span class="keyword">function</span>(<span class="params">currentWindow</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		chrome.tabs.query(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">windowId</span>: currentWindow.id&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(callback) callback(tabs.length ? tabs[<span class="number">0</span>].id: <span class="literal">null</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-5-本地存储"><a href="#9-5-本地存储" class="headerlink" title="9.5 本地存储"></a>9.5 本地存储</h2><p>本地存储建议用chrome.storage而不是普通的localStorage，区别有好几点，个人认为最重要的2点区别是</p>
<ul>
<li>chrome.storage是针对插件全局的，即使你在background中保存的数据，在content-script也能获取到；</li>
<li>chrome.storage.sync可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络；</li>
</ul>
<p>需要声明storage权限，有chrome.storage.sync和chrome.storage.local2种方式可供选择，使用示例如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取数据，第一个参数是指定要读取的key以及设置默认值</span></span><br><span class="line">chrome.storage.sync.get(&#123;<span class="attr">color</span>: <span class="string">'red'</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(items.color, items.age);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">chrome.storage.sync.set(&#123;<span class="attr">color</span>: <span class="string">'blue'</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'保存成功！'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="9-6-webRequest"><a href="#9-6-webRequest" class="headerlink" title="9.6 webRequest"></a>9.6 webRequest</h2><p>通过webRequest系列API可以对HTTP请求进行任性地修改、定制，这里通过beforeRequest来简单演示一下它的冰山一角：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//manifest.json</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 权限申请</span></span><br><span class="line">	<span class="string">"permissions"</span>:</span><br><span class="line">	[</span><br><span class="line">		<span class="string">"webRequest"</span>, <span class="comment">// web请求</span></span><br><span class="line">		<span class="string">"webRequestBlocking"</span>, <span class="comment">// 阻塞式web请求</span></span><br><span class="line">		<span class="string">"storage"</span>, <span class="comment">// 插件本地存储</span></span><br><span class="line">		<span class="string">"http://*/*"</span>, <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">		<span class="string">"https://*/*"</span> <span class="comment">// 可以通过executeScript或者insertCSS访问的网站</span></span><br><span class="line">	],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// background.js</span></span><br><span class="line"><span class="comment">// 是否显示图片</span></span><br><span class="line"><span class="keyword">var</span> showImage;</span><br><span class="line">chrome.storage.sync.get(&#123;<span class="attr">showImage</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">	showImage = items.showImage;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// web请求监听，最后一个参数表示阻塞式，需单独声明权限：webRequestBlocking</span></span><br><span class="line">chrome.webRequest.onBeforeRequest.addListener(<span class="function"><span class="params">details</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">// cancel 表示取消本次请求</span></span><br><span class="line">	<span class="keyword">if</span>(!showImage &amp;&amp; details.type == <span class="string">'image'</span>) <span class="keyword">return</span> &#123;<span class="attr">cancel</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">	<span class="comment">// 简单的音视频检测</span></span><br><span class="line">	<span class="comment">// 大部分网站视频的type并不是media，且视频做了防下载处理，所以这里仅仅是为了演示效果，无实际意义</span></span><br><span class="line">	<span class="keyword">if</span>(details.type == <span class="string">'media'</span>) &#123;</span><br><span class="line">		chrome.notifications.create(<span class="literal">null</span>, &#123;</span><br><span class="line">			type: <span class="string">'basic'</span>,</span><br><span class="line">			iconUrl: <span class="string">'img/icon.png'</span>,</span><br><span class="line">			title: <span class="string">'检测到音视频'</span>,</span><br><span class="line">			message: <span class="string">'音视频地址：'</span> + details.url,</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, &#123;<span class="attr">urls</span>: [<span class="string">"&lt;all_urls&gt;"</span>]&#125;, [<span class="string">"blocking"</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="9-7-API总结"><a href="#9-7-API总结" class="headerlink" title="9.7 API总结"></a>9.7 API总结</h2><p>比较常用用的一些API系列：</p>
<ul>
<li>chrome.tabs</li>
<li>chrome.runtime</li>
<li>chrome.webRequest</li>
<li>chrome.window</li>
<li>chrome.storage</li>
<li>chrome.contextMenus</li>
<li>chrome.devtools</li>
<li>chrome.extension<h1 id="10-经验总结"><a href="#10-经验总结" class="headerlink" title="10. 经验总结"></a>10. 经验总结</h1><h2 id="10-1-查看已安装插件路径"><a href="#10-1-查看已安装插件路径" class="headerlink" title="10.1 查看已安装插件路径"></a>10.1 查看已安装插件路径</h2>已安装的插件源码路径：C:\Users\用户名\AppData\Local\Google\Chrome\User Data\Default\Extensions，每一个插件被放在以插件ID为名的文件夹里面，想要学习某个插件的某个功能是如何实现的，看人家的源码是最好的方法了：<br><img src="https://camo.githubusercontent.com/6d7b27fda3d87e0591cf6215065e3fd310caef43/687474703a2f2f696d6167652e6c69757869616e616e2e636f6d2f3230313730362f32303137303630315f3130303230305f3634375f363530372e706e67" alt="此处输入图片的描述"></li>
</ul>
<p>如何查看某个插件的ID？进入 chrome://extensions ，然后勾线开发者模式即可看到了。<br><img src="https://camo.githubusercontent.com/2a9ba1adb836ce745c9daecfcbc0d8adad898291/687474703a2f2f696d6167652e6c69757869616e616e2e636f6d2f3230313730362f32303137303630315f3130303430385f3333385f333039352e706e67" alt="此处输入图片的描述"></p>
<h2 id="10-2-特别注意background的报错"><a href="#10-2-特别注意background的报错" class="headerlink" title="10.2 特别注意background的报错"></a>10.2 特别注意background的报错</h2><p>很多时候你发现你的代码会莫名其妙的失效，找来找去又找不到原因，这时打开background的控制台才发现原来某个地方写错了导致代码没生效，正式由于background报错的隐蔽性(需要主动打开对应的控制台才能看到错误)，所以特别注意这点。</p>
<h1 id="11-打包与发布"><a href="#11-打包与发布" class="headerlink" title="11. 打包与发布"></a>11. 打包与发布</h1><p>打包的话直接在插件管理页有一个打包按钮：<br><img src="https://camo.githubusercontent.com/4a44ea082063e77fc60880d8ba050c5c6314135b/687474703a2f2f696d6167652e6c69757869616e616e2e636f6d2f3230313730362f32303137303632315f3138313133305f3336325f333336302e706e67" alt="此处输入图片的描述"></p>
<p>然后会生成一个.crx文件</p>
<h1 id="12-参考"><a href="#12-参考" class="headerlink" title="12. 参考"></a>12. 参考</h1><h2 id="官方资料"><a href="#官方资料" class="headerlink" title="官方资料"></a>官方资料</h2><p>推荐查看官方文档，虽然是英文，但是全且新，国内的中文资料都比较旧（注意以下全部需要翻墙）：</p>
<ul>
<li><a href="https://developer.chrome.com/extensions" target="_blank" rel="noopener">Chrome插件官方文档主页</a></li>
<li><a href="https://developer.chrome.com/extensions/samples" target="_blank" rel="noopener">Chrome插件官方示例</a></li>
<li><a href="https://developer.chrome.com/extensions/manifest" target="_blank" rel="noopener">manifest清单文件</a></li>
<li><a href="https://developer.chrome.com/extensions/permissions" target="_blank" rel="noopener">permissions权限</a></li>
<li>chrome.xxx.api文档</li>
<li>模糊匹配规则语法详解</li>
</ul>
<h1 id="Chrome扩展demo"><a href="#Chrome扩展demo" class="headerlink" title="Chrome扩展demo"></a>Chrome扩展demo</h1><p><a href="https://github.com/RocWangPeng/chrome-plugin-demo" target="_blank" rel="noopener">https://github.com/RocWangPeng/chrome-plugin-demo</a></p>
<p>原文参考自:<a href="http://blog.haoji.me/chrome-plugin-develop.html?from=xa" target="_blank" rel="noopener">好记的博客</a></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器插件开发</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>浏览器插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>FileReader使用指南</title>
    <url>/2016/06/30/FileReader%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h2><p>FileReader用来把文件读入内存，并且读取文件中的数据。其接口提供了一个异步API，使用该API可以在浏览器主线程中异步访问文件系统，读取文件中的数据。到目前文职，只有FF3.6+和Chrome6.0+实现了FileReader接口。</p>
<p><strong>接口方法:</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>readAsText</td>
<td>file</td>
<td>将文件读取为文本</td>
</tr>
<tr>
<td>readAsDataURL</td>
<td>file</td>
<td>将文件读取为DataURL</td>
</tr>
<tr>
<td>readAsBinaryString</td>
<td>file</td>
<td>将文件读取为二进制编码</td>
</tr>
<tr>
<td>readAsArrayBuffer</td>
<td>file</td>
<td>将文件读取为ArrayBuffer</td>
</tr>
<tr>
<td>abort</td>
<td>none</td>
<td>终止读取操作</td>
</tr>
</tbody></table>
<a id="more"></a>

<p><strong>接口事件</strong></p>
<table>
<thead>
<tr>
<th>事件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>onabort</td>
<td>中断</td>
</tr>
<tr>
<td>onerror</td>
<td>出错</td>
</tr>
<tr>
<td>onloadstart</td>
<td>开始</td>
</tr>
<tr>
<td>onprogress</td>
<td>正在读取</td>
</tr>
<tr>
<td>onload</td>
<td>成功读取</td>
</tr>
<tr>
<td>onloadend</td>
<td>读取完成，无论成功失败</td>
</tr>
</tbody></table>
<p><strong>完整示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;FileReader&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; multiple&#x3D;&quot;multiple&quot;&gt;</span><br><span class="line">    &lt;button type&#x3D;&quot;button&quot;&gt;获取&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 具体脚本</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>具体脚本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> $ = <span class="built_in">document</span>.querySelectorAll.bind(<span class="built_in">document</span>),</span><br><span class="line">    log = <span class="built_in">console</span>.log.bind(<span class="built_in">console</span>);</span><br><span class="line"></span><br><span class="line">$(<span class="string">'button'</span>)[<span class="number">0</span>].addEventListener(<span class="string">'click'</span>, handle);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> files = $(<span class="string">'input'</span>)[<span class="number">0</span>].files,</span><br><span class="line">        len = files.length,</span><br><span class="line">        file;</span><br><span class="line">    <span class="keyword">if</span>(len &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果有选中图片</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            file = files[i];</span><br><span class="line">            <span class="keyword">if</span>(<span class="regexp">/image\/[jpeg,gif,jpg,png]/</span>.test(file.type)) &#123; <span class="comment">// 如果是图片</span></span><br><span class="line">                log(file);</span><br><span class="line">                <span class="comment">// readAsText(file);</span></span><br><span class="line">                <span class="comment">// readAsDataURL(file);</span></span><br><span class="line">                <span class="comment">// readAsBinaryString(file);</span></span><br><span class="line">                readAsArrayBuffer(file);</span><br><span class="line">                <span class="comment">// createObjectURL(file);</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log(<span class="string">'请选择图片!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件以文本形式读入页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readAsText</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileReader = <span class="keyword">new</span> FileReader();  </span><br><span class="line">    fileReader.readAsText(file);</span><br><span class="line">    fileReader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">        p.textContent = e.currentTarget.result;</span><br><span class="line">        $(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件以Data URL形式读入页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readAsDataURL</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileReader = <span class="keyword">new</span> FileReader();  </span><br><span class="line">    fileReader.readAsDataURL(file);</span><br><span class="line">    log(fileReader)</span><br><span class="line">    fileReader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">        img.src = e.currentTarget.result;</span><br><span class="line">        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            $(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(img);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件以二进制形式读入页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readAsBinaryString</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileReader = <span class="keyword">new</span> FileReader();  </span><br><span class="line">    fileReader.readAsBinaryString(file);</span><br><span class="line">    fileReader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span><br><span class="line">        p.textContent = e.currentTarget.result;</span><br><span class="line">        $(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(p);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件以Array Buffer形式读入页面</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readAsArrayBuffer</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileReader = <span class="keyword">new</span> FileReader();  </span><br><span class="line">    fileReader.readAsArrayBuffer(file);</span><br><span class="line">    fileReader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        log(e.currentTarget.result);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象URL</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObjectURL</span>(<span class="params">file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">window</span>.URL.revokeObjectURL(img.src); <span class="comment">// revokeObjectURL() 静态方法用来释放一个之前通过调用 URL.createObjectURL() 创建的已经存在的 URL 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    img.src = <span class="built_in">window</span>.URL.createObjectURL(file);</span><br><span class="line">    $(<span class="string">'body'</span>)[<span class="number">0</span>].appendChild(img);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>html</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js你不知道的一些小技巧</title>
    <url>/2019/02/16/Vue-js%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="给-props-属性设置多个类型"><a href="#给-props-属性设置多个类型" class="headerlink" title="给 props 属性设置多个类型"></a>给 props 属性设置多个类型</h2><p>这个技巧在开发组件的时候用的较多，为了更大的容错性考虑，同时代码也更加人性化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    width: &#123;</span><br><span class="line">      type: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'100px'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 或者这样</span></span><br><span class="line">    <span class="comment">// width: [String, Number]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>比如一个 <my-button> 上暴露了一个 width 属性，我们既可以传 100px，也可以传 100 ：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- my-button.vue --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">:style</span>=<span class="string">"computedWidth"</span>&gt;</span>&#123;&#123; computedWidth &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">    props: &#123;</span><br><span class="line"><span class="javascript">      width: [<span class="built_in">String</span>, <span class="built_in">Number</span>]</span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line">      computedWidth () &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> o = &#123;&#125;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.width === <span class="string">'string'</span>) o.width = <span class="keyword">this</span>.width</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.width === <span class="string">'number'</span>) o.width = <span class="keyword">this</span>.width + <span class="string">'px'</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> o</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在其他组件中使用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-button</span> <span class="attr">width</span>=<span class="string">"100px"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-button</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- or --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-button</span> <span class="attr">:width</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="禁止浏览器-Auto-complete-行为"><a href="#禁止浏览器-Auto-complete-行为" class="headerlink" title="禁止浏览器 Auto complete 行为"></a>禁止浏览器 Auto complete 行为</h2><p>有时候我们输入账号密码登录后台系统，浏览器会弹出是否保存你的登录信息。我们一般会点击保存，因为下次再次登录的时候会自动填充增加了我们的用户体验，很好。</p>
<p>但有时，当我们开发某个某块（比如新增用户）时，点击新增用户按钮，显示弹框，不巧的是，在账号，密码输入框中浏览器帮我们填充上了。但这并不是我们想要的。所以，我的有效解决思路如下：</p>
<ul>
<li>设置 <code>&lt;el-input/&gt;</code> 为只读模式</li>
<li>在 focus 事件中去掉只读模式</li>
</ul>
<p>代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-model</span>=<span class="string">"addData.loginName"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">readonly</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">focus</span>=<span class="string">"handleFocusEvent"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">methods: &#123;</span><br><span class="line">  handleFocusEvent(event) &#123;</span><br><span class="line">    event.target &amp;&amp; event.target.removeAttribute(<span class="string">'readonly'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="阻止-lt-el-form-gt-默认提交行为"><a href="#阻止-lt-el-form-gt-默认提交行为" class="headerlink" title="阻止 &lt;el-form&gt; 默认提交行为"></a>阻止 <code>&lt;el-form&gt;</code> 默认提交行为</h2><p>有时候我们在用饿了么组件 <code>&lt;el-form&gt;</code> 在文本框中键入 enter 快捷键的时候会默认触发页面刷新。我们可以加入如下代码解决其默认行为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">el-form</span> @<span class="attr">submit.native.prevent</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="data-初始化"><a href="#data-初始化" class="headerlink" title="data 初始化"></a>data 初始化</h2><p>因为 props 要比 data 先完成初始化，所以我们可以利用这一点给 data 初始化一些数据进去，看代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      buttonSize: <span class="keyword">this</span>.size</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> props: &#123;</span><br><span class="line">   size: <span class="built_in">String</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了以上，子组件的 data 函数也可以有参数，且该参数是当前实例对象。所有我们可以利用这一点做一些自己的判断。如，改写上面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data (vm) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      buttonSize: vm.size</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"> props: &#123;</span><br><span class="line">   size: <span class="built_in">String</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="template"><a href="#template" class="headerlink" title="template"></a>template</h2><p>我们在做 v-if 判断的时候，可以把判断条件放在 template 组件上，最终的渲染结果将不包含 <code>&lt;template&gt;</code> 元素。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">"isVal"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>...<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>v-for 也同样适用。</p>
<h2 id="render-函数"><a href="#render-函数" class="headerlink" title="render 函数"></a>render 函数</h2><p>下面是一段简单的 template 模板代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>title<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    this is content</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们用渲染函数来重写上面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    <span class="keyword">let</span> _c = h</span><br><span class="line">    <span class="keyword">return</span> _c(<span class="string">'div'</span>, </span><br><span class="line">      &#123; <span class="attr">class</span>: <span class="string">'box'</span>&#125;, </span><br><span class="line">      [_c(<span class="string">'h2'</span>, &#123;&#125;, <span class="string">'title'</span>), <span class="string">'this is content'</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vuex-在页面刷新后状态丢失解决办法"><a href="#vuex-在页面刷新后状态丢失解决办法" class="headerlink" title="vuex 在页面刷新后状态丢失解决办法"></a>vuex 在页面刷新后状态丢失解决办法</h2><p>刷新页面后，存在 vuex 的数据会丢失，给调试带来不便。把用户的登录信息放到 sessionStorage 中避免丢失。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> USER_INFO = <span class="string">"userInfo"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    userInfo: <span class="built_in">JSON</span>.parse(sessionStorage.getItem(USER_INFO))</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    setUserInfo(state, userInfo)&#123;</span><br><span class="line">      <span class="comment">//存储到 sessionStorage 中以防刷新页面后状态丢失</span></span><br><span class="line">      sessionStorage.setItem(USER_INFO, <span class="built_in">JSON</span>.stringify(userInfo));</span><br><span class="line">      state.userInfo = userInfo</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="修改页面-Title"><a href="#修改页面-Title" class="headerlink" title="修改页面 Title"></a>修改页面 Title</h2><p>首先在 router.js 里，每个路由加上 meta ，设置 title</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/login'</span>,</span><br><span class="line">    name: <span class="string">'login'</span>,</span><br><span class="line">    component: Login,</span><br><span class="line">    meta:&#123;</span><br><span class="line">      title:<span class="string">'登录'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">'/home'</span>,</span><br><span class="line">    name: <span class="string">'home'</span>,</span><br><span class="line">    component: Home,</span><br><span class="line">    children: [],</span><br><span class="line">    meta:&#123;</span><br><span class="line">      title:<span class="string">'主页'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>然后在 main.js 里通过前置路由动态修改 title</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">/* 路由发生变化修改页面title */</span></span><br><span class="line">  <span class="keyword">if</span> (to.meta.title) &#123;</span><br><span class="line">    <span class="built_in">document</span>.title = to.meta.title;</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>Json最强攻略</title>
    <url>/2019/03/30/Json%E6%9C%80%E5%BC%BA%E6%94%BB%E7%95%A5/</url>
    <content><![CDATA[<h2 id="一、-JSON是什么？"><a href="#一、-JSON是什么？" class="headerlink" title="一、 JSON是什么？"></a>一、 JSON是什么？</h2><ul>
<li><p>JSON，全称“JavaScript Object Notation（JavaScript对象表示法）”，起源于JavaScript的对象和数组。JSON，说白了就是JavaScript用来处理数据的一种格式，这种格式非常简单易用。</p>
</li>
<li><p>JSON，大部分都是用来处理JavaScript和web服务器端之间的数据交换，把后台web服务器的数据传递到前台，然后使用JavaScript进行处理，例如ajax等。</p>
</li>
<li><p>JSON支持的语言非常多，包括JavaScript、C#、PHP、Java等等，这是由于JSON独立于语言的轻量级的数据交换格式，这个特点有点类似于SQL语言。</p>
</li>
<li><p>JSON，就是一种数据传输格式而已，无它，非常容易掌握。但是大家不要误以为JSON最大的用处是在前端，其实JSON最大的用处是处理JavaScript和web服务器端之间数据交换。</p>
</li>
</ul>
<a id="more"></a>

<h2 id="二、JSON对象结构"><a href="#二、JSON对象结构" class="headerlink" title="二、JSON对象结构"></a>二、JSON对象结构</h2><blockquote>
<p>JSON结构共有2种：<br>（1）对象结构；<br>（2）数组结构；</p>
</blockquote>
<h3 id="1、对象结构"><a href="#1、对象结构" class="headerlink" title="1、对象结构"></a>1、对象结构</h3><p>JSON，简单来说就是JavaScript中的对象或数组，所以这两种结构就是对象和数组。通过这两种结构就可以表示各种复杂的结构。</p>
<blockquote>
<p>对象结构是使用大括号“{}”括起来的，大括号内是由0个或多个用英文逗号分隔的“关键字:值”对（key:value）构成的。</p>
</blockquote>
<p><code>语法：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"键名1"</span>:值<span class="number">1</span>,</span><br><span class="line">    <span class="string">"键名2"</span>:值<span class="number">2</span>,</span><br><span class="line">    ……</span><br><span class="line">    <span class="string">"键名n"</span>:值n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：<br>jsonObj指的是json对象。对象结构是以“{”开始，到“}”结束。其中“键名”和“值”之间用英文冒号构成对，两个“键名:值”之间用英文逗号分隔。</p>
<p>注意，这里的键名是字符串，但是值可以是数值、字符串、对象、数组或逻辑true和false。</p>
<p><code>举例：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var obj =</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "</span>name<span class="string">":"</span>helicopter<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>age<span class="string">":23,</span></span><br><span class="line"><span class="string">            //JSON对象内部也有一个JSON对象</span></span><br><span class="line"><span class="string">            hobby:</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                "</span>first<span class="string">":"</span>swimming<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>second<span class="string">":"</span>singing<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>third<span class="string">":"</span>dancing<span class="string">"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        //读取JSON数据</span></span><br><span class="line"><span class="string">        document.write("</span>名字是：<span class="string">"+obj.name+"</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string">        document.write("</span>第一项爱好是：<span class="string">"+obj.hobby.first);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>在浏览器预览效果如下：</p>
<p><img src="http://static.zybuluo.com/wp0214/28qkfqjnwfg8zsx8oq9k72x1/image_1c1ui3ugh1q3g1lr8118f1i121dd519.png" alt="image_1c1ui3ugh1q3g1lr8118f1i121dd519.png-19.7kB"></p>
<p>  <strong>1、从JSON中读数据</strong></p>
<blockquote>
<p>对于JSON对象结构，读取JSON非常简单，获取JSON中的数据共有2种方式。</p>
</blockquote>
<p><code>语法：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">	</span><br><span class="line">jsonObj.key</span><br><span class="line">jsonObj[<span class="string">"key"</span>]</span><br></pre></td></tr></table></figure>
<p><code>说明：</code><br>jsonObj指的是JSON对象，key指的是键名。读取JSON数据使用的是“.”操作符，这个跟JavaScript对象读取属性值是差不多的。</p>
<p>实际例子请看上面举例。</p>
<p><strong>2、向JSON写数据</strong></p>
<blockquote>
<p>对于JSON对象结构，要往JSON中增加一条数据，也是使用“.”操作符。</p>
</blockquote>
<p><code>语法：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jsonObj.key = 值;</span><br><span class="line">jsonObj[<span class="string">"key"</span>] = 值;</span><br></pre></td></tr></table></figure>
<p><code>说明：</code><br>jsonObj指的是JSON对象，key指的是键名。</p>
<p><code>举例：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var obj =</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "</span>name<span class="string">":"</span>helicopter<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>age<span class="string">":23,</span></span><br><span class="line"><span class="string">            //JSON对象内部也有一个JSON对象</span></span><br><span class="line"><span class="string">            hobby:</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                "</span>first<span class="string">":"</span>swimming<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>second<span class="string">":"</span>singing<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>third<span class="string">":"</span>dancing<span class="string">"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        obj.gender = "</span>男<span class="string">";  //或者obj["</span>gender<span class="string">"]="</span>男<span class="string">";</span></span><br><span class="line"><span class="string">        document.write("</span>性别是：<span class="string">"+obj.gender);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>在浏览器预览效果如下：</p>
<p><img src="http://static.zybuluo.com/wp0214/qef8saddse2xv8wbu98mefnu/image_1c1ui96k610351uq31ck91e3b1ts51m.png" alt="在浏览器预览效果如下："></p>
<p> <strong>3、修改JSON中的数据</strong></p>
<blockquote>
<p>对于JSON对象结构，要修改JSON中的数据，也是使用“.”操作符。</p>
</blockquote>
<p><code>语法：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">jsonObj.key = 新值;</span><br></pre></td></tr></table></figure>
<p>举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var obj =</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "</span>name<span class="string">":"</span>helicopter<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>age<span class="string">":23,</span></span><br><span class="line"><span class="string">            "</span>gender<span class="string">":"</span>男<span class="string">",</span></span><br><span class="line"><span class="string">            //JSON对象内部也有一个JSON对象</span></span><br><span class="line"><span class="string">            hobby:</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                "</span>first<span class="string">":"</span>swimming<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>second<span class="string">":"</span>singing<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>third<span class="string">":"</span>dancing<span class="string">"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        obj.name = "</span>小杰<span class="string">";  //或者obj["</span>name<span class="string">"]="</span>小杰<span class="string">";</span></span><br><span class="line"><span class="string">        document.write("</span>姓名是：<span class="string">"+obj.name);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>在浏览器预览效果如下：<br><img src="http://static.zybuluo.com/wp0214/kmgposdk24gulgwfq745g4mq/image_1c1uid74elbi1s21nut1o8e1q6g23.png" alt="image_1c1uid74elbi1s21nut1o8e1q6g23.png-15kB"></p>
<p><strong>4、删除JSON中的数据</strong></p>
<blockquote>
<p>对于JSON对象结构，我们使用delete关键字来删除JSON中的数据。</p>
</blockquote>
<p><code>语法：</code></p>
<figure class="highlight plain"><figcaption><span>jsonObj.key;```</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#96;说明：&#96;</span><br><span class="line">删除JSON中数据非常简单，只需要使用delete关键字即可。</span><br><span class="line"></span><br><span class="line">&#96;举例：&#96;</span><br><span class="line">&#96;&#96;&#96; javascript</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;1999&#x2F;xhtml&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">        var obj &#x3D;</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;name&quot;:&quot;helicopter&quot;,</span><br><span class="line">            &quot;age&quot;:23,</span><br><span class="line">            &quot;gender&quot;:&quot;男&quot;,</span><br><span class="line">            &#x2F;&#x2F;JSON对象内部也有一个JSON对象</span><br><span class="line">            hobby:</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;first&quot;:&quot;swimming&quot;,</span><br><span class="line">                &quot;second&quot;:&quot;singing&quot;,</span><br><span class="line">                &quot;third&quot;:&quot;dancing&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        delete obj.age;</span><br><span class="line">        if(obj.age&#x3D;&#x3D;null)</span><br><span class="line">        &#123;</span><br><span class="line">            console(&quot;JSON中的年龄项已经被删除！&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>5、遍历JSON对象</strong></p>
<blockquote>
<p>对于JSON对象结构，可以使用for…in…循环来遍历JSON对象中的数据。</p>
</blockquote>
<p><code>举例：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var obj =</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "</span>name<span class="string">":"</span>helicopter<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>age<span class="string">":23,</span></span><br><span class="line"><span class="string">            "</span>gender<span class="string">":"</span>男<span class="string">",</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        for(var c in obj)</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            if(c=="</span>name<span class="string">")</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                document.write("</span>姓名是：<span class="string">"+obj[c]);</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>在浏览器预览效果如下：<br><img src="http://static.zybuluo.com/wp0214/iy624bkzch2rlev5jrz60z6j/image_1c1uimc401hkdk8a2qq14nn1ude2g.png" alt="image_1c1uimc401hkdk8a2qq14nn1ude2g.png-15.5kB"></p>
<h3 id="2、数组结构"><a href="#2、数组结构" class="headerlink" title="2、数组结构"></a>2、数组结构</h3><blockquote>
<p>JSON数组结构是用中括号“[]”括起来，中括号内部由0个或多个以英文逗号“,”分隔的值列表组成。</p>
</blockquote>
<p><code>语法：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr =</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"键名1"</span>:值<span class="number">1</span>,</span><br><span class="line">        <span class="string">"键名2"</span>:值<span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"键名3"</span>:值<span class="number">3</span>,</span><br><span class="line">        <span class="string">"键名4"</span>:值<span class="number">4</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ……</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p><code>说明：</code><br>arr指的是json数组。数组结构是以“[”开始，到“]”结束，这一点跟JSON对象不同。不过在JSON数组结构中，每一对“{}”相当于一个JSON对象，大家看看像不像？而且语法都非常类似。</p>
<p>注意，这里的键名是字符串，但是值可以是数值、字符串、对象、数组或逻辑true和false。</p>
<p><code>举例：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var arr =</span></span><br><span class="line"><span class="string">        [</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                "</span>name<span class="string">":"</span>小明<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>age<span class="string">":23,</span></span><br><span class="line"><span class="string">                "</span>gender<span class="string">":"</span>男<span class="string">"</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                "</span>name<span class="string">":"</span>小红<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>age<span class="string">":21,</span></span><br><span class="line"><span class="string">                "</span>gender<span class="string">":"</span>女<span class="string">"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">        //读取JSON数据</span></span><br><span class="line"><span class="string">        document.write("</span>第一个学生的名字是：<span class="string">"+arr[0].name+"</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string">        document.write("</span>第二个学生的性别是：<span class="string">"+arr[1].gender+"</span>&lt;br&gt;<span class="string">");</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>在浏览器预览效果如下：</p>
<p><img src="http://static.zybuluo.com/wp0214/v26g4p99j9m67jhbmaqh3xu6/image_1c1uitq791nva1egmvbs1jqhnh2t.png" alt="image_1c1uitq791nva1egmvbs1jqhnh2t.png-16.5kB"></p>
<p>JSON数组结构也是非常简单的，只需要通过数组下标来获取哪一个数组元素（一个“{}”的内容就类似一个数组元素），然后再配合使用“.”操作符就可以获取相应数组元素的内部数据。</p>
<p>对于获取、写入、修改、删除、遍历JSON数组结构中的数据，跟JSON对象结构的数据操作类似，大家对比琢磨一下基本就懂了，在此不再累赘讲解。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var arr =</span></span><br><span class="line"><span class="string">        [</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                "</span>name<span class="string">":"</span>小明<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>age<span class="string">":23,</span></span><br><span class="line"><span class="string">                "</span>gender<span class="string">":"</span>男<span class="string">"</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                "</span>name<span class="string">":"</span>小红<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>age<span class="string">":21,</span></span><br><span class="line"><span class="string">                "</span>gender<span class="string">":"</span>女<span class="string">"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">        delete arr[0];</span></span><br><span class="line"><span class="string">        arr[1].name="</span>小兰<span class="string">";</span></span><br><span class="line"><span class="string">        document.write("</span>第<span class="number">2</span>个学生的姓名是：<span class="string">"+arr[1].name);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="三、JSON对象和JSON字符串"><a href="#三、JSON对象和JSON字符串" class="headerlink" title="三、JSON对象和JSON字符串"></a>三、JSON对象和JSON字符串</h2><p><strong>普通字符串、JSON字符串和JSON对象</strong><br>初学者经常有一个困惑，就是分不清普通字符串、JSON字符串和JSON对象。其实这3者是非常容易区分的。</p>
<p>1、普通字符串<br>    字符串嘛，大家都知道是使用单引号或双引号括起来的一串字符。<br><code>举例：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"学习json教程"</span>;</span><br></pre></td></tr></table></figure>
<p>2、JSON对象<br>JSON对象我们在“JSON对象结构”这一节已经详细为大家讲解了。JSON对象，指的是符合JSON格式要求的JavaScript对象。<br><code>举例：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;<span class="string">"name"</span>:<span class="string">"helicopter"</span>,<span class="string">"age"</span>:<span class="number">23</span>,<span class="string">"gender"</span>:<span class="string">"男"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>3、JSON字符串<br>JSON字符串，指的是符合“JSON格式”的字符串。<br>JSON字符串要求两点：</p>
<p>（1）必须是字符串，也就是要用单引号或双引号括起来；</p>
<p>（2）必须符合“JSON”格式。<br><code>举例：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonStr = <span class="string">'&#123;"name": "helicopter", "age":23, "gender": "男"&#125;'</span>;</span><br></pre></td></tr></table></figure>
<p>JSON字符串说白了就是在JSON对象外面加一对单引号。</p>
<p>大家好好对比一下，就知道普通字符串、JSON对象和JSON字符串的区别了。</p>
<p>###JSON对象转换为JSON字符串</p>
<blockquote>
<p>在JSON中，可以使用JSON.stringify()方法将JSON对象转换为JSON字符串。</p>
</blockquote>
<p><code>语法：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(<span class="built_in">JSON</span>对象名);</span><br></pre></td></tr></table></figure>
<p><code>举例：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var obj =</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "</span>name<span class="string">":"</span>helicopter<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>age<span class="string">":23,</span></span><br><span class="line"><span class="string">            //JSON对象内部也有一个JSON对象</span></span><br><span class="line"><span class="string">            hobby:</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                "</span>first<span class="string">":"</span>swimming<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>second<span class="string">":"</span>singing<span class="string">",</span></span><br><span class="line"><span class="string">                "</span>third<span class="string">":"</span>dancing<span class="string">"</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        var jsonStr=JSON.stringify(obj);</span></span><br><span class="line"><span class="string">        document.write(jsonStr);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>在浏览器预览效果如下：<br><img src="http://static.zybuluo.com/wp0214/8r04wc4v20xqb8p05yfnmzh4/image_1c1ujb7d81fui9hhuk19sp89p3a.png" alt="image_1c1ujb7d81fui9hhuk19sp89p3a.png-34.5kB"></p>
<h3 id="JSON字符串转换为JSON对象"><a href="#JSON字符串转换为JSON对象" class="headerlink" title="JSON字符串转换为JSON对象"></a>JSON字符串转换为JSON对象</h3><p> 在JavaScript中，将JSON字符串转换为JSON对象非常有用。一般，在Web服务器后台向前台传输数据的过程中，往往都是用字符串形式来传输JSON数据。如果我们在前台想要获取JSON数据，就必须将JSON字符串转换为JSON对象才能操作。</p>
<blockquote>
<p>现在大多数浏览器（IE8及以上，Chrome和Firefox差不多全部）自带原生JSON对象，提供JSON.parse()方法来将JSON字符串转换为JSON对象。</p>
</blockquote>
<p><code>语法：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(字符串名);</span><br></pre></td></tr></table></figure>

<p><code>举例：</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html xmlns=<span class="string">"http://www.w3.org/1999/xhtml"</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">    &lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">        var jsonStr = '&#123;"</span>name<span class="string">": "</span>helicopter<span class="string">", "</span>age<span class="string">":23, "</span>gender<span class="string">": "</span>男<span class="string">"&#125;';</span></span><br><span class="line"><span class="string">        var jsonObj=JSON.parse(jsonStr);</span></span><br><span class="line"><span class="string">        document.write("</span>姓名是：<span class="string">"+jsonObj.name);</span></span><br><span class="line"><span class="string">    &lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML&amp;CSS入门</title>
    <url>/2016/03/29/HTML-CSS%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>HTML&amp;CSS基础入门总结</p>
<h2 id="一、使用-css-控制页面样式的方式"><a href="#一、使用-css-控制页面样式的方式" class="headerlink" title="一、使用 css 控制页面样式的方式"></a>一、使用 css 控制页面样式的方式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//行内样式</span></span><br><span class="line">&lt;div style=<span class="string">"属性1:值1;属性2:值2;"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/嵌入样式</span></span><br><span class="line"><span class="regexp">&lt;style type="text/</span>css<span class="string">"&gt;</span></span><br><span class="line"><span class="string">选择器&#123;属性1:值1;属性2:值2;&#125;</span></span><br><span class="line"><span class="string">&lt;/style&gt;</span></span><br><span class="line"><span class="string">//外部样式</span></span><br><span class="line"><span class="string">&lt;link rel="</span>stylesheet<span class="string">" type="</span>text/css<span class="string">" href="</span>url<span class="string">"&gt;</span></span><br><span class="line"><span class="string">//导入样式</span></span><br><span class="line"><span class="string">import url(外部样式表位置)；</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="二、css-选择器"><a href="#二、css-选择器" class="headerlink" title="二、css 选择器"></a>二、css 选择器</h2><blockquote>
<p>当我们定义一条样式规则时候，这条样式规则会作用于网页当中<br>的某些元素，而我们的规定的这些元素的规则就叫做选择器</p>
</blockquote>
<p>•  <strong>id选择器</strong><br>•  <strong>类选择器</strong><br>•  <strong>标签选择器</strong><br>• 交叉选择器<br>• 群组选择器<br>• 后代选择器 (包含选择器 )<br>• 通用选择器</p>
<h2 id="三、css-的继承性和叠加性"><a href="#三、css-的继承性和叠加性" class="headerlink" title="三、css 的继承性和叠加性"></a>三、css 的继承性和叠加性</h2><blockquote>
<p><strong>继承性</strong><br>后代元素会继承前辈元素的一些文字属性和样式</p>
</blockquote>
<blockquote>
<p><strong>叠加性</strong><br>同一个元素，被多个样式规则指定。<br>因为css的继承性和叠加性，就有了css优先级的概念</p>
</blockquote>
<h2 id="四、选择器的优先级"><a href="#四、选择器的优先级" class="headerlink" title="四、选择器的优先级"></a>四、选择器的优先级</h2><blockquote>
<p>所谓的优先级，指的就是哪条样式规则会最终作用于指定的元素</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">-</span> 在属性后面使用 !<span class="selector-tag">important</span> 会覆盖页面内任何位置定义的元素样式。</span><br><span class="line"><span class="selector-tag">-</span> 作为<span class="selector-tag">style</span>属性写在元素内的样式</span><br><span class="line"><span class="selector-tag">-</span> <span class="selector-tag">id</span>选择器</span><br><span class="line"><span class="selector-tag">-</span> 类选择器</span><br><span class="line"><span class="selector-tag">-</span> 标签选择器</span><br><span class="line"><span class="selector-tag">-</span> 通配符选择器</span><br><span class="line"><span class="selector-tag">-</span> 浏览器自定义或继承</span><br></pre></td></tr></table></figure>

<h2 id="五、元素类型"><a href="#五、元素类型" class="headerlink" title="五、元素类型"></a>五、元素类型</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&gt;  块元素</span><br><span class="line">&gt;		<span class="selector-tag">div</span>,<span class="selector-tag">h1-h6</span>,<span class="selector-tag">p</span>,<span class="selector-tag">ul</span>,<span class="selector-tag">li</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">dt</span>,<span class="selector-tag">dd</span>,<span class="selector-tag">header</span>,<span class="selector-tag">nav</span>,<span class="selector-tag">footer</span>,<span class="selector-tag">section</span>,<span class="selector-tag">article</span>,<span class="selector-tag">aside</span></span><br><span class="line">&gt;		特征：</span><br><span class="line">&gt;		1、默认独占一行</span><br><span class="line">&gt;		2、没有给宽度的时候，宽度是<span class="selector-tag">auto</span>，撑满一行(宽度就是父级的宽度)</span><br><span class="line">&gt;		3、支持所有的<span class="selector-tag">css</span>命令</span><br><span class="line">&gt;		</span><br><span class="line">&gt;	行内元素</span><br><span class="line">&gt;		<span class="selector-tag">a</span>,<span class="selector-tag">span</span>,<span class="selector-tag">strong</span>,<span class="selector-tag">em</span>,<span class="selector-tag">mark</span>,<span class="selector-tag">img</span>,<span class="selector-tag">time</span></span><br><span class="line">&gt;		特征：</span><br><span class="line">&gt;		1、内容撑开宽高</span><br><span class="line">&gt;			宽高的值都是<span class="selector-tag">auto</span>，只不过显出来的宽高是由内容撑开的</span><br><span class="line">&gt;		2、不支持设置宽高</span><br><span class="line">&gt;		3、不支持上下的<span class="selector-tag">margin</span>与上下<span class="selector-tag">padding</span>(左右支持)</span><br><span class="line">&gt;			上下的<span class="selector-tag">padding</span>是有问题，虽然把背影撑出来了，这个只是表面现象，它不会对其它的元素有影响</span><br><span class="line">&gt;		4、所有的行内元素都会在一行显示</span><br><span class="line">&gt;		5、代码换行会被解析成一个空格</span><br><span class="line">&gt;		</span><br><span class="line">&gt;	行内块元素</span><br><span class="line">&gt;		特征：</span><br><span class="line">&gt;			1、行内元素支持宽高</span><br><span class="line">&gt;			2、块元素可以在一行中显示</span><br><span class="line">&gt;			3、不给宽高的话，宽度会由内容撑开</span><br><span class="line">&gt;			4、代码换行会被解析成一个空格</span><br><span class="line">&gt;			5、<span class="selector-tag">IE6</span>、7不支持块元素的<span class="selector-tag">inline-block</span></span><br></pre></td></tr></table></figure>
<h3 id="块元素和行元素的相互转换"><a href="#块元素和行元素的相互转换" class="headerlink" title="块元素和行元素的相互转换"></a>块元素和行元素的相互转换</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">块元素转为行元素</span><br><span class="line">display:inline</span><br><span class="line"></span><br><span class="line">行元素转为块元素</span><br><span class="line">display:block</span><br><span class="line"></span><br><span class="line">行元素转为行内块元素</span><br><span class="line">display:inline-block</span><br><span class="line"></span><br><span class="line">为元素设置display: none; 可以让元素隐藏起来并且不</span><br><span class="line">占用页面空间,浏览器会完全忽略掉这个元素，该元素将</span><br><span class="line">不会被显示，也不会占据文档中的位置</span><br></pre></td></tr></table></figure>
<h2 id="六、css-文字属性"><a href="#六、css-文字属性" class="headerlink" title="六、css 文字属性"></a>六、css 文字属性</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">font</span>			文字</span><br><span class="line"><span class="selector-tag">font-weight</span>		文字着重</span><br><span class="line"><span class="selector-tag">font-style</span>		文字倾斜</span><br><span class="line"><span class="selector-tag">font-size</span>		文字大小（一般都为偶数）</span><br><span class="line"><span class="selector-tag">line-height</span>		文字行高		</span><br><span class="line"><span class="selector-tag">font-family</span>		字体（中文默认是宋体）</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">  </span><br><span class="line">### 文字样式 <span class="selector-tag">font</span></span><br><span class="line">``` <span class="selector-tag">css</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">font-weight</span>			文字加粗</span><br><span class="line">	<span class="selector-tag">weight</span>			加粗</span><br><span class="line">	<span class="selector-tag">normal</span>			正常</span><br><span class="line">	</span><br><span class="line"><span class="selector-tag">font-style</span>			文字倾斜</span><br><span class="line">	<span class="selector-tag">italic</span>			倾斜</span><br><span class="line">	<span class="selector-tag">normal</span>			正常</span><br><span class="line">	</span><br><span class="line"><span class="selector-tag">font-size</span>			文字大小</span><br><span class="line">	50<span class="selector-tag">px</span>			数字加单位</span><br><span class="line">	</span><br><span class="line"><span class="selector-tag">font-family</span>			文字字体</span><br><span class="line">	"主要字体","备选字体1","备选字体2"		表示如果用户电脑上有 “主要字体”，就显示"主要字体",如果用户电脑上没有主要字体",那就显示"备选字体1",如果用户电脑没有"备选字体1",就显示"备选字体2";</span><br><span class="line">	英文字体,"中文字体"		英文字符 使用英文字体，中文字符 使用 中文字体;</span><br><span class="line"></span><br><span class="line">举例:</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">font-weight</span>: bold;</span><br><span class="line">	<span class="attribute">font-style</span>: normal;</span><br><span class="line">	<span class="attribute">font-size</span>: <span class="number">50px</span>;</span><br><span class="line">	<span class="attribute">font-family</span>:arial,<span class="string">"华文行楷"</span>,<span class="string">"宋体"</span>,<span class="string">'楷体'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="行高-line-height"><a href="#行高-line-height" class="headerlink" title="行高 line-height"></a>行高 line-height</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">行高代表了一行文字在容器中所占的高度</span><br><span class="line"><span class="selector-tag">line-height</span>		行高	</span><br><span class="line">	'16px'		值是数字加单位</span><br><span class="line">	</span><br><span class="line">如果行高的值与容器的高度相等，那文字就会垂直居中</span><br><span class="line"></span><br><span class="line">测量多行文字行高的方法</span><br><span class="line">	1、首先要知道文字的大小</span><br><span class="line">	2、量下两行文字之间的距离</span><br><span class="line">	3、拿上面量出来的距离除上2</span><br><span class="line">	</span><br><span class="line">	如果行高为奇数的话，文字的上边距会小一像素，下边距会多一像素</span><br><span class="line">	</span><br><span class="line">	12	13/2=7.5		6	7</span><br><span class="line">举例:</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">30px</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文字复合样式"><a href="#文字复合样式" class="headerlink" title="文字复合样式"></a>文字复合样式</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">font:font-weight font-style font-size(必需)/line-height font-family(必需);</span><br><span class="line"></span><br><span class="line">举例:</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">font</span>: bold italic <span class="number">26px</span>/<span class="number">50px</span> <span class="string">"微软雅黑"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">文本</span><br><span class="line">			</span><br><span class="line"><span class="selector-tag">color</span>				颜色</span><br><span class="line"><span class="selector-tag">text-algin</span>			文本的对齐方式</span><br><span class="line"><span class="selector-tag">text-indent</span>			首行缩进（<span class="selector-tag">em</span>缩进字符）</span><br><span class="line"><span class="selector-tag">text-decoration</span>		文本修饰</span><br><span class="line"><span class="selector-tag">letter-spacing</span>		字母的间距</span><br><span class="line"><span class="selector-tag">word-spacing</span>		单词的间距（以空格来解析）</span><br><span class="line"><span class="selector-tag">white-space</span>			强制不换行</span><br><span class="line"></span><br><span class="line">详细:</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">color</span>				颜色</span><br><span class="line"><span class="selector-tag">text-algin</span>			文本的对齐方式</span><br><span class="line">	<span class="selector-tag">left</span>			左对齐（默认）</span><br><span class="line">	<span class="selector-tag">center</span>			居中对齐</span><br><span class="line">	<span class="selector-tag">right</span>			右对齐</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">text-indent</span>			首行缩进</span><br><span class="line">	32<span class="selector-tag">px</span>			值是数字加单位</span><br><span class="line">	</span><br><span class="line"><span class="selector-tag">text-decoration</span>		文本修饰</span><br><span class="line">	<span class="selector-tag">underline</span>		下划线</span><br><span class="line">	<span class="selector-tag">overline</span>		上划线</span><br><span class="line">	<span class="selector-tag">line-through</span>	中划线</span><br><span class="line">	<span class="selector-tag">none</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">letter-spacing</span>		字母间距</span><br><span class="line">	10<span class="selector-tag">px</span>			值为数字加单位</span><br><span class="line">	</span><br><span class="line"><span class="selector-tag">word-sapcing</span>		单词间距</span><br><span class="line">	10<span class="selector-tag">px</span>			值为数字加单位</span><br></pre></td></tr></table></figure>
<h3 id="七、盒模型"><a href="#七、盒模型" class="headerlink" title="七、盒模型"></a>七、盒模型</h3><blockquote>
<p>盒子模型是CSS的基石之一，布局最重要的概念，它<br>指定元素如何呈现在页面当中。网页就是由许多个盒<br>子通过不同的排列方式（纵向排列，横向排列，嵌套<br>排列）堆积而成。</p>
</blockquote>
<blockquote>
<p>页面上的每个元素都被浏览器看成是一个矩形盒子模型是由content（内容）、padding（内边距）、margin（外边距）和border（边框）组成。</p>
</blockquote>
<blockquote>
<p>默认情况下盒子的边框是无，背景色是透明，所以我们在默认情况下看不到盒子</p>
</blockquote>
<p><img src="http://img.blog.csdn.net/20160823131751824?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="enter image description here"></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">内容</span><br><span class="line">盒子里面所包含的元素和内容</span><br><span class="line"></span><br><span class="line">填充(内边距) (<span class="selector-tag">padding</span>)</span><br><span class="line">盒子里面的内容到盒子的边框之间的距离.</span><br><span class="line"><span class="selector-tag">padding-left</span>、 <span class="selector-tag">padding-right</span>、 <span class="selector-tag">padding-top</span>、<span class="selector-tag">padding-bottom</span></span><br><span class="line"></span><br><span class="line">边框(<span class="selector-tag">border</span>)</span><br><span class="line">盒子本身没有边框(<span class="selector-tag">border</span>)</span><br><span class="line"><span class="selector-tag">border-left</span>、 <span class="selector-tag">border-right</span>、 <span class="selector-tag">border-top</span>、 <span class="selector-tag">border-bottom</span></span><br><span class="line"></span><br><span class="line">外边距(<span class="selector-tag">margin</span>)</span><br><span class="line">• 边框外和其它盒子之间</span><br><span class="line"><span class="selector-tag">margin-left</span>、 <span class="selector-tag">margin-right</span>、 <span class="selector-tag">margin-top</span>、</span><br><span class="line"><span class="selector-tag">margin-bottom</span></span><br></pre></td></tr></table></figure>

<ul>
<li>边框（border）的组成：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">边框（<span class="selector-tag">border</span>）的组成</span><br><span class="line">1、边框的粗细</span><br><span class="line">	1<span class="selector-tag">px</span></span><br><span class="line">2、边框的样子</span><br><span class="line">	<span class="selector-tag">solid</span>		实线</span><br><span class="line">	<span class="selector-tag">dashed</span>		虚线</span><br><span class="line">	<span class="selector-tag">dotted</span>		点划线(不同的浏览器显示的是不一样的)</span><br><span class="line">3、边框的颜色</span><br><span class="line">	<span class="selector-tag">red</span>					颜色的英文单词</span><br><span class="line">	<span class="selector-id">#f00</span>				颜色的16进制表示法</span><br><span class="line">	<span class="selector-tag">rgba</span>(255,0,0,0<span class="selector-class">.5</span>)	颜色的<span class="selector-tag">rgb</span>的表示方法</span><br><span class="line">	</span><br><span class="line">举例 :</span><br><span class="line">&lt;<span class="selector-tag">style</span>&gt;</span><br><span class="line">	<span class="selector-tag">div</span>&#123;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">		<span class="attribute">border</span>: <span class="number">10px</span> solid <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.5</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>


<h2 id="八、overflow-属性"><a href="#八、overflow-属性" class="headerlink" title="八、overflow 属性"></a>八、overflow 属性</h2><blockquote>
<p>有时候，子元素的宽高会超出父元素的尺寸，我们需要对超出<br>的内容做一些设置。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">overflow			针对超出父级的内容如何显示</span><br><span class="line">	visible			默认值，超出的内容会显示出来</span><br><span class="line">	auto			如果内容超出了父级，那就出现滚动条。如果内容没有超出，就没有滚动条</span><br><span class="line">	hidden			超出的内容隐藏掉</span><br><span class="line">	scroll			不管内容有没有超出，都会出现滚动条</span><br></pre></td></tr></table></figure>

<h2 id="九、浮动-float"><a href="#九、浮动-float" class="headerlink" title="九、浮动 float"></a>九、浮动 float</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">定义			使元素脱离文档流，按照指定的方向发生移动，遇到父级的边界或者相邻的浮动元素就会停下来</span><br><span class="line">值			<span class="selector-tag">left</span>、<span class="selector-tag">right</span>、<span class="selector-tag">none</span></span><br><span class="line">特征</span><br><span class="line">			1、块元素可以在一行显示</span><br><span class="line">			2、按照一个指定的方向移动，遇到父级的边界或者相邻的浮动元素就会停下来</span><br><span class="line">			3、行内元素支持宽高</span><br><span class="line">			4、脱离文档流</span><br></pre></td></tr></table></figure>
<h3 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h3><blockquote>
<p>文档流<br>                文档中可显示的元素在排列时候的开始位置以及他们所占的区域<br>                因为页面中的元素分为不同的种类，所以他们会按各自的特点去显示，在页面中所占的区域不是一样的。会按从上到下，从左到右的顺序输出内容</p>
</blockquote>
<h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">清除浮动的方法</span><br><span class="line">	1、<span class="selector-tag">clear</span></span><br><span class="line">	2、给父级添加高度</span><br><span class="line">		有的时候是不能给父级添加高度的，所以这个方法就用不了（父级没有高度的情况下）</span><br><span class="line">	3、<span class="selector-tag">inline-block</span></span><br><span class="line">		具胡与上一个的清除浮动一样的总是，同时加了以后这个元素就没有办法居中了</span><br><span class="line">	4、<span class="selector-tag">overflow</span><span class="selector-pseudo">:hidden</span>;</span><br><span class="line">		如果子级有定位的话，并且这个定位超出了父级的范围，那样的话就看不到了，所以不能加这个命令</span><br><span class="line">	5、空标签</span><br><span class="line">		空标签是没有内容，但是它的作用是用来清除浮动的，所以不符合行为、样式、结构相分离的标准</span><br><span class="line">		<span class="selector-tag">ie6</span>下标签是有一个最小高度19<span class="selector-tag">px</span>，解决后也会有2像素的偏差</span><br><span class="line">	6、<span class="selector-tag">br</span>清除浮动</span><br><span class="line">		与上面的问题是一样</span><br><span class="line">	7、<span class="selector-tag">after</span>伪类清除浮动（现在最主流的方法）</span><br><span class="line"></span><br><span class="line">	示例:</span><br><span class="line">	<span class="selector-class">.clearfix</span>&#123;</span><br><span class="line">		*zoom:1;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">		<span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">		<span class="attribute">display</span>: block;</span><br><span class="line">		<span class="attribute">clear</span>: both;</span><br><span class="line">		<span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">		<span class="attribute">overflow</span>: hidden;</span><br><span class="line">		<span class="attribute">visibility</span>: hidden;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<br/>

<h2 id="十、定位-position"><a href="#十、定位-position" class="headerlink" title="十、定位 position"></a>十、定位 position</h2><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span>				定位</span><br><span class="line">	<span class="selector-tag">relative</span>			相对定位</span><br><span class="line">		移动的方向</span><br><span class="line">			<span class="selector-tag">top</span>、<span class="selector-tag">right</span>、<span class="selector-tag">bottom</span>、<span class="selector-tag">left</span></span><br><span class="line">		特点</span><br><span class="line">			1、只加相对定位，不设置元素移动的位置，元素和之前是没有变化</span><br><span class="line">			2、根据自己原来的位置计算移动的位置</span><br><span class="line">			3、不脱离文档流，元素移走以后，原来的位置还会被保留</span><br><span class="line">			4、加上相对定位后对原来的元素本身的特征没有影响</span><br><span class="line">			5、提升层级</span><br><span class="line">			</span><br><span class="line">	示例:</span><br><span class="line">	<span class="selector-class">.div2</span>&#123;</span><br><span class="line">		<span class="attribute">background</span>: green;</span><br><span class="line">		<span class="attribute">position</span>: relative;</span><br><span class="line">		<span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">		<span class="attribute">top</span>: <span class="number">200px</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>


<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">absolute</span>			绝对定位</span><br><span class="line">	移动的方向</span><br><span class="line">		<span class="selector-tag">top</span>、<span class="selector-tag">right</span>、<span class="selector-tag">bottom</span>、<span class="selector-tag">left</span></span><br><span class="line">	特点</span><br><span class="line">		1、完全脱离文档流</span><br><span class="line">		2、行内元素支持所有样式（与加上浮动或者<span class="selector-tag">inline-block</span>以后的效果是一样的）</span><br><span class="line">		3、如果父级有定位，那位置会根据父级移动。如果父级没有定位，那位置根据可视区移动</span><br><span class="line">			(一般情况下，要用到绝对定位的时候，都会给父级来一个相对定位)</span><br><span class="line">		4、提升层级</span><br><span class="line">			5、提升层级</span><br><span class="line">			</span><br><span class="line">	示例:</span><br><span class="line">	<span class="selector-class">.div2</span>&#123;</span><br><span class="line">		<span class="attribute">background</span>: green;</span><br><span class="line">		<span class="attribute">position</span>: absolute;</span><br><span class="line">		<span class="attribute">left</span>: <span class="number">200px</span>;</span><br><span class="line">		<span class="attribute">top</span>: <span class="number">200px</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="十一、背景（background）"><a href="#十一、背景（background）" class="headerlink" title="十一、背景（background）"></a>十一、背景（background）</h2><h3 id="背景（background）的组成："><a href="#背景（background）的组成：" class="headerlink" title="背景（background）的组成："></a>背景（background）的组成：</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">background</span>				背景</span><br><span class="line"><span class="selector-tag">background-color</span>		背景色</span><br><span class="line"><span class="selector-tag">backgounnd-image</span>		背景图片</span><br><span class="line"><span class="selector-tag">background-repeat</span>		背景图片是否重复</span><br><span class="line"><span class="selector-tag">background-position</span>		背景图片的位置</span><br><span class="line"><span class="selector-tag">background-attachment</span>	背景图片是否滚动</span><br></pre></td></tr></table></figure>
<h3 id="背景色-background-color"><a href="#背景色-background-color" class="headerlink" title="背景色 background-color"></a>背景色 background-color</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>		背景色</span><br><span class="line"></span><br><span class="line">内容可以把容器的宽高撑开</span><br><span class="line">背景不会占用容器的宽高</span><br><span class="line"></span><br><span class="line">举例:</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">	<span class="attribute">background-color</span>:green;</span><br><span class="line">	<span class="attribute">background-color</span>:<span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">107</span>,<span class="number">35</span>,<span class="number">1</span>);</span><br><span class="line">	<span class="attribute">background-color</span>:<span class="number">#008800</span>;		<span class="comment">/*#080*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="背景图片-background-image"><a href="#背景图片-background-image" class="headerlink" title="背景图片 background-image"></a>背景图片 background-image</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">background-image</span>		背景图片</span><br><span class="line">		<span class="selector-tag">url</span>(图片的地址)</span><br><span class="line">		<span class="selector-tag">none</span>			没有背景图（默认）</span><br><span class="line">		</span><br><span class="line">背景图默认会铺满整个容器</span><br><span class="line"></span><br><span class="line">举例:</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">	<span class="attribute">background-image</span>:<span class="built_in">url</span>(images/img.jpg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="背景图重复-background-repeat"><a href="#背景图重复-background-repeat" class="headerlink" title="背景图重复 background-repeat"></a>背景图重复 background-repeat</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">background-repeat</span>			背景图是否重复平铺</span><br><span class="line">		<span class="selector-tag">no-repeat</span>			不重复平铺</span><br><span class="line">		<span class="selector-tag">repeat-x</span>			横向平铺</span><br><span class="line">		<span class="selector-tag">repeat-y</span>			纵向平铺</span><br><span class="line">		<span class="selector-tag">repeat</span>				全部平铺（默认值）</span><br><span class="line">		</span><br><span class="line">背景图默认会铺满整个容器</span><br><span class="line"></span><br><span class="line">举例:</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">	<span class="attribute">background-image</span>:<span class="built_in">url</span>(images/img.jpg);</span><br><span class="line">	<span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">	<span class="attribute">background-repeat</span>: repeat-x;</span><br><span class="line">	<span class="attribute">background-repeat</span>: repeat-y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="背景图片位置-background-position"><a href="#背景图片位置-background-position" class="headerlink" title="背景图片位置 background-position"></a>背景图片位置 background-position</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-tag">background-position</span><span class="selector-pseudo">:x</span> <span class="selector-tag">y</span>;			背景图片的位置</span><br><span class="line">	传数值：（背景图片离左上角的距离）</span><br><span class="line">			<span class="selector-tag">x</span>:</span><br><span class="line">				正值		从容器的左边往右边走的距离</span><br><span class="line">				负值		从容器的左边往左边走的距离</span><br><span class="line">			<span class="selector-tag">y</span>:</span><br><span class="line">				正值		从容器的上边往下边走的距离</span><br><span class="line">				负值		从容器的上边往上边走的距离</span><br><span class="line">	传关键字</span><br><span class="line">			<span class="selector-tag">x</span>:</span><br><span class="line">				<span class="selector-tag">left</span>	图片在容器的左边</span><br><span class="line">				<span class="selector-tag">center</span>	图片在容器<span class="selector-tag">X</span>轴的中心</span><br><span class="line">				<span class="selector-tag">right</span>	图片在容器的右边</span><br><span class="line">			<span class="selector-tag">y</span>:</span><br><span class="line">				<span class="selector-tag">top</span>		图片在容器的上边</span><br><span class="line">				<span class="selector-tag">center</span>	图片在容器<span class="selector-tag">Y</span>轴的中心</span><br><span class="line">				<span class="selector-tag">bottom</span>	图片在容器的下边</span><br><span class="line">				</span><br><span class="line">	</span><br><span class="line">	如果只传一个值的话，那另一个值默认为<span class="selector-tag">center</span></span><br><span class="line">	如果两个值都不写的话，那默认为0，0点，左上角</span><br><span class="line"></span><br><span class="line">举例:</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">	<span class="attribute">background-image</span>:<span class="built_in">url</span>(images/img.jpg);</span><br><span class="line">	<span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">	<span class="attribute">background-repeat</span>: repeat-x;</span><br><span class="line">	<span class="attribute">background-repeat</span>: repeat-y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="背景图复合样式-background-推荐"><a href="#背景图复合样式-background-推荐" class="headerlink" title="背景图复合样式 background ( 推荐 )"></a>背景图复合样式 background ( 推荐 )</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">举例:</span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">	<span class="attribute">border</span>: <span class="number">10px</span> solid red;</span><br><span class="line">	<span class="comment">/*background-image: url(images/img.jpg);</span></span><br><span class="line"><span class="comment">	background-position: left top;</span></span><br><span class="line"><span class="comment">	background-repeat: no-repeat;</span></span><br><span class="line"><span class="comment">	background-attachment: scroll;*/</span></span><br><span class="line">	<span class="attribute">background</span>: green <span class="built_in">url</span>(images/img.jpg) no-repeat center top scroll;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="十二、html-amp-html5标签"><a href="#十二、html-amp-html5标签" class="headerlink" title="十二、html&amp;html5标签"></a>十二、html&amp;html5标签</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;h1&gt;...&lt;&#x2F;h1&gt; 标题字(最大)</span><br><span class="line">&lt;h6&gt;...&lt;&#x2F;h6&gt; 标题字(最小)</span><br><span class="line">&lt;ul&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ul&gt; 无序列表</span><br><span class="line">&lt;ol&gt; &lt;li&gt;&lt;&#x2F;li&gt; &lt;&#x2F;ol&gt; 有序列表</span><br><span class="line">&lt;strong&gt;...&lt;&#x2F;strong&gt; 粗体字</span><br><span class="line">&lt;em&gt;...&lt;&#x2F;em&gt; 		 斜体字</span><br><span class="line">&lt;span&gt;…&lt;&#x2F;span&gt;       无意义的文字标签</span><br><span class="line">&lt;a&gt;…&lt;&#x2F;a&gt; 			 链接标签</span><br><span class="line">&lt;img&gt;				 图片标签</span><br><span class="line"></span><br><span class="line">html5</span><br><span class="line">新的特殊内容元素 article、footer、header、nav、section</span><br><span class="line">新的表单控件，比如 calendar、date、time、email、url、search</span><br></pre></td></tr></table></figure>
<h2 id="十三、transition过渡效果"><a href="#十三、transition过渡效果" class="headerlink" title="十三、transition过渡效果"></a>十三、transition过渡效果</h2><blockquote>
<p>过渡效果：<br>• 过渡效果允许css的属性值在一定的时间区间内平滑地过渡。这种效果可以在鼠标单击、<br>获得焦点或对元素任何改变中触发，并圆滑地以动画效果改变CSS的属性值<br>transition简写形式:<br>• transition: transition-property transition-duration transition-timing-function<br>transition-delay<br>transition-property:<br>• 指定应用过渡的属性，值为：none(没有属性改变)；all（所有属性改变）这<br>个也是其默认值；indent（元素属性名）。<br>transition-duration:<br>• 指定元素 转换过程的持续时间，单位为s（秒）或者ms(毫秒)<br>transition-delay：<br>• 指定动画开始执行前的延迟时间，单位为s（秒）或者ms(毫秒)</p>
</blockquote>
<h2 id="十四、大波练习…"><a href="#十四、大波练习…" class="headerlink" title="十四、大波练习…"></a>十四、大波练习…</h2>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>axios-大众版封装</title>
    <url>/2020/03/30/axios-%E5%A4%A7%E4%BC%97%E7%89%88%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p>直接上代码吧，比较简单</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'router/index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; TIMEOUT &#125; <span class="keyword">from</span> <span class="string">'helpers/config'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; getToken &#125; <span class="keyword">from</span> <span class="string">'../helpers/cache'</span>;</span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">'querystring'</span>;</span><br><span class="line"><span class="keyword">import</span> Message <span class="keyword">from</span> <span class="string">'components/dc-message/index'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置一</span></span><br><span class="line"><span class="keyword">const</span> service = axios.create(&#123;</span><br><span class="line">  baseURL: process.env.VUE_APP_URL,</span><br><span class="line">  timeout: TIMEOUT,</span><br><span class="line">  withCredentials: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置请求头</span></span><br><span class="line">service.defaults.headers = &#123;</span><br><span class="line">  post: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/json;charset=utf-8'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截</span></span><br><span class="line">service.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> token = getToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token) &#123;</span><br><span class="line">      config.headers.Authorization = <span class="string">`Bearer <span class="subst">$&#123;token.access_token&#125;</span>`</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/^application\/x-www-form-urlencoded/</span>.test(config.headers[<span class="string">'Content-Type'</span>])) &#123;</span><br><span class="line">      config.data = qs.stringify(config.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.error(error.data);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截</span></span><br><span class="line">service.interceptors.response.use(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.status === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(res.data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(res.data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    <span class="keyword">if</span> (error.response.data &amp;&amp; error.response.data.status === <span class="number">401</span>) &#123;</span><br><span class="line">      router.replace(&#123;</span><br><span class="line">        path: <span class="string">'/login'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          redirect: router.currentRoute.fullPath</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Message(<span class="string">`<span class="subst">$&#123;error.response.status&#125;</span>: <span class="subst">$&#123;error.response.data.message ? error.response.data.message : error.response.data.error_description&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error.response);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> service;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>axios</tag>
      </tags>
  </entry>
  <entry>
    <title>egret白鹭入门教程-3小时开发一款小游戏</title>
    <url>/2020/04/19/egret%E7%99%BD%E9%B9%AD%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B-3%E5%B0%8F%E6%97%B6%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BE%E5%B0%8F%E6%B8%B8%E6%88%8F/</url>
    <content><![CDATA[<h2 id="什么是egret白鹭引擎"><a href="#什么是egret白鹭引擎" class="headerlink" title="什么是egret白鹭引擎"></a>什么是egret白鹭引擎</h2><p>Egret是一套HTML5游戏开发解决方案，灵活地满足开发者开发 2D 或 3D 游戏的需求（渲染模式基于webgl与canvas切换,并且完善的跨平台支持,在任何平台都可使用</p>
<p>生态产品包含Egret Engine，Egret Wing，EgretVS，Res Depot，Texture Merger，TS Conversion，Egret Feather，Egret Inspector，DragonBones，Lakeshore等。</p>
<p>而核心产品是Egret Engine，是一个基于TypeScript语言开发的一个HTML5游戏引擎，其余的大多是开发和辅助工具。</p>
<a id="more"></a>

<h2 id="开发准备"><a href="#开发准备" class="headerlink" title="开发准备"></a>开发准备</h2><p><strong>开发工具</strong></p>
<ul>
<li><p>引擎库管理工具 EgretLauncher <a href="https://docs.egret.com/engine" target="_blank" rel="noopener">下载地址</a> 安装后，切换到引擎面板，选择最新的引擎版本下载</p>
</li>
<li><p>IDE代码工具选择vscode下载安装</p>
</li>
<li><p>代码调试（Egret Inspector）[进行界面与代码调试]</p>
</li>
</ul>
<p><strong>图片素材</strong><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200419101404.png" alt=""></p>
<h2 id="开发目录"><a href="#开发目录" class="headerlink" title="开发目录"></a>开发目录</h2><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line">app</span><br><span class="line">├── egretProperties.json</span><br><span class="line">├── favicon.ico</span><br><span class="line">├── index.html </span><br><span class="line">├── libs</span><br><span class="line">├── manifest.json</span><br><span class="line">├── README.md</span><br><span class="line">├── resource</span><br><span class="line">│   ├── assets</span><br><span class="line">│   └── <span class="keyword">default</span>.res.json</span><br><span class="line">├── src    <span class="comment">//开发目录</span></span><br><span class="line">│   ├── api <span class="comment">//http封装与接口</span></span><br><span class="line">│   │   ├── Api.ts</span><br><span class="line">│   │   └── Http.ts</span><br><span class="line">│   ├── common<span class="comment">//公共组件与类</span></span><br><span class="line">│   │   ├── GameEvent.ts</span><br><span class="line">│   │   ├── Point.ts</span><br><span class="line">│   │   └── Utils.ts</span><br><span class="line">│   ├── game</span><br><span class="line">│   │   ├── Example.ts</span><br><span class="line">│   │   └── TimerPanel.ts</span><br><span class="line">│   ├── Main.ts <span class="comment">//主场景入口</span></span><br><span class="line">│   ├── scene   <span class="comment">//其它各场景</span></span><br><span class="line">│   │   ├── BaseScene.ts</span><br><span class="line">│   │   ├── EndScenes.ts</span><br><span class="line">│   │   ├── LoadingScene.ts</span><br><span class="line">│   │   ├── PlayScene.ts</span><br><span class="line">│   │   ├── SceneController.ts</span><br><span class="line">│   │   └── StartScene.ts</span><br><span class="line">│   └── store</span><br><span class="line">│       └── Data.ts</span><br><span class="line">├── template</span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/RocWangPeng/egret-demo" target="_blank" rel="noopener">仓库地址</a></p>
]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>css多行文本溢出显示省略号...</title>
    <url>/2019/10/30/css%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7/</url>
    <content><![CDATA[<p>大家应该都知道用text-overflow:ellipsis属性来实现单行文本的溢出显示省略号(…)。当然部分浏览器还需要加宽度width属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">white-space</span>: <span class="selector-tag">nowrap</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>但是这个属性并不支持多行文本溢出显示省略号，这里根据应用场景介绍几个方法来实现这样的效果。</p>
<p>WebKit浏览器或移动端的页面</p>
<p>在WebKit浏览器或移动端（绝大部分是WebKit内核的浏览器）的页面实现比较简单，可以直接使用WebKit的CSS扩展属性(WebKit是私有属性)-webkit-line-clamp </p>
<p><code>-webkit-line-clamp</code>用来限制在一个块元素显示的文本的行数。 为了实现该效果，它需要组合其他的WebKit属性</p>
<p>常见结合属性：</p>
<ul>
<li><code>display: -webkit-box</code>; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。</li>
<li><code>-webkit-box-orient</code> 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。</li>
<li><code>text-overflow: ellipsis</code>;，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span> : <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span>: 2;</span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>egret白鹭入门教程一</title>
    <url>/2020/04/13/egret%E7%99%BD%E9%B9%AD%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%E4%B8%80/</url>
    <content><![CDATA[<h2 id="什么是egret白鹭引擎"><a href="#什么是egret白鹭引擎" class="headerlink" title="什么是egret白鹭引擎"></a>什么是egret白鹭引擎</h2><p>Egret是一套HTML5游戏开发解决方案，灵活地满足开发者开发 2D 或 3D 游戏的需求（渲染模式基于webgl与canvas切换,并且完善的跨平台支持,在任何平台都可使用</p>
<p>生态产品包含Egret Engine，Egret Wing，EgretVS，Res Depot，Texture Merger，TS Conversion，Egret Feather，Egret Inspector，DragonBones，Lakeshore等。</p>
<p>而核心产品是Egret Engine，是一个基于TypeScript语言开发的一个HTML5游戏引擎，其余的大多是开发和辅助工具。</p>
<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>1、第一步：引擎库管理工具 EgretLauncher <a href="https://docs.egret.com/engine" target="_blank" rel="noopener">下载地址</a> 然后下一步…安装</p>
<p>2、第二步：打开 EgretLauncher，切换到引擎面板，并点击引擎的最新稳定版进行下载</p>
<p>3、第三步：切换到工具面板，可选择性的下载和安装开发工具（我没有安装，我用vscode进行开发）</p>
<a id="more"></a>

<p><strong>提供以下工具下载</strong></p>
<ul>
<li>Egret UI Editor</li>
<li>Egret Wing 代码和界面制作工具</li>
<li>DragonBones 龙骨动画制作工具</li>
<li>TextureMerger 图片资源合并工具</li>
<li>Res Depot 资源管理工具</li>
<li>Egret Feather 粒子制作工具</li>
</ul>
<p>注意：</p>
<blockquote>
<p>Egret UI Editor 是 Egret Wing 的升级版本，官方在 2019 年发布 Egret UI Editor 的设计目标是，使用 UI Editor + VSCode 取代现有的Egret Wing。</p>
</blockquote>
<h2 id="快速创建并启动项目"><a href="#快速创建并启动项目" class="headerlink" title="快速创建并启动项目"></a>快速创建并启动项目</h2><p>创建名为【HelloWorld】的一个项目</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 确认egret命令环境变量已经存在</span></span><br><span class="line">egret create HelloWorld</span><br></pre></td></tr></table></figure>

<p>启动HelloWorld项目</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在编辑器打开项目，并执行命令</span></span><br><span class="line">egret run HelloWorld</span><br></pre></td></tr></table></figure>
<p>大功告成</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200413195420.png" alt=""></p>
<p>注意：</p>
<blockquote>
<p>执行 <code>egret run HelloWorld -a</code> 可监控文件变化，实时编译最新结果</p>
</blockquote>
<h2 id="初步尝试"><a href="#初步尝试" class="headerlink" title="初步尝试"></a>初步尝试</h2><p>介绍项目目录：</p>
<ul>
<li>src是TypeScript源码目录，</li>
<li>bin-debug是调试环境编译出来的js，</li>
<li>libs是文件包的引用目录，</li>
<li>template主要是app用到的runtime；</li>
<li>resource是我们项目中的资源路径，一般我们把图片音频等素材放置asset目录下，json等配置文件放置config目录下，</li>
<li>default.res.json是我们用于加载资源的json配置文件，一般不修改名字，后面会讲到怎么使用。</li>
<li>egretProperties是我们这个项目的一些配置记录信息，一般我们不需要动它。</li>
<li>index.html就是我们游戏的主界面文件。</li>
</ul>
<p><strong>打开 index.html</strong><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200413195024.png" alt=""></p>
<p>将data-show-fps和data-show-log设成true，我们就可以看到游戏运行的实时帧率了。</p>
<p>帧率可以检测游戏运行的流畅度（性能），渲染数量越多，同时计算量越大，性能就越差，掉帧就越多。所以帧率越高，则表示性能越好，流畅度高。</p>
<p>另外，在底部，我们还能看到一个egret.runEgret({})的运行方法，在这里，可以修改egret的渲染模式，默认是”webgl”。</p>
<h2 id="最常用的几个-api"><a href="#最常用的几个-api" class="headerlink" title="最常用的几个 api"></a>最常用的几个 api</h2><h3 id="关于文本"><a href="#关于文本" class="headerlink" title="关于文本"></a>关于文本</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> label:egret.TextField = <span class="keyword">new</span> egret.TextField(); </span><br><span class="line">label.text = <span class="string">"hello world!"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="关于图片"><a href="#关于图片" class="headerlink" title="关于图片"></a>关于图片</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> img:egret.Bitmap = <span class="keyword">new</span> egret.Bitmap();</span><br><span class="line">img.texture = RES.getRes(<span class="string">"imgName"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="关于形状"><a href="#关于形状" class="headerlink" title="关于形状"></a>关于形状</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 画个红色矩形框</span></span><br><span class="line"><span class="keyword">let</span> shp:egret.Shape = <span class="keyword">new</span> egret.Shape();</span><br><span class="line">shp.graphics.beginFill( <span class="number">0xff0000</span>, <span class="number">1</span>);</span><br><span class="line">shp.graphics.drawRect( <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span> );</span><br><span class="line">shp.graphics.endFill();</span><br></pre></td></tr></table></figure>

<h3 id="关于声音"><a href="#关于声音" class="headerlink" title="关于声音"></a>关于声音</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 画个红色矩形框</span></span><br><span class="line"><span class="keyword">let</span> sound:egret.Sound = RES.getRes(<span class="string">"mp3Name"</span>);</span><br><span class="line">sound.play();</span><br><span class="line">sound.stop();</span><br></pre></td></tr></table></figure>

<h3 id="关于事件"><a href="#关于事件" class="headerlink" title="关于事件"></a>关于事件</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 触摸事件（相当于点击）</span></span><br><span class="line"><span class="keyword">this</span>.addEventListener(egret.TouchEvent.TOUCH_TAP, <span class="keyword">this</span>.onTouchTap, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">this</span>.removeEventListener(egret.TouchEvent.TOUCH_TAP, <span class="keyword">this</span>.onTouchTap, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>

<h3 id="关于计时器"><a href="#关于计时器" class="headerlink" title="关于计时器"></a>关于计时器</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数为时间间隔（ms）和执行次数</span></span><br><span class="line"><span class="keyword">let</span> timer:egret.Timer = <span class="keyword">new</span> egret.Timer(<span class="number">500</span>, <span class="number">5</span>); </span><br><span class="line"><span class="comment">// 边计时边触发</span></span><br><span class="line">timer.addEventListener(egret.TimerEvent.TIMER, <span class="keyword">this</span>.timerFunc, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 计时结束触发</span></span><br><span class="line">timer.addEventListener(egret.TimerEvent.TIMER_COMPLETE, <span class="keyword">this</span>.timerComFunc, <span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 开始计时</span></span><br><span class="line">timer.start();</span><br><span class="line"><span class="comment">// 暂停计时</span></span><br><span class="line">timer.stop();</span><br><span class="line"><span class="comment">// 重新计时</span></span><br><span class="line">timer.reset();</span><br></pre></td></tr></table></figure>
<h3 id="关于数据存储"><a href="#关于数据存储" class="headerlink" title="关于数据存储"></a>关于数据存储</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储数据</span></span><br><span class="line"><span class="keyword">let</span> key:string = <span class="string">"score"</span>;</span><br><span class="line"><span class="keyword">let</span> value:string = <span class="string">"100"</span>;</span><br><span class="line">egret.localStorage.setItem(key, value);</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="keyword">let</span> score:string = egret.localStorage.getItem(key);</span><br><span class="line"><span class="comment">// 移除数据</span></span><br><span class="line">egret.localStorage.removeItem(key);</span><br><span class="line"><span class="comment">// 清除所有数据</span></span><br><span class="line">egret.localStorage.clear();</span><br></pre></td></tr></table></figure>

<h2 id="小贴士"><a href="#小贴士" class="headerlink" title="小贴士"></a>小贴士</h2><ul>
<li>1、写代码需要用 ts（规范的 js） 进行开发。</li>
<li>2、egret 游戏默认是 30 帧的。</li>
<li>3、大部分 api 是以 egret 开头的，读取资源的是用 RES。</li>
<li>4、有时候你改了代码不生效或者突然报错，别慌，试试重启大法。</li>
<li>5、长度单位是像素。</li>
<li>6、每个 egret 应有且只有一个舞台（也就是 stage 对象）。舞台是 egret 显示架构中最根本的显示容器。舞台的坐标原点位于左上角。</li>
</ul>
]]></content>
      <categories>
        <category>游戏开发</category>
      </categories>
      <tags>
        <tag>游戏开发</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>js 常用事件大全</title>
    <url>/2016/05/29/js-%E5%B8%B8%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>js 常用事件大全</p>
<h2 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">click 当用户点击某个对象时调用的事件句柄。 </span><br><span class="line">contextmenu 在用户点击鼠标右键打开上下文菜单时触发 </span><br><span class="line">dblclick 当用户双击某个对象时调用的事件句柄。 </span><br><span class="line">mousedown 鼠标按钮被按下。 </span><br><span class="line">mouseenter 当鼠标指针移动到元素上时触发。 </span><br><span class="line">mouseleave 当鼠标指针移出元素时触发 </span><br><span class="line">mousemove 鼠标被移动。 </span><br><span class="line">mouseover 鼠标移到某元素之上。 </span><br><span class="line">mouseout 鼠标从某元素移开。 </span><br><span class="line">mouseup 鼠标按键被松开。</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">属性 描述 DOM </span><br><span class="line">keydown 某个键盘按键被按下。 </span><br><span class="line">keypress 某个键盘按键被按下并松开。 </span><br><span class="line">keyup 某个键盘按键被松开。</span><br></pre></td></tr></table></figure>

<h2 id="框架-对象（Frame-Object）事件"><a href="#框架-对象（Frame-Object）事件" class="headerlink" title="框架/对象（Frame/Object）事件"></a>框架/对象（Frame/Object）事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abort 图像的加载被中断。 ( ) </span><br><span class="line">beforeunload 该事件在即将离开页面（刷新或关闭）时触发 </span><br><span class="line">error 在加载文档或图像时发生错误。 ( , 和 ) </span><br><span class="line">hashchange 该事件在当前 URL 的锚部分发生修改时触发。 </span><br><span class="line">load 一张页面或一幅图像完成加载。 </span><br><span class="line">pageshow 该事件在用户访问页面时触发 </span><br><span class="line">pagehide 该事件在用户离开当前网页跳转到另外一个页面时触发 </span><br><span class="line">resize 窗口或框架被重新调整大小。 </span><br><span class="line">scroll 当文档被滚动时发生的事件。 </span><br><span class="line">unload 用户退出页面。 ( 和 )</span><br></pre></td></tr></table></figure>
<h2 id="表单事件"><a href="#表单事件" class="headerlink" title="表单事件"></a>表单事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blur 元素失去焦点时触发 </span><br><span class="line">change 该事件在表单元素的内容改变时触发( , , , 和 ) </span><br><span class="line">focus 元素获取焦点时触发 </span><br><span class="line">focusin 元素即将获取焦点是触发 </span><br><span class="line">focusout 元素即将失去焦点是触发 </span><br><span class="line">input 元素获取用户输入是触发 </span><br><span class="line">reset 表单重置时触发 </span><br><span class="line">search 用户向搜索域输入文本时触发</span><br></pre></td></tr></table></figure>
<h2 id="剪贴板事件"><a href="#剪贴板事件" class="headerlink" title="剪贴板事件"></a>剪贴板事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy 该事件在用户拷贝元素内容时触发 </span><br><span class="line">cut 该事件在用户剪切元素内容时触发 </span><br><span class="line">paste 该事件在用户粘贴元素内容时触发</span><br></pre></td></tr></table></figure>
<h2 id="打印事件"><a href="#打印事件" class="headerlink" title="打印事件"></a>打印事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">afterprint 该事件在页面已经开始打印，或者打印窗口已经关闭时触发 </span><br><span class="line">beforeprint 该事件在页面即将开始打印时触发</span><br></pre></td></tr></table></figure>
<h2 id="拖动事件"><a href="#拖动事件" class="headerlink" title="拖动事件"></a>拖动事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drag 该事件在元素正在拖动时触发 </span><br><span class="line">dragend 该事件在用户完成元素的拖动时触发 </span><br><span class="line">dragenter 该事件在拖动的元素进入放置目标时触发 </span><br><span class="line">dragleave 该事件在拖动元素离开放置目标时触发 </span><br><span class="line">dragover 该事件在拖动元素在放置目标上时触发 </span><br><span class="line">dragstart 该事件在用户开始拖动元素时触发 </span><br><span class="line">drop 该事件在拖动元素放置在目标区域时触发</span><br></pre></td></tr></table></figure>
<h2 id="多媒体（Media）事件"><a href="#多媒体（Media）事件" class="headerlink" title="多媒体（Media）事件"></a>多媒体（Media）事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abort 事件在视频&#x2F;音频（audio&#x2F;video）终止加载时触发。 </span><br><span class="line">canplay 事件在用户可以开始播放视频&#x2F;音频（audio&#x2F;video）时触发。 </span><br><span class="line">canplaythrough 事件在视频&#x2F;音频（audio&#x2F;video）可以正常播放且无需停顿和缓冲时触发。 </span><br><span class="line">durationchange 事件在视频&#x2F;音频（audio&#x2F;video）的时长发生变化时触发。 </span><br><span class="line">emptied The event occurs when the current playlist is empty </span><br><span class="line">ended 事件在视频&#x2F;音频（audio&#x2F;video）播放结束时触发。 </span><br><span class="line">error 事件在视频&#x2F;音频（audio&#x2F;video）数据加载期间发生错误时触发。 </span><br><span class="line">loadeddata 事件在浏览器加载视频&#x2F;音频（audio&#x2F;video）当前帧时触发触发。 </span><br><span class="line">loadedmetadata 事件在指定视频&#x2F;音频（audio&#x2F;video）的元数据加载后触发。 </span><br><span class="line">loadstart 事件在浏览器开始寻找指定视频&#x2F;音频（audio&#x2F;video）触发。 </span><br><span class="line">pause 事件在视频&#x2F;音频（audio&#x2F;video）暂停时触发。 </span><br><span class="line">play 事件在视频&#x2F;音频（audio&#x2F;video）开始播放时触发。 </span><br><span class="line">playing 事件在视频&#x2F;音频（audio&#x2F;video）暂停或者在缓冲后准备重新开始播放时触发。 </span><br><span class="line">progress 事件在浏览器下载指定的视频&#x2F;音频（audio&#x2F;video）时触发。 </span><br><span class="line">ratechange 事件在视频&#x2F;音频（audio&#x2F;video）的播放速度发送改变时触发。 </span><br><span class="line">seeked 事件在用户重新定位视频&#x2F;音频（audio&#x2F;video）的播放位置后触发。 </span><br><span class="line">seeking 事件在用户开始重新定位视频&#x2F;音频（audio&#x2F;video）时触发。 </span><br><span class="line">stalled 事件在浏览器获取媒体数据，但媒体数据不可用时触发。 </span><br><span class="line">suspend 事件在浏览器读取媒体数据中止时触发。 </span><br><span class="line">timeupdate 事件在当前的播放位置发送改变时触发。 </span><br><span class="line">volumechange 事件在音量发生改变时触发。 </span><br><span class="line">waiting 事件在视频由于要播放下一帧而需要缓冲时触发。</span><br></pre></td></tr></table></figure>

<h2 id="动画事件"><a href="#动画事件" class="headerlink" title="动画事件"></a>动画事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">animationend 该事件在 CSS 动画结束播放时触发 </span><br><span class="line">animationiteration 该事件在 CSS 动画重复播放时触发 </span><br><span class="line">animationstart 该事件在 CSS 动画开始播放时触发</span><br></pre></td></tr></table></figure>
<h2 id="过渡事件"><a href="#过渡事件" class="headerlink" title="过渡事件"></a>过渡事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transitionend 该事件在 CSS 完成过渡后触发。</span><br></pre></td></tr></table></figure>

<h2 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">message 该事件通过或者从对象(WebSocket, Web Worker, Event Source 或者子 frame 或父窗口)接收到消息时触发 </span><br><span class="line">online 该事件在浏览器开始在线工作时触发。 </span><br><span class="line">offline 该事件在浏览器开始离线工作时触发。 </span><br><span class="line">popstate 该事件在窗口的浏览历史（history 对象）发生改变时触发。 </span><br><span class="line">show 该事件当元素在上下文菜单显示时触发 </span><br><span class="line">storage 该事件在 Web Storage(HTML 5 Web 存储)更新时触发 </span><br><span class="line">toggle 该事件在用户打开或关闭 元素时触发 </span><br><span class="line">wheel 该事件在鼠标滚轮在元素上下滚动时触发</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>html转图片小技巧</title>
    <url>/2017/02/14/html%E8%BD%AC%E5%9B%BE%E7%89%87%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> wth = <span class="number">500</span>,</span><br><span class="line">	hgt = <span class="number">360</span>;</span><br><span class="line">canvas.width = wth;</span><br><span class="line">canvas.height = hgt;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(canvas);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">"&lt;svg xmlns='http://www.w3.org/2000/svg' width='200' height='200'&gt;"</span> +</span><br><span class="line">             <span class="string">"&lt;foreignObject width='100%' height='100%'&gt;"</span> +</span><br><span class="line">               <span class="string">"&lt;div xmlns='http://www.w3.org/1999/xhtml' style='font-size:40px'&gt;"</span> +</span><br><span class="line">                  <span class="string">"&lt;em&gt;I&lt;/em&gt; like &lt;span style='color:white; text-shadow:0 0 2px blue;'&gt;cheese&lt;/span&gt;"</span> +</span><br><span class="line">               <span class="string">"&lt;/div&gt;"</span> +</span><br><span class="line">             <span class="string">"&lt;/foreignObject&gt;"</span> +</span><br><span class="line">           <span class="string">"&lt;/svg&gt;"</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">'#ddd'</span>;</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, wth, hgt);</span><br><span class="line"><span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line"><span class="keyword">var</span> svg = <span class="keyword">new</span> Blob([data], &#123;<span class="attr">type</span>: <span class="string">"image/svg+xml;charset=utf-8"</span>&#125;);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">window</span>.URL.createObjectURL(svg);</span><br><span class="line">img.crossOrigin = <span class="string">'anonymous'</span>;</span><br><span class="line">img.src = url;</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.URL.revokeObjectURL(url);</span><br><span class="line">    ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">window</span>.open(canvas.toDataURL(<span class="string">'image/jpeg'</span>, <span class="number">0.75</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心代码是while循环部分，实际上就是一个递归调用，你也可以写成一个函数，用递归的方法来调用，同时用到冒泡的原理，从里往外冒泡，知道currentTarget为止，当当前的target是li的时候，就可以执行对应的事件了，然后终止循环</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>知识点</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>js导出Excel表格的方法</title>
    <url>/2019/03/02/js%E5%AF%BC%E5%87%BAExcel%E8%A1%A8%E6%A0%BC%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>js导出Excel的方法</p>
<ul>
<li>利用html的table表格的格式书写想要的excel格式</li>
<li>获取table的内容并组装成一个xls格式的字符串</li>
<li>利用Blob对象生成一个xls格式的文件</li>
<li>利用a标签的download属性创建文件名，并下载到本地</li>
</ul>
<a id="more"></a>

<p><strong>table表格内容</strong></p>
<p>先写一个正常的html表格</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">DOCTYPE</span> <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;html lang="en"&gt;</span><br><span class="line">&lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">  &lt;meta charset="UTF-8"&gt;</span><br><span class="line">  &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;</span><br><span class="line">  &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;</span><br><span class="line">  &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">  &lt;style media="screen"&gt;</span><br><span class="line">    <span class="selector-class">.tableA</span> &#123;</span><br><span class="line">      <span class="attribute">border-collapse</span>: collapse;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.tableA</span> <span class="selector-class">.title</span> <span class="selector-tag">th</span>&#123;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">      <span class="attribute">font-family</span>: <span class="string">'微软雅黑'</span>;</span><br><span class="line">      <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.tableA</span> <span class="selector-tag">tr</span> <span class="selector-tag">th</span> &#123;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#000</span> solid;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">      <span class="attribute">background</span>: <span class="number">#efefef</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.tableA</span> <span class="selector-tag">tr</span> <span class="selector-tag">td</span> &#123;</span><br><span class="line">      <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">40px</span>;</span><br><span class="line">      <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#000</span> solid;</span><br><span class="line">      <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">      <span class="attribute">text-align</span>: center;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.tableA</span> <span class="selector-class">.footer</span> <span class="selector-tag">td</span> &#123;</span><br><span class="line">      <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">      <span class="attribute">font-weight</span>: <span class="number">700</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">  &lt;table bordercolor="black" class="tableA"&gt;</span><br><span class="line">    &lt;tr class="title"&gt;</span><br><span class="line">      &lt;th colspan="4"&gt;学生信息&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;<span class="selector-tag">tr</span>&gt;</span><br><span class="line">      &lt;th&gt;名字&lt;/th&gt;</span><br><span class="line">      &lt;th&gt;性别&lt;/th&gt;</span><br><span class="line">      &lt;th&gt;年龄&lt;/th&gt;</span><br><span class="line">      &lt;th&gt;班级&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;<span class="selector-tag">tr</span>&gt;</span><br><span class="line">      &lt;td&gt;小明&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;男&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;19&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;1班&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;<span class="selector-tag">tr</span>&gt;</span><br><span class="line">      &lt;td&gt;小黄&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;男&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;20&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;2班&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;<span class="selector-tag">tr</span>&gt;</span><br><span class="line">      &lt;td&gt;老王&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;男&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;29&lt;/td&gt;</span><br><span class="line">      &lt;td&gt;3班&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;tr class="footer"&gt;</span><br><span class="line">      &lt;td colspan="4"&gt;总人数：3人&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">  &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><strong>获取table的内容装成一个xls格式的字符串</strong><br>接下来就是获取table的html内容了，里面包括标签的class或id等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oHtml = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'tableA'</span>)[<span class="number">0</span>].outerHTML;</span><br></pre></td></tr></table></figure>

<p>将table和style组成一个html，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> excelHtml = <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;html&gt;</span></span><br><span class="line"><span class="string">      &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;meta charset='utf-8' /&gt;</span></span><br><span class="line"><span class="string">        &lt;style&gt;</span></span><br><span class="line"><span class="string">          .tableA &#123;</span></span><br><span class="line"><span class="string">            border-collapse: collapse;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">          .tableA .title th&#123;</span></span><br><span class="line"><span class="string">            height: 50px;</span></span><br><span class="line"><span class="string">            font-size: 24px;</span></span><br><span class="line"><span class="string">            font-family: '微软雅黑';</span></span><br><span class="line"><span class="string">            font-weight: 700;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">          .tableA tr th &#123;</span></span><br><span class="line"><span class="string">            border: 1px #000 solid;</span></span><br><span class="line"><span class="string">            height: 40px;</span></span><br><span class="line"><span class="string">            background: #efefef;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">          .tableA tr td &#123;</span></span><br><span class="line"><span class="string">            padding: 0 40px;</span></span><br><span class="line"><span class="string">            border: 1px #000 solid;</span></span><br><span class="line"><span class="string">            height: 40px;</span></span><br><span class="line"><span class="string">			text-align: center;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">          .tableA .footer td &#123;</span></span><br><span class="line"><span class="string">            font-size: 20px;</span></span><br><span class="line"><span class="string">            font-weight: 700;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &lt;/style&gt;</span></span><br><span class="line"><span class="string">      &lt;/head&gt;</span></span><br><span class="line"><span class="string">      &lt;body&gt;</span></span><br><span class="line"><span class="string">        <span class="subst">$&#123;oHtml&#125;</span></span></span><br><span class="line"><span class="string">      &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br></pre></td></tr></table></figure>

<p><strong>生成xls文件并通过a标签下载到本地</strong><br>前面的准备工作就差不多了，接下来就是将字符串转成xls文件了，这里主要利用Blob对象和<code>URL.createObjectURL()</code> 方法</p>
<ul>
<li><p>Blob对象表示不可变的类似文件对象的原始数据。Blob表示不一定是JavaScript原生形式的数据。 File 接口基于Blob，继承了 blob的功能并将其扩展使其支持用户系统上的文件。</p>
</li>
<li><p>URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的URL 对象表示指定的 File 对象或 Blob 对象。</p>
</li>
</ul>
<p>Blob 构造函数用法举例（生成一个json文件）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> debug = &#123;<span class="attr">hello</span>: <span class="string">"world"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> blob = <span class="keyword">new</span> Blob([<span class="built_in">JSON</span>.stringify(debug, <span class="literal">null</span>, <span class="number">2</span>)],&#123;<span class="attr">type</span> : <span class="string">'application/json'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>同样道理利用第二个步骤的字符串生成Excel</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> excelBlob = <span class="keyword">new</span> Blob([excelHtml], &#123;<span class="attr">type</span>: <span class="string">'application/vnd.ms-excel'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>最后一步就是通过a标签下载到本地了，下载前可以利用a标签的download属性命名</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个a标签</span></span><br><span class="line"><span class="keyword">var</span> oA = <span class="built_in">document</span>.createElement(<span class="string">'a'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用URL.createObjectURL()方法为a元素生成blob URL</span></span><br><span class="line">oA.href = URL.createObjectURL(excelBlob);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给文件命名</span></span><br><span class="line">oA.download = <span class="string">'学生名单.xls'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟点击</span></span><br><span class="line">oA.click();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ps:因为权限问题，生成的excel的格式只能为.xls而且每次打开都会弹窗询问。所以建议打开后另存一份excel</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>前端</tag>
        <tag>下载</tag>
      </tags>
  </entry>
  <entry>
    <title>js的面向对象详解</title>
    <url>/2020/03/29/js%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="对象的创建："><a href="#对象的创建：" class="headerlink" title="对象的创建："></a>对象的创建：</h2><ul>
<li>创建一个面向对象<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line">obj.name = <span class="string">'haha'</span>;</span><br><span class="line">obj.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  alert(obj.name);</span><br><span class="line">&#125;</span><br><span class="line">obj.showName();</span><br></pre></td></tr></table></figure>
缺点：当我们想创建多个面向对象的时候，重复代码过多，需要封装，所以有了工厂方法。</li>
</ul>
<a id="more"></a>

<ul>
<li><p>工厂方式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">   <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();   <span class="comment">//原料</span></span><br><span class="line">   obj.name = name;         <span class="comment">//加工</span></span><br><span class="line">   obj.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     alert(<span class="keyword">this</span>.name);</span><br><span class="line"> &#125; </span><br><span class="line">   <span class="keyword">return</span> obj;<span class="comment">//出厂</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = CreatePerson(<span class="string">'haha'</span>);</span><br><span class="line">p1.showName();</span><br><span class="line"><span class="keyword">var</span> p2 = CreatePerson(<span class="string">'hehe'</span>);</span><br><span class="line">p2.showName();</span><br><span class="line"><span class="comment">//其实就是简单的封装函数，整个过程像工厂的流水线，所以叫工厂方式</span></span><br></pre></td></tr></table></figure>
<p>缺点：无法识别创建的对象的类型。因为全部都是Object，没有区分度，不像Date、Array等，因此出现了构造函数模式。</p>
</li>
<li><p>构造函数模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">   <span class="keyword">this</span>.name = name; </span><br><span class="line">   <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">     alert(<span class="keyword">this</span>.name);</span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> p1 =<span class="keyword">new</span> CreatePerson(<span class="string">'haha'</span>); </span><br><span class="line">p1.showName();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> CreatePerson(<span class="string">'hehe'</span>); </span><br><span class="line">p2.showName();</span><br></pre></td></tr></table></figure>
<p>我们通过这二个方面来改变：</p>
</li>
<li><p>1 函数名首字母大写<br>这是为了区别于普通的函数，构造函数本身其实就是普通的函数，只是我们专门用它来实现了构造的功能，所以专门起了一个名字叫构造函数，任何函数都可以成为构造函数，这取决于你调用函数的方式，当使用了New的方式调用就成了构造函数。</p>
</li>
<li><p>2 New 关键字调用<br>调用函数的时候用了 New关键字，那么New到底做了什么？用不用New有什么区别？再来看下面的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.name = name;</span><br><span class="line">   <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     alert(<span class="keyword">this</span>.name); </span><br><span class="line">   &#125;; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">new</span> CreatePerson(<span class="string">'haha'</span>); <span class="comment">//CreatePerson 指向了当前构造函数</span></span><br><span class="line">CreatePerson(<span class="string">'haha'</span>);  <span class="comment">//window 指向了window</span></span><br></pre></td></tr></table></figure>
<p>我们会发现当用New去调用一个函数的时候，this的指向会不一样。其实New主要做了下面这些事，不过下面写的只是大概的行为，并不是内部源码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">   <span class="keyword">var</span> obj = &#123;&#125;; <span class="comment">//声明一个空对象obj </span></span><br><span class="line">   obj._proto_= CreatePerson.prototype;</span><br><span class="line">   <span class="comment">//把这个对象的_proto_属性指向构造函数的原型对象,这样obj就可以调用CreatePerson原型对象下的所有方法 ，这里原型先知道结论，下面会讲。</span></span><br><span class="line">    CreatePerson.apply(obj);   <span class="comment">//用apply方法让this指向obj对象</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;   <span class="comment">//obj对象添加属性，方法</span></span><br><span class="line">    <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">       alert(<span class="keyword">this</span>.name);</span><br><span class="line">      &#125;; </span><br><span class="line">    <span class="keyword">return</span> obj;<span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>函数构造模式存在的问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(p1.showName==p2.showName);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>缺点：可见这两个对象并不是共用一个方法，每new一次，系统都会新创建一个内存，这两个对象各自有各自的地盘，但他们具有相同的功能，还不共用，肯定不是我们所希望的。所以就有了下一种方法，原型+构造模式</p>
<ul>
<li>原型+构造模式<br>原型：每个函数都有一个prototype属性，它是一个对象，也称作原型对象，我们可以把方法和属性写在它上面（不过原型对象不仅仅有我们写的属性和方法，还有别的，下面会介绍），而通过这个函数创建出来的实例对象，都能共享这个原型对象下的方法和属性。所以我们只需要把想要共享的东西放在函数的prototype下，不想共享的东西通过构造函数来创建就可以了。<br>看个栗子（原型+构造）<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePerson</span>(<span class="params">name</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">CreatePerson.prototype.showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">   alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 =<span class="keyword">new</span> CreatePerson(<span class="string">'haha'</span>);</span><br><span class="line">p1.showName();</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> CreatePerson(<span class="string">'hehe'</span>);</span><br><span class="line">p2.showName();</span><br><span class="line">alert(p1.showName==p2.showName);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
测试为true，可见showName()方法是共享的，也就是说他们共用一个内存，更进一步的说它们存在引用关系，也就是说你更改了p1的showName也会影响p2的showName。</li>
</ul>
<p>_proto_属性:<br>同一个函数造出来的实例对象能共享这个函数的prototype下的方法和属性，但是它是如何做到的呢？这里要出场的就是_proto_属性.<br>每个实例化对象都有_proto_属性，它是一个指针，指向函数的prototype，也就是保存了它的地址。（JS中任何对象的值都是保存在堆内存中，我们声明的变量只是一个指针，保存了这个对象的实际地址，所以有了地址就能找到对象），<br>所以总得来说，每个实例化对象都有_proto_属性，保存了构造函数的原型对象的地址，通过这个属性就可以拥有原型对象下的所有属性和方法，_proto_属性实际就是实例化对象和原型对象之间的连接</p>
<p>原型链：<br>每个函数都可以成为构造函数，每个函数都有原型对象，每个原型对象也可以是一个实例化对象，比如，你创建了一个函数fun,它是构造函数function的实例化对象，而function的原型对象，又是Object的实例对象。所以fun有个_proto_属性可以访问到function的原型对象,function原型对象也是个实例对象，也有个_proto_属性,可以访问到Object的原型对象，所以通过_proto_属性，就形成了一条原型链。每个实例化对象都可以访问到链子上方的方法和属性，所以fun是可以访问Object原型对象下的方法和属性的。实际上所有对象都可以访问到Object的原型对象。</p>
<p>原型链的访问规则：先在自身的下面寻找，再去一级一级的往原型链上找。<br>如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Aaa</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Aaa.prototype.num = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> a1 = <span class="keyword">new</span> Aaa();</span><br><span class="line">a1.num =<span class="number">10</span>;</span><br><span class="line">alert(a1.num); <span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>![image_1clisr95k1r2a857e9ii3oqc9.png-15.3kB][1]<br>[1]: <a href="http://static.zybuluo.com/wp0214/l00axuifrvo7bvpqfeiz8pfa/image_1clisr95k1r2a857e9ii3oqc9.png" target="_blank" rel="noopener">http://static.zybuluo.com/wp0214/l00axuifrvo7bvpqfeiz8pfa/image_1clisr95k1r2a857e9ii3oqc9.png</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>知识点</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>js的闭包详解</title>
    <url>/2020/03/29/js%E7%9A%84%E9%97%AD%E5%8C%85%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="js变量作用域"><a href="#js变量作用域" class="headerlink" title="js变量作用域"></a>js变量作用域</h2><p>js的变量作用域有两种，全局变量和局部变量</p>
<p>需要注意的是，函数内部可以直接读取全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="number">666</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(global);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(); <span class="comment">//666</span></span><br></pre></td></tr></table></figure>
<p>函数外部无法读取到函数内部的局部变量，因为函数在执行完之后，函数内部的环境就被销毁了。</p>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="number">888</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(message); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>
<p>如果函数内部没有使用var，那么实际上就相当于把这个变量声明为全局变量了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	message = <span class="number">999</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func();	<span class="comment">//这里注意要运行一遍函数，`message`	才有定义</span></span><br><span class="line"></span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>
<h2 id="如何从外部读取到局部变量？"><a href="#如何从外部读取到局部变量？" class="headerlink" title="如何从外部读取到局部变量？"></a>如何从外部读取到局部变量？</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> message = <span class="number">999</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(message); <span class="comment">//999</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中，f2可以访问到f1的局部变量message，那么我们只要把f2作为f1的返回值return出去，那么就可以在外部访问到message了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">var</span> message = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(message); <span class="comment">//999</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> f2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单理解闭包"><a href="#简单理解闭包" class="headerlink" title="简单理解闭包"></a>简单理解闭包</h2><p>上面的f2函数就是闭包。</p>
<p>闭包就是能够读取其他函数内部变量的函数，所以，闭包实际上是一个函数。<br>闭包可以理解为“定义在一个函数内部的函数”，本质上，闭包是将函数内部和外部连接起来的一座桥梁。<br>这里要注意一点，父函数内部定义的子函数，如果没有引用父函数作用域中的变量，那么这个子函数不是闭包，这点非常重要，也就是说，闭包是由函数和它所在的环境构成的，缺一不可</p>
<h2 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h2><ul>
<li>读取函数内部的变量</li>
<li>让变量始终保存在内存中<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> n = <span class="number">999</span>;</span><br><span class="line">	nAdd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; n += <span class="number">1</span> &#125;; <span class="comment">//nAdd是一个全局函数</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		alert(n);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = f1(); <span class="comment">//result是一个函数，f1中return的字函数</span></span><br><span class="line">result();<span class="comment">//999</span></span><br><span class="line">nAdd();<span class="comment">//执行全局函数</span></span><br><span class="line">result();<span class="comment">//1000</span></span><br></pre></td></tr></table></figure></li>
<li>闭包的应用比较典型是定义模块，我们将操作函数暴露给外部，而细节隐藏在模块内部：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">module</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> arr = [];</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">typeof</span> val == <span class="string">'number'</span>) &#123;</span><br><span class="line">			arr.push(val);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (index &lt; arr.length) &#123;</span><br><span class="line">			<span class="keyword">return</span> arr[index]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		add: add,</span><br><span class="line">		<span class="keyword">get</span>: <span class="keyword">get</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var mod1 = module();</span><br><span class="line">mod1.add(1);</span><br><span class="line">mod1.add(2);</span><br><span class="line">mod1.add('xxx');</span><br><span class="line">console.log(mod1.<span class="keyword">get</span>(2));</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h2 id="使用闭包的注意事项"><a href="#使用闭包的注意事项" class="headerlink" title="使用闭包的注意事项"></a>使用闭包的注意事项</h2><p>闭包会让函数中的变量都被保存在内存中，内存消耗大，所以不能滥用闭包，可以在不使用该变量的时候将其delete。<br>闭包会在父函数外部改变父函数内部的值，如果把父函数当作object使用，把闭包当作公有方法，内部变量当作私有成员，那就要小心不要随意改变父函数内部变量的值。</p>
<h2 id="经典闭包例子"><a href="#经典闭包例子" class="headerlink" title="经典闭包例子"></a>经典闭包例子</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li&gt;<span class="number">1</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;2&lt;/</span>li&gt;</span><br><span class="line">  &lt;li&gt;<span class="number">3</span>&lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li&gt;4&lt;/</span>li&gt;</span><br><span class="line">&lt;<span class="regexp">/ul&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line"> lis[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本意是想每次点击，输入对应序号，但结果是每次输入都为3</span></span><br></pre></td></tr></table></figure>

<p>———————————–分割线———————————–分割线————————–</p>
<p>首先我们来了解几个概念：</p>
<p>立即执行函数：形如 （function(){}）();的一类函数；</p>
<p>闭包：闭包是指有权访问另一函数作用域中的变量的函数。</p>
<p>作用域链：当代码执行的时候，会创建变量对象的一个作用域链….（具体百度）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">	lis[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，代码中的匿名函数没有变量 i，所以它必须向上查找，在全局环境中找到了 i。</p>
<p>当for循环运行后，全局变量中的 i 变成了3。此时当你点击文字的时候，会调用其绑定的函数，而该函数运行的时候，发现自己没有 i，就会取得全局环境中的 i。</p>
<p>所以，最后的结果是，不管你点击那段文字，最后结果都是3。</p>
<p><strong>那怎么办呢？你可以用立即执行函数，看代码：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">	lis[i].onclick = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="built_in">console</span>.log(s)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把参数 i 作为传给立即执行函数，这样，i 的值就传给了立即执行函数的局部变量 i 了。立即执行函数会直接执行，但是其活动不会销毁，因为里面有个匿名函数。执行后局部变量 i 与全局变量 i 联系就切断了，也就是执行的时候，传进去的变量 i 是多少，立即执行函数的局部变量 i  就是多少，并且该局部变量 i 仍然没有消失，因为匿名函数的存在。</p>
<p>这时候，return中的匿名函数的作用域链中会有两个变量 i。当点击文本的时候，它向上搜索 i 的时候，它找到立即执行函数的局部变量 i ，就停止向上查找了，因此最后的结果就不会是全局变量 i 的值3了。</p>
<p> 有一个方法可以检验你们有没有真的理解上面所说的，看上面的变体，代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">　<span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;dom.length;i++)&#123;</span><br><span class="line">    dom[i].onclick=<span class="function"><span class="keyword">function</span>(<span class="params">t</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"> </span>)</span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log(t);<span class="comment">//1</span></span><br><span class="line">        <span class="built_in">console</span>.log(i);<span class="comment">//3</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实return中的匿名函数中的 t 就是立即执行函数的局部变量 i，而 i 就是 指全局变量 i，因为立即执行函数中没有变量i，只能继续向上搜索，然后就找到全局变量的 i 了。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>知识点</tag>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs之fs模块</title>
    <url>/2020/04/02/nodejs%E4%B9%8Bfs%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p><strong>fs文件系统用于对系统文件及目录进行读写操作</strong></p>
</blockquote>
<h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><h4 id="普通读取"><a href="#普通读取" class="headerlink" title="普通读取"></a>普通读取</h4><p>同步读取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    data = fs.readFileSync(<span class="string">'./fileForRead.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件内容: '</span> + data);</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'读取文件出错: '</span> + err.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>输出如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/node readFileSync.js</span><br><span class="line">文件内容: hello world</span><br></pre></td></tr></table></figure>

<p>异步读取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./fileForRead.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.error(<span class="string">'读取文件出错: '</span> + err.message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件内容: '</span> + data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/node readFile.js</span><br><span class="line">文件内容: hello world</span><br></pre></td></tr></table></figure>

<h4 id="通过文件流读取"><a href="#通过文件流读取" class="headerlink" title="通过文件流读取"></a>通过文件流读取</h4><p>适合读取大文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./fileForRead.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">readStream</span><br><span class="line">    .on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'读取数据: '</span> + chunk);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'出错: '</span> + err.message);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 没有数据了</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'没有数据了'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 已经关闭，不会再有事件抛出</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'已经关闭'</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/node createReadStream.js</span><br><span class="line">读取数据: hello world</span><br><span class="line">没有数据了</span><br><span class="line">已经关闭</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">### 文件写入</span></span><br><span class="line"></span><br><span class="line">备注：以下代码，如果文件不存在，则创建文件；如果文件存在，则覆盖文件内容；</span><br><span class="line"></span><br><span class="line">异步写入</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var fs = require(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">'./fileForWrite.txt'</span>, <span class="string">'hello world'</span>, <span class="string">'utf8'</span>, function(err)&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    console.log(<span class="string">'文件写入成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同步写入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fs.writeFileSync(<span class="string">'./fileForWrite1.txt'</span>, <span class="string">'hello world'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件写入成功'</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过文件流写入"><a href="#通过文件流写入" class="headerlink" title="通过文件流写入"></a>通过文件流写入</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(<span class="string">'./fileForWrite1.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">writeStream</span><br><span class="line">    .on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 已经关闭，不会再有事件抛出</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'已经关闭'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">writeStream.write(<span class="string">'hello'</span>);</span><br><span class="line">writeStream.write(<span class="string">'world'</span>);</span><br><span class="line">writeStream.end(<span class="string">''</span>);</span><br></pre></td></tr></table></figure>

<h4 id="相对底层的接口"><a href="#相对底层的接口" class="headerlink" title="相对底层的接口"></a>相对底层的接口</h4><blockquote>
<p>fs.write(fd, buffer, offset, length[, position], callback)<br>fs.write(fd, data[, position[, encoding]], callback)<br>fs.writeSync(fd, buffer, offset, length[, position])<br>fs.writeSync(fd, data[, position[, encoding]])</p>
</blockquote>
<ul>
<li>fd：写入的文件句柄。</li>
<li>buffer：写入的内容。</li>
<li>offset：将buffer从offset位置开始，长度为length的内容写入。</li>
<li>length：写入的buffer内容的长度。</li>
<li>position：从打开文件的position处写入。</li>
<li>callback：参数为 <code>(err, written, buffer)</code>。<code>written</code>表示有xx字节的buffer被写入。</li>
</ul>
<p>备注：<code>fs.write(fd, buffer, offset, length[, position], callback)</code>跟<code>fs.write(fd, data[, position[, encoding]], callback)</code>的区别在于：后面的只能把所有的data写入，而前面的可以写入指定的data子串？</p>
<h3 id="文件是否存在"><a href="#文件是否存在" class="headerlink" title="文件是否存在"></a>文件是否存在</h3><p><code>fs.exists()</code>已经是<code>deprecated</code>状态，现在可以通过下面代码判断文件是否存在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.access(<span class="string">'./fileForRead.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fileForRead.txt存在'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.access(<span class="string">'./fileForRead2.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fileForRead2.txt存在'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>fs.access()</code>除了判断文件是否存在（默认模式），还可以用来判断文件的权限。</p>
<p>备忘：<code>fs.constants.F_OK</code>等常量无法获取（node v6.1，mac 10.11.4下，<code>fs.constants</code>是<code>undefined</code>）</p>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>异步版本（如果目录已存在，会报错）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.mkdir(<span class="string">'./hello'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'目录创建成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同步版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.mkdirSync(<span class="string">'./hello'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.unlink(<span class="string">'./fileForUnlink.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件删除成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.unlinkSync(<span class="string">'./fileForUnlink.txt'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="创建目录-1"><a href="#创建目录-1" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.mkdir(path[, mode], callback)</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.mkdir(<span class="string">'sub'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建目录成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.mkdirSync(path[, mode])</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fs.mkdirSync(<span class="string">'hello'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建目录成功'</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><p>同步版本，注意：<code>fs.readdirSync()</code>只会读一层，所以需要判断文件类型是否目录，如果是，则进行递归遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.readdirSync(path[, options])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getFilesInDir = <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> results = [ path.resolve(dir) ];</span><br><span class="line">    <span class="keyword">var</span> files = fs.readdirSync(dir, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">    files.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        file = path.resolve(dir, file);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> stats = fs.statSync(file);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stats.isFile())&#123;</span><br><span class="line">            results.push(file);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stats.isDirectory())&#123;</span><br><span class="line">            results = results.concat( getFilesInDir(file) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> files = getFilesInDir(<span class="string">'../'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(files);</span><br></pre></td></tr></table></figure>

<p>异步版本：（TODO）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.rename(oldPath, newPath, callback)</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.rename(<span class="string">'./hello'</span>, <span class="string">'./world'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'重命名成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.renameSync(oldPath, newPath)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.renameSync(<span class="string">'./world'</span>, <span class="string">'./hello'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>移动文件也是我们经常会遇见的，可是fs没有专门移动文件的函数，但是我们可以通过rename函数来达到移动文件的目的，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">fs.rename(oldPath,newPath,function (err) &#123;</span><br><span class="line">   if (err) throw err;</span><br><span class="line">   console.log(&#39;renamed complete&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="监听文件修改"><a href="#监听文件修改" class="headerlink" title="监听文件修改"></a>监听文件修改</h3><p><code>fs.watch()</code>比<code>fs.watchFile()</code>高效很多（why）</p>
<h4 id="fs-watchFile"><a href="#fs-watchFile" class="headerlink" title="fs.watchFile()"></a>fs.watchFile()</h4><p>实现原理：轮询。每隔一段时间检查文件是否发生变化。所以在不同平台上表现基本是一致的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    persistent: <span class="literal">true</span>,  <span class="comment">// 默认就是true</span></span><br><span class="line">    interval: <span class="number">2000</span>  <span class="comment">// 多久检查一次</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// curr, prev 是被监听文件的状态, fs.Stat实例</span></span><br><span class="line"><span class="comment">// 可以通过 fs.unwatch() 移除监听</span></span><br><span class="line">fs.watchFile(<span class="string">'./fileForWatch.txt'</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">curr, prev</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'修改时间为: '</span> + curr.mtime);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>修改<code>fileForWatch.txt</code>，可以看到控制台下打印出日志</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/node watchFile.js</span><br><span class="line">修改时间为: Sat Jul <span class="number">16</span> <span class="number">2016</span> <span class="number">19</span>:<span class="number">03</span>:<span class="number">57</span> GMT+<span class="number">0800</span> (CST)</span><br><span class="line">修改时间为: Sat Jul <span class="number">16</span> <span class="number">2016</span> <span class="number">19</span>:<span class="number">04</span>:<span class="number">05</span> GMT+<span class="number">0800</span> (CST)</span><br></pre></td></tr></table></figure>

<p>为啥子？莫非单纯访问文件也会触发回调？</p>
<blockquote>
<p>If you want to be notified when the file was modified, not just accessed, you need to compare curr.mtime and prev.mtime.</p>
</blockquote>
<p>在 <strong>v0.10</strong> 之后的改动。如果监听的文件不存在，会怎么处理。如下</p>
<blockquote>
<p>Note: when an fs.watchFile operation results in an ENOENT error, it will invoke the listener once, with all the fields zeroed (or, for dates, the Unix Epoch). In Windows, blksize and blocks fields will be undefined, instead of zero. If the file is created later on, the listener will be called again, with the latest stat objects. This is a change in functionality since v0.10.</p>
</blockquote>
<h4 id="fs-watch"><a href="#fs-watch" class="headerlink" title="fs.watch()"></a>fs.watch()</h4><blockquote>
<p>fs.watch(filename[, options][, listener])<br>fs.unwatchFile(filename[, listener])</p>
</blockquote>
<p>这接口非常不靠谱（当前测试用的v6.1.0），参考 <a href="https://github.com/nodejs/node/issues/7420" target="_blank" rel="noopener">https://github.com/nodejs/node/issues/7420</a></p>
<blockquote>
<p>fs.watch(filename[, options][, listener])#</p>
</blockquote>
<p>注意：<code>fs.watch()</code>这个接口并不是在所有的平台行为都一致，并且在某些情况下是不可用的。<code>recursive</code>这个选项只在<code>mac</code>、<code>windows</code>下可用。</p>
<p>问题来了：</p>
<ol>
<li>不一致的表现。</li>
<li>不可用的场景。</li>
<li>linux上要recursive咋整。</li>
</ol>
<blockquote>
<p>The fs.watch API is not 100% consistent across platforms, and is unavailable in some situations.<br>The recursive option is only supported on OS X and Windows.</p>
</blockquote>
<p>备忘，不可用的场景。比如网络文件系统等。</p>
<blockquote>
<p>For example, watching files or directories can be unreliable, and in some cases impossible, on network file systems (NFS, SMB, etc), or host file systems when using virtualization software such as Vagrant, Docker, etc.</p>
</blockquote>
<p>另外，listener回调有两个参数，分别是<code>event</code>、<code>filename</code>。其中，<code>filename</code>仅在linux、windows上会提供，并且不是100%提供，所以，尽量不要依赖<code>filename</code>。</p>
<p>在linux、osx上，<code>fs.watch()</code>监听的是inode。如果文件被删除，并重新创建，那么删除事件会触发。同时，<code>fs.watch()</code>监听的还是最初的inode。（API的设计就是这样的）</p>
<p>结论：怎么看都感觉这个API很不靠谱，虽然性能比fs.watchFile()要高很多。</p>
<p>先来个例子，在osx下测试了一下，简直令人绝望。。。无论是创建、修改、删除文件，<code>evt</code>都是<code>rename</code>。。。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    persistent: <span class="literal">true</span>,</span><br><span class="line">    recursive: <span class="literal">true</span>,</span><br><span class="line">    encoding: <span class="string">'utf8'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fs.watch(<span class="string">'../'</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">event, filename</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'触发事件:'</span> + event);</span><br><span class="line">    <span class="keyword">if</span>(filename)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'文件名是: '</span> + filename);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'文件名是没有提供'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>修改下<code>fileForWatch.txt</code>，看到下面输出。。。感觉打死也不想用这个API。。。</p>
<p>贴下环境：osx 10.11.4, node v6.1.0。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">触发事件:rename</span><br><span class="line">文件名是: fs/fileForWatch.txt___jb_bak___</span><br><span class="line">触发事件:rename</span><br><span class="line">文件名是: fs/fileForWatch.txt</span><br><span class="line">触发事件:rename</span><br><span class="line">文件名是: fs/fileForWatch.txt___jb_old___</span><br><span class="line">触发事件:rename</span><br><span class="line">文件名是: .idea/workspace.xml___jb_bak___</span><br><span class="line">触发事件:rename</span><br><span class="line">文件名是: .idea/workspace.xml</span><br><span class="line">触发事件:rename</span><br><span class="line">文件名是: .idea/workspace.xml___jb_old___</span><br></pre></td></tr></table></figure>

<h3 id="修改所有者"><a href="#修改所有者" class="headerlink" title="修改所有者"></a>修改所有者</h3><p>参考linux命令行，不举例子了。。。</p>
<blockquote>
<p>fs.chown(path, uid, gid, callback)<br>fs.chownSync(path, uid, gid)<br>fs.fchown(fd, uid, gid, callback)<br>fs.fchownSync(fd, uid, gid)</p>
</blockquote>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>可以用<code>fs.chmod()</code>，也可以用<code>fs.fchmod()</code>。两者的区别在于，前面传的是文件路径，后面传的的文件句柄。</p>
<ol>
<li><code>fs.chmod)</code>、<code>fs.fchmod()</code>区别：传的是文件路径，还是文件句柄。</li>
<li><code>fs.chmod()</code>、<code>fs.lchmod()</code>区别：如果文件是软连接，那么<code>fs.chmod()</code>修改的是软连接指向的目标文件；<code>fs.lchmod()</code>修改的是软连接。</li>
</ol>
<blockquote>
<p>fs.chmod(path, mode, callback)<br>fs.chmodSync(path, mode)</p>
</blockquote>
<blockquote>
<p>fs.fchmod(fd, mode, callback)<br>fs.fchmodSync(fd, mode)</p>
</blockquote>
<blockquote>
<p>fs.lchmod(path, mode, callback)#<br>fs.lchmodSync(path, mode)</p>
</blockquote>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.chmod(<span class="string">'./fileForChown.txt'</span>, <span class="string">'777'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'权限修改成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同步版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">fs.chmodSync(&#39;.&#x2F;fileForChown.txt&#39;, &#39;777&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="获取文件状态"><a href="#获取文件状态" class="headerlink" title="获取文件状态"></a>获取文件状态</h3><p>区别：</p>
<ul>
<li><code>fs.stat()</code> vs <code>fs.fstat()</code>：传文件路径 vs 文件句柄。</li>
<li><code>fs.stat()</code> vs <code>fs.lstat()</code>：如果文件是软链接，那么<code>fs.stat()</code>返回目标文件的状态，<code>fs.lstat()</code>返回软链接本身的状态。</li>
</ul>
<blockquote>
<p>fs.stat(path, callback)<br>fs.statSync(path)</p>
</blockquote>
<blockquote>
<p>fs.fstat(fd, callback)<br>fs.fstatSync(fd)</p>
</blockquote>
<blockquote>
<p>fs.lstat(path, callback)<br>fs.lstatSync(path)</p>
</blockquote>
<p>主要关注<code>Class: fs.Stats</code>。</p>
<p>首先是方法</p>
<ul>
<li>stats.isFile()  – 是否文件</li>
<li>stats.isDirectory() – 是否目录</li>
<li>stats.isBlockDevice() – 什么鬼</li>
<li>stats.isCharacterDevice() – 什么鬼</li>
<li>stats.isSymbolicLink() (only valid with fs.lstat()) – 什么鬼</li>
<li>stats.isFIFO() – 什么鬼</li>
<li>stats.isSocket() – 是不是socket文件</li>
</ul>
<p>官网例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  dev: <span class="number">2114</span>,</span><br><span class="line">  ino: <span class="number">48064969</span>,</span><br><span class="line">  mode: <span class="number">33188</span>,</span><br><span class="line">  nlink: <span class="number">1</span>,</span><br><span class="line">  uid: <span class="number">85</span>,</span><br><span class="line">  gid: <span class="number">100</span>,</span><br><span class="line">  rdev: <span class="number">0</span>,</span><br><span class="line">  size: <span class="number">527</span>,</span><br><span class="line">  blksize: <span class="number">4096</span>,</span><br><span class="line">  blocks: <span class="number">8</span>,</span><br><span class="line">  atime: Mon, <span class="number">10</span> Oct <span class="number">2011</span> <span class="number">23</span>:<span class="number">24</span>:<span class="number">11</span> GMT, <span class="comment">// 访问时间</span></span><br><span class="line">  mtime: Mon, <span class="number">10</span> Oct <span class="number">2011</span> <span class="number">23</span>:<span class="number">24</span>:<span class="number">11</span> GMT,  <span class="comment">// 文件内容修改时间</span></span><br><span class="line">  ctime: Mon, <span class="number">10</span> Oct <span class="number">2011</span> <span class="number">23</span>:<span class="number">24</span>:<span class="number">11</span> GMT,  <span class="comment">// 文件状态修改时间</span></span><br><span class="line">  birthtime: Mon, <span class="number">10</span> Oct <span class="number">2011</span> <span class="number">23</span>:<span class="number">24</span>:<span class="number">11</span> GMT  <span class="comment">// 创建时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>atime：Access Time // 访问时间</li>
<li>mtime:: Modified Time  // 文件内容修改时间</li>
<li>ctime: Changed Time.  // 文件状态修改时间，比如修改文件所有者、修改权限、重命名等</li>
<li>birthtime: Birth Time // 创建时间。在某些系统上是不可靠的，因为拿不到。</li>
</ul>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getTimeDesc = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [d.getFullYear(), d.getMonth()+<span class="number">1</span>, d.getDate()].join(<span class="string">'-'</span>) + <span class="string">' '</span> + [d.getHours(), d.getMinutes(), d.getSeconds()].join(<span class="string">':'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fs.stat(<span class="string">'./fileForStat.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件大小: '</span> + stats.size);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建时间: '</span> + getTimeDesc(stats.birthtime));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'访问时间: '</span> + getTimeDesc(stats.atime));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'修改时间: '</span> + getTimeDesc(stats.mtime));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/node stat.js</span><br><span class="line">文件大小: <span class="number">3613</span></span><br><span class="line">创建时间: <span class="number">2016</span><span class="literal">-7</span><span class="literal">-16</span> <span class="number">12</span>:<span class="number">40</span>:<span class="number">49</span></span><br><span class="line">访问时间: <span class="number">2016</span><span class="literal">-7</span><span class="literal">-16</span> <span class="number">12</span>:<span class="number">40</span>:<span class="number">49</span></span><br><span class="line">修改时间: <span class="number">2016</span><span class="literal">-7</span><span class="literal">-16</span> <span class="number">12</span>:<span class="number">40</span>:<span class="number">49</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Process</span> finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>同步的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getTimeDesc = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [d.getFullYear(), d.getMonth()+<span class="number">1</span>, d.getDate()].join(<span class="string">'-'</span>) + <span class="string">' '</span> + [d.getHours(), d.getMinutes(), d.getSeconds()].join(<span class="string">':'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stats = fs.statSync(<span class="string">'./fileForStat.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'文件大小: '</span> + stats.size);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'创建时间: '</span> + getTimeDesc(stats.birthtime));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'访问时间: '</span> + getTimeDesc(stats.atime));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'修改时间: '</span> + getTimeDesc(stats.mtime));</span><br></pre></td></tr></table></figure>

<h3 id="访问-权限检测"><a href="#访问-权限检测" class="headerlink" title="访问/权限检测"></a>访问/权限检测</h3><p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.access(path[, mode], callback)</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.access(<span class="string">'./fileForAccess.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'可以访问'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同步版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.accessSync(path[, mode])</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果成功，则返回undefined，如果失败，则抛出错误（什么鬼）</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fs.accessSync(<span class="string">'./fileForAccess.txt'</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="keyword">throw</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件打开-关闭"><a href="#文件打开-关闭" class="headerlink" title="文件打开/关闭"></a>文件打开/关闭</h3><p>比较底层的接口，实际需要用到的机会不多。需要用到的时候看下<a href="https://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback" target="_blank" rel="noopener">文档</a>就行。</p>
<ul>
<li>flags：文件打开模式，比如<code>r</code>、<code>r+</code>、<code>w</code>、<code>w+</code>等。可选模式非常多。</li>
<li>mode：默认是<code>666</code>，可读+可写。</li>
</ul>
<blockquote>
<p>fs.open(path, flags[, mode], callback)<br>fs.openSync(path, flags[, mode])<br>fs.close(fd, callback)<br>fs.closeSync(fd)</p>
</blockquote>
<h3 id="文件读取（底层）"><a href="#文件读取（底层）" class="headerlink" title="文件读取（底层）"></a>文件读取（底层）</h3><p>相对底层的读取接口，参数如下</p>
<ul>
<li>fd：文件句柄。</li>
<li>buffer：将读取的文件内容写到buffer里。</li>
<li>offset：buffer开始写入的位置。（在offset开始写入，还是offset+1？）</li>
<li>length：要读取的字节数。</li>
<li>position：文件从哪个位置开始读取。如果是null，那么就从当前位置开始读取。（读取操作会记录下上一个位置）</li>
</ul>
<p>此外，<code>callback</code>的回调参数为<code>(err, bytesRead, buffer)</code></p>
<blockquote>
<p>fs.read(fd, buffer, offset, length, position, callback)</p>
</blockquote>
<h3 id="追加文件内容"><a href="#追加文件内容" class="headerlink" title="追加文件内容"></a>追加文件内容</h3><blockquote>
<p>fs.appendFile(file, data[, options], callback)</p>
</blockquote>
<ul>
<li>file：可以是文件路径，也可以是文件句柄。（还可以是buffer？）</li>
<li>data：要追加的内容。string或者buffer。</li>
<li>options<ul>
<li>encoding：编码，默认是<code>utf8</code></li>
<li>mode：默认是<code>0o666</code></li>
<li>flag：默认是<code>a</code></li>
</ul>
</li>
</ul>
<p>注意：如果<code>file</code>是文件句柄，那么</p>
<ul>
<li>开始追加数据前，file需要已经打开。</li>
<li>file需要手动关闭。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.appendFile(<span class="string">'./extra/fileForAppend.txt'</span>, <span class="string">'helo'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'append成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="文件内容截取"><a href="#文件内容截取" class="headerlink" title="文件内容截取"></a>文件内容截取</h3><blockquote>
<p>fs.truncate(path, len, callback)<br>fs.truncateSync(path, len)</p>
<p>fs.ftruncate(fd, len, callback)<br>fs.ftruncateSync(fd, len)</p>
</blockquote>
<p>用途参考<a href="http://man7.org/linux/man-pages/man2/ftruncate.2.html" target="_blank" rel="noopener">linux说明文档</a>。</p>
<p>要点：</p>
<ul>
<li><code>offset</code>不会变化。比如通过<code>fs.read()</code>读取文件内容，就需要特别注意。</li>
<li>如果<code>len</code>小于文件内容长度，剩余文件内容部分会丢失；如果<code>len</code>大于文件内容长度，那么超出的部分，会用<code>\0</code>进行填充。</li>
<li>如果传的是文件路径，需要确保文件是可写的；如果传的是文件句柄，需要确保文件句柄已经打开并且可写入。</li>
</ul>
<blockquote>
<p>The truncate() and ftruncate() functions cause the regular file named<br>by path or referenced by fd to be truncated to a size of precisely<br>length bytes.</p>
</blockquote>
<blockquote>
<p>If the file previously was larger than this size, the extra data is<br>lost.  If the file previously was shorter, it is extended, and the<br>extended part reads as null bytes (‘\0’).</p>
</blockquote>
<blockquote>
<p>The file offset is not changed.</p>
</blockquote>
<blockquote>
<p>With ftruncate(), the file must be open for writing; with truncate(), the file must be writable.</p>
</blockquote>
<h3 id="修改文件属性（时间）"><a href="#修改文件属性（时间）" class="headerlink" title="修改文件属性（时间）"></a>修改文件属性（时间）</h3><ul>
<li>path/fd：文件路径/文件句柄</li>
<li>atime：Access Time。上一次访问文件数据的时间。</li>
<li>mtime：Modified Time。修改时间。</li>
</ul>
<blockquote>
<p>fs.utimes(path, atime, mtime, callback)<br>fs.utimesSync(path, atime, mtime)</p>
</blockquote>
<blockquote>
<p>fs.futimes(fd, atime, mtime, callback)<br>fs.futimesSync(fd, atime, mtime)</p>
</blockquote>
<p>备注，在命令行下可以</p>
<ul>
<li>通过<code>stat</code>查看文件的状态信息，包括了上面的atime、mtime。</li>
<li>通过<code>touch</code>修改这几个时间。</li>
</ul>
<h3 id="创建文件链接"><a href="#创建文件链接" class="headerlink" title="创建文件链接"></a>创建文件链接</h3><blockquote>
<p>fs.symlink(target, path[, type], callback)<br>fs.symlinkSync(target, path[, type])</p>
<p>fs.link(srcpath, dstpath, callback)<br>fs.linkSync(srcpath, dstpath)</p>
</blockquote>
<blockquote>
<p> link() creates a new link (also known as a hard link) to an existing file.</p>
</blockquote>
<p>软链接、硬链接区别：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/" target="_blank" rel="noopener">参考</a> 或者 [这个]。(<a href="http://www.cnblogs.com/itech/archive/2009/04/10/1433052.html" target="_blank" rel="noopener">http://www.cnblogs.com/itech/archive/2009/04/10/1433052.html</a>)</p>
<ul>
<li>硬链接：inode相同，多个别名。删除一个硬链接文件，不会影响其他有相同inode的文件。</li>
<li>软链接：有自己的inode，用户数据块存放指向文件的inode。</li>
</ul>
<p>参考<a href="http://man7.org/linux/man-pages/man2/link.2.html" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="创建临时目录"><a href="#创建临时目录" class="headerlink" title="创建临时目录"></a>创建临时目录</h3><blockquote>
<p>fs.mkdtemp(prefix, callback)<br>fs.mkdtempSync(prefix)</p>
</blockquote>
<p>备忘：跟普通的随便找个目录，创建个随机名字的文件夹，有什么区别？</p>
<p>代码示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.mkdtemp(<span class="string">'/tmp/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, folder</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建临时目录: '</span> + folder);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/node mkdtemp.js</span><br><span class="line">创建临时目录: /tmp/Cxw51O</span><br></pre></td></tr></table></figure>

<h3 id="找出软连接指向的真实路径"><a href="#找出软连接指向的真实路径" class="headerlink" title="找出软连接指向的真实路径"></a>找出软连接指向的真实路径</h3><blockquote>
<p>fs.readlink(path[, options], callback)<br>fs.readlinkSync(path[, options])</p>
</blockquote>
<p>如下面例子，创建了个软链接指向<code>fileForReadLink.txt</code>，通过<code>fs.readlink()</code>就可以找出原始的路径。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> randomFileName = <span class="string">'./extra/fileForReadLink-'</span> + <span class="built_in">String</span>(<span class="built_in">Math</span>.random()).slice(<span class="number">2</span>, <span class="number">6</span>) + <span class="string">'.txt'</span>;</span><br><span class="line"></span><br><span class="line">fs.symlinkSync(<span class="string">'./extra/fileForReadLink.txt'</span>, randomFileName);</span><br><span class="line">fs.readlink(randomFileName, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, linkString</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'链接文件内容: '</span> + linkString);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>类似终端下直接运行<code>readlink</code>。对于软链接文件，效果同上面代码。对于硬链接，没有输出。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">➜  extra git:(master) ✗ readlink fileForReadLink<span class="literal">-9827</span>.txt</span><br><span class="line">./extra/fileForReadLink.txt</span><br><span class="line">➜  extra git:(master) ✗ readlink fileForLinkHard.txt </span><br><span class="line">➜  extra git:(master) ✗ readlink fileForLinkSoft.txt</span><br><span class="line">./extra/fileForLink.txt</span><br></pre></td></tr></table></figure>

<h3 id="真实路径"><a href="#真实路径" class="headerlink" title="真实路径"></a>真实路径</h3><blockquote>
<p>fs.realpath(path[, options], callback)<br>fs.realpathSync(path[, options])</p>
</blockquote>
<p>例子：（不能作用于软链接？）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fileForRealPath1.txt 是普通文件,正常运行</span></span><br><span class="line">fs.realpath(<span class="string">'./extra/inner/fileForRealPath1.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, resolvedPath</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fs.realpath: '</span> + resolvedPath);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fileForRealPath.txt 是软链接, 会报错,提示找不到文件</span></span><br><span class="line">fs.realpath(<span class="string">'./extra/inner/fileForRealPath.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, resolvedPath</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fs.realpath: '</span> + resolvedPath);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">'path.resolve: '</span> + path.resolve(<span class="string">'./extra/inner/fileForRealpath.txt'</span>) );</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">path.resolve: /Users/a/Documents/git<span class="literal">-code</span>/git<span class="literal">-blog</span>/demo/<span class="number">2015.05</span>.<span class="number">21</span><span class="literal">-node</span><span class="literal">-basic</span>/fs/extra/inner/fileForRealpath.txt</span><br><span class="line">fs.realpath: /Users/a/Documents/git<span class="literal">-code</span>/git<span class="literal">-blog</span>/demo/<span class="number">2015.05</span>.<span class="number">21</span><span class="literal">-node</span><span class="literal">-basic</span>/fs/extra/inner/fileForRealPath1.txt</span><br><span class="line">/Users/a/Documents/git<span class="literal">-code</span>/git<span class="literal">-blog</span>/demo/<span class="number">2015.05</span>.<span class="number">21</span><span class="literal">-node</span><span class="literal">-basic</span>/fs/realpath.js:<span class="number">12</span></span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">            ^</span><br><span class="line"></span><br><span class="line">Error: ENOENT: no such file or directory, realpath <span class="string">'./extra/inner/fileForRealPath.txt'</span></span><br><span class="line">    at Error (native)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Process</span> finished with <span class="keyword">exit</span> code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><blockquote>
<p>fs.rmdir(path, callback)<br>fs.rmdirSync(path)</p>
</blockquote>
<p>例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.rmdir(<span class="string">'./dirForRemove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'目录删除成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="不常用"><a href="#不常用" class="headerlink" title="不常用"></a>不常用</h3><h4 id="缓冲区内容写到磁盘"><a href="#缓冲区内容写到磁盘" class="headerlink" title="缓冲区内容写到磁盘"></a>缓冲区内容写到磁盘</h4><blockquote>
<p>fs.fdatasync(fd, callback)<br>fs.fdatasyncSync(fd)</p>
</blockquote>
<p>可以参考这里：</p>
<blockquote>
<p>1、sync函数<br>sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。<br>通常称为update的系统守护进程会周期性地（一般每隔30秒）调用sync函数。这就保证了定期冲洗内核的块缓冲区。命令sync(1)也调用sync函数。<br>2、fsync函数<br>fsync函数只对由文件描述符filedes指定的单一文件起作用，并且等待写磁盘操作结束，然后返回。<br>fsync可用于数据库这样的应用程序，这种应用程序需要确保将修改过的块立即写到磁盘上。<br>3、fdatasync函数<br>fdatasync函数类似于fsync，但它只影响文件的数据部分。而除数据外，fsync还会同步更新文件的属性。<br>对于提供事务支持的数据库，在事务提交时，都要确保事务日志（包含该事务所有的修改操作以及一个提交记录）完全写到硬盘上，才认定事务提交成功并返回给应用层。</p>
</blockquote>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>npm入门使用指南</title>
    <url>/2020/03/29/npm%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<p>由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm -v</span><br><span class="line"><span class="number">5.5</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：</p>
<p>如果是 Window 系统使用以下命令即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install npm -g</span><br></pre></td></tr></table></figure>

<h3 id="使用-npm-命令安装模块"><a href="#使用-npm-命令安装模块" class="headerlink" title="使用 npm 命令安装模块"></a><strong>使用 npm 命令安装模块</strong></h3><p>npm 安装 Node.js 模块语法格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<p>以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure>

<p>安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="全局安装与本地安装"><a href="#全局安装与本地安装" class="headerlink" title="全局安装与本地安装"></a><strong>全局安装与本地安装</strong></h3><p>npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已<br>比如:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">npm install express      # 本地安装</span><br><span class="line">npm install express -g   # 全局安装</span><br></pre></td></tr></table></figure>

<h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a><strong>本地安装</strong></h3><ol>
<li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以通过 require() 来引入本地安装的包。</li>
</ol>
<h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a><strong>全局安装</strong></h3><ol>
<li>将安装包放在 /usr/local 下或者你 node 的安装目录。</li>
<li>可以直接在命令行里使用。</li>
</ol>
<h3 id="查看安装信息"><a href="#查看安装信息" class="headerlink" title="查看安装信息"></a><strong>查看安装信息</strong></h3><p>你可以使用以下命令来查看所有全局安装的模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ npm list -g</span><br><span class="line"></span><br><span class="line">├─┬ cnpm@<span class="number">4.3</span><span class="number">.2</span></span><br><span class="line">│ ├── auto-correct@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│ ├── bagpipe@<span class="number">0.3</span><span class="number">.5</span></span><br><span class="line">│ ├── colors@<span class="number">1.1</span><span class="number">.2</span></span><br><span class="line">│ ├─┬ commander@<span class="number">2.9</span><span class="number">.0</span></span><br><span class="line">│ │ └── graceful-readlink@<span class="number">1.0</span><span class="number">.1</span></span><br><span class="line">│ ├─┬ cross-spawn@<span class="number">0.2</span><span class="number">.9</span></span><br><span class="line">│ │ └── lru-cache@<span class="number">2.7</span><span class="number">.3</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h3 id="使用-package-json"><a href="#使用-package-json" class="headerlink" title="使用 package.json"></a><strong>使用 package.json</strong></h3><p>每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。<br>直接的说：就是管理你本地安装的npm包 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"name"</span>: <span class="string">"Hello World"</span>,</span><br><span class="line">	<span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">	<span class="string">"author"</span>: <span class="string">"张三"</span>,</span><br><span class="line">	<span class="string">"description"</span>: <span class="string">"第一个node.js程序"</span>,</span><br><span class="line">	<span class="string">"keywords"</span>:[<span class="string">"node.js"</span>,<span class="string">"javascript"</span>],</span><br><span class="line">	<span class="string">"repository"</span>: &#123;</span><br><span class="line">		<span class="string">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">		<span class="string">"url"</span>: <span class="string">"https://path/to/url"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"license"</span>:<span class="string">"MIT"</span>,</span><br><span class="line">	<span class="string">"engines"</span>: &#123;<span class="string">"node"</span>: <span class="string">"0.10.x"</span>&#125;,</span><br><span class="line">	<span class="string">"bugs"</span>:&#123;<span class="string">"url"</span>:<span class="string">"http://path/to/bug"</span>,<span class="string">"email"</span>:<span class="string">"bug@example.com"</span>&#125;,</span><br><span class="line">	<span class="string">"contributors"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"李四"</span>,<span class="string">"email"</span>:<span class="string">"lisi@example.com"</span>&#125;],</span><br><span class="line">	<span class="string">"scripts"</span>: &#123;</span><br><span class="line">		<span class="string">"start"</span>: <span class="string">"node index.js"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"dependencies"</span>: &#123;</span><br><span class="line">		<span class="string">"express"</span>: <span class="string">"latest"</span>,</span><br><span class="line">		<span class="string">"mongoose"</span>: <span class="string">"~3.8.3"</span>,</span><br><span class="line">		<span class="string">"handlebars-runtime"</span>: <span class="string">"~1.0.12"</span>,</span><br><span class="line">		<span class="string">"express3-handlebars"</span>: <span class="string">"~0.5.0"</span>,</span><br><span class="line">		<span class="string">"MD5"</span>: <span class="string">"~1.2.0"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">		<span class="string">"bower"</span>: <span class="string">"~1.2.8"</span>,</span><br><span class="line">		<span class="string">"grunt"</span>: <span class="string">"~0.4.1"</span>,</span><br><span class="line">		<span class="string">"grunt-contrib-concat"</span>: <span class="string">"~0.3.0"</span>,</span><br><span class="line">		<span class="string">"grunt-contrib-jshint"</span>: <span class="string">"~0.7.2"</span>,</span><br><span class="line">		<span class="string">"grunt-contrib-uglify"</span>: <span class="string">"~0.2.7"</span>,</span><br><span class="line">		<span class="string">"grunt-contrib-clean"</span>: <span class="string">"~0.5.0"</span>,</span><br><span class="line">		<span class="string">"browserify"</span>: <span class="string">"2.36.1"</span>,</span><br><span class="line">		<span class="string">"grunt-browserify"</span>: <span class="string">"~1.3.0"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Package-json-属性说明"><a href="#Package-json-属性说明" class="headerlink" title="Package.json 属性说明"></a><strong>Package.json 属性说明</strong></h3><ul>
<li><p>name - 包名。</p>
</li>
<li><p>version - 包的版本号。</p>
</li>
<li><p>description - 包的描述。</p>
</li>
<li><p>homepage - 包的官网 url 。</p>
</li>
<li><p>author - 包的作者姓名。</p>
</li>
<li><p>contributors - 包的其他贡献者姓名。</p>
</li>
<li><p>dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</p>
</li>
<li><p>repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。</p>
</li>
<li><p>main - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。</p>
</li>
<li><p>keywords - 关键字</p>
</li>
</ul>
<p><strong>详细介绍参考</strong> <a href="http://javascript.ruanyifeng.com/nodejs/packagejson.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/packagejson.html</a></p>
<h3 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a><strong>卸载模块</strong></h3><p>我们可以使用以下命令来卸载 Node.js 模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm uninstall express</span><br></pre></td></tr></table></figure>
<h3 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a><strong>更新模块</strong></h3><p>我们可以使用以下命令更新模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm update express</span><br></pre></td></tr></table></figure>
<h3 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a><strong>搜索模块</strong></h3><p>使用以下来搜索模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm search express</span><br></pre></td></tr></table></figure>
<h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a><strong>创建模块</strong></h3><p>创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm init</span><br><span class="line">This utility will walk you through creating a package.json file.</span><br><span class="line">It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line"></span><br><span class="line">See <span class="string">`npm help json`</span> <span class="keyword">for</span> definitive documentation on these fields</span><br><span class="line">and exactly what they <span class="keyword">do</span>.</span><br><span class="line"></span><br><span class="line">Use <span class="string">`npm install &lt;pkg&gt; --save`</span> afterwards to install a package and</span><br><span class="line">save it <span class="keyword">as</span> a dependency <span class="keyword">in</span> the package.json file.</span><br><span class="line"></span><br><span class="line">Press ^C at any time to quit.</span><br><span class="line">name: (node_modules) test                   # 模块名</span><br><span class="line">version: (<span class="number">1.0</span><span class="number">.0</span>) </span><br><span class="line">description: Node.js 测试模块(www.test.com)  # 描述</span><br><span class="line">entry point: (index.js) </span><br><span class="line">test command: make test</span><br><span class="line">git repository: https:<span class="comment">//github.com/test/runoob.git  # Github 地址</span></span><br><span class="line">keywords: </span><br><span class="line">author: </span><br><span class="line">license: (ISC) </span><br><span class="line">About to write to ……/node_modules/package.json:      # 生成地址</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"learn"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"Node.js 测试模块"</span>,</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is <span class="keyword">this</span> ok? (yes) yes</span><br></pre></td></tr></table></figure>
<p>以上的信息，你需要根据你自己的情况输入。在最后输入 “yes” 后会生成 package.json 文件。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install [-g] 本地或全局安装模块</span><br><span class="line">npm uninstall [-g] 本地或全局卸载模块</span><br><span class="line">npm update 更新模块</span><br><span class="line">npm ls 查看安装的模块</span><br><span class="line">npm list 列出已安装模块</span><br><span class="line">npm show  显示模块详情</span><br><span class="line">npm info 查看模块的详细信息</span><br><span class="line">npm search 搜索模块</span><br><span class="line">npm publish 发布模块</span><br><span class="line">npm unpublish 删除已发布的模块</span><br><span class="line">npm -v 或 npm version显示版本信息</span><br><span class="line">npm view npm versions 列出npm 的所有有效版本</span><br><span class="line">npm install -g npm@<span class="number">2.14</span><span class="number">.14</span> /npm update -g npm@<span class="number">2.14</span><span class="number">.14</span>  安装指定的npm版本</span><br><span class="line">npm init 引导创建一个package.json文件，包括名称、版本、作者这些信息等</span><br><span class="line">npm outdated  #检查模块是否已经过时</span><br><span class="line">npm root  [-g] 查看包的安装路径，输出 node_modules的路径，</span><br><span class="line">npm help 查看某条命令的详细帮助 例如输入npm help install</span><br><span class="line">npm config 管理npm的配置路径</span><br></pre></td></tr></table></figure>

<h3 id="使用淘宝-NPM-镜像"><a href="#使用淘宝-NPM-镜像" class="headerlink" title="使用淘宝 NPM 镜像"></a><strong>使用淘宝 NPM 镜像</strong></h3><p>大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</p>
<p>淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>
<p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">&#96;&#96;&#96; javascript</span><br><span class="line">这样就可以使用 cnpm 命令来安装模块了：</span><br></pre></td></tr></table></figure>
<p> cnpm install [name]</p>
<pre><code></code></pre>]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>nodejs</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer基础-极速入门教程（必看）</title>
    <url>/2020/04/03/puppeteer%E5%9F%BA%E7%A1%80-%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E5%BF%85%E7%9C%8B%EF%BC%89/</url>
    <content><![CDATA[<h2 id="1、Puppeteer-简介"><a href="#1、Puppeteer-简介" class="headerlink" title="1、Puppeteer 简介"></a>1、Puppeteer 简介</h2><p>Puppeteer 是一个node库，他提供了一组用来操纵Chrome的API, 通俗来说就是一个 headless chrome浏览器 (当然你也可以配置成有UI的，默认是没有的)。既然是浏览器，那么我们手工可以在浏览器上做的事情 Puppeteer 都能胜任, 另外，Puppeteer 翻译成中文是”木偶”意思，所以听名字就知道，操纵起来很方便，你可以很方便的操纵她去实现：</p>
<blockquote>
<p>  1） 生成网页截图或者 PDF<br>    2） 高级爬虫，可以爬取大量异步渲染内容的网页<br>    3） 模拟键盘输入、表单自动提交、登录网页等，实现 UI 自动化测试<br>    4） 捕获站点的时间线，以便追踪你的网站，帮助分析网站性能问题</p>
</blockquote>
<p>如果你用过 PhantomJS 的话，你会发现她们有点类似，但Puppeteer是Chrome官方团队进行维护的，用俗话说就是”有娘家的人“，前景更好。</p>
<a id="more"></a>

<h2 id="2、运行环境"><a href="#2、运行环境" class="headerlink" title="2、运行环境"></a>2、运行环境</h2><p>查看 Puppeteer 的官方 API 你会发现满屏的 async, await 之类，这些都是 ES7 的规范，所以你需要：</p>
<ul>
<li>Nodejs 的版本不能低于 v7.6.0, 需要支持 async, await.</li>
<li>需要最新的 chrome driver, 这个你在通过 npm 安装 Puppeteer 的时候系统会自动下载的<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install puppeteer --save</span><br><span class="line">或者</span><br><span class="line">yarn add  puppeteer</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="3、基本用法"><a href="#3、基本用法" class="headerlink" title="3、基本用法"></a>3、基本用法</h2><p>先开看看官方的入门的 DEMO</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://example.com'</span>);</span><br><span class="line">  <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'example.png'</span>&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>上面这段代码就实现了网页截图，先大概解读一下上面几行代码：</p>
<ul>
<li>先通过 puppeteer.launch() 创建一个浏览器实例 Browser 对象</li>
<li>然后通过 Browser 对象创建页面 Page 对象</li>
<li>然后 page.goto() 跳转到指定的页面</li>
<li>调用 page.screenshot() 对页面进行截图</li>
<li>关闭浏览器</li>
</ul>
<p>是不是觉得好简单</p>
<h3 id="3-1-puppeteer-launch-options"><a href="#3-1-puppeteer-launch-options" class="headerlink" title="3.1 puppeteer.launch(options)"></a>3.1 puppeteer.launch(options)</h3><p>使用 puppeteer.launch() 运行 puppeteer，它会 return 一个 promise，使用 then 方法获取 browser 实例， 当然高版本的 的 nodejs 已经支持 await 特性了，所以上面的例子使用 await 关键字，这一点需要特殊说明一下，Puppeteer 几乎所有的操作都是 异步的, 为了使用大量的 then 使得代码的可读性降低，本文所有 demo 代码都是用 async, await 方式实现。这个 也是 Puppeteer 官方推荐的写法。</p>
<p><strong>options 参数详解</strong></p>
<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数说明</th>
</tr>
</thead>
<tbody><tr>
<td>ignoreHTTPSErrors</td>
<td>boolean</td>
<td>在请求的过程中是否忽略 Https 报错信息，默认为 false</td>
</tr>
<tr>
<td>headless</td>
<td>boolean</td>
<td>是否以”无头”的模式运行 chrome, 也就是不显示 UI， 默认为 true</td>
</tr>
<tr>
<td>executablePath</td>
<td>string</td>
<td>可执行文件的路劲，Puppeteer 默认是使用它自带的 chrome webdriver, 如果你想指定一个自己的 webdriver 路径，可以通过这个参数设置</td>
</tr>
<tr>
<td>slowMo</td>
<td>number</td>
<td>使 Puppeteer 操作减速，单位是毫秒。如果你想看看 Puppeteer 的整个工作过程，这个参数将非常有用。</td>
</tr>
<tr>
<td>args</td>
<td>Array(String)</td>
<td>传递给 chrome 实例的其他参数，比如你可以使用”–ash-host-window-bounds=1024x768” 来设置浏览器窗口大小。更多参数参数列表可以参考这里</td>
</tr>
<tr>
<td>handleSIGINT</td>
<td>boolean</td>
<td>是否允许通过进程信号控制 chrome 进程，也就是说是否可以使用 CTRL+C 关闭并退出浏览器.</td>
</tr>
<tr>
<td>timeout</td>
<td>number</td>
<td>等待 Chrome 实例启动的最长时间。默认为30000（30秒）。如果传入 0 的话则不限制时间</td>
</tr>
<tr>
<td>dumpio</td>
<td>boolean</td>
<td>是否将浏览器进程stdout和stderr导入到process.stdout和process.stderr中。默认为false。</td>
</tr>
<tr>
<td>userDataDir</td>
<td>string</td>
<td>设置用户数据目录，默认linux 是在 ~/.config 目录，window 默认在 C:\Users{USER}\AppData\Local\Google\Chrome\User Data, 其中 {USER} 代表当前登录的用户名</td>
</tr>
<tr>
<td>env</td>
<td>Object</td>
<td>指定对Chromium可见的环境变量。默认为process.env。</td>
</tr>
<tr>
<td>devtools</td>
<td>boolean</td>
<td>是否为每个选项卡自动打开DevTools面板， 这个选项只有当 headless 设置为 false 的时候有效</td>
</tr>
</tbody></table>
<h3 id="3-2-Browser-对象"><a href="#3-2-Browser-对象" class="headerlink" title="3.2 Browser 对象"></a>3.2 Browser 对象</h3><p>当 Puppeteer 连接到一个 Chrome 实例的时候就会创建一个 Browser 对象，有以下两种方式：</p>
<p>Puppeteer.launch 和 Puppeteer.connect.</p>
<p>下面这个 DEMO 实现断开连接之后重新连接浏览器实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">puppeteer.launch().then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">  <span class="comment">// 保存 Endpoint，这样就可以重新连接  Chromium</span></span><br><span class="line">  <span class="keyword">const</span> browserWSEndpoint = browser.wsEndpoint();</span><br><span class="line">  <span class="comment">// 从Chromium 断开连接</span></span><br><span class="line">  browser.disconnect();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用endpoint 重新和 Chromiunm 建立连接</span></span><br><span class="line">  <span class="keyword">const</span> browser2 = <span class="keyword">await</span> puppeteer.connect(&#123;browserWSEndpoint&#125;);</span><br><span class="line">  <span class="comment">// Close Chromium</span></span><br><span class="line">  <span class="keyword">await</span> browser2.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Browser 对象 API</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>返回值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>browser.close()</td>
<td>Promise</td>
<td>关闭浏览器</td>
</tr>
<tr>
<td>browser.disconnect()</td>
<td>void</td>
<td>断开浏览器连接</td>
</tr>
<tr>
<td>browser.newPage()</td>
<td>Promise(Page)</td>
<td>创建一个 Page 实例</td>
</tr>
<tr>
<td>browser.pages()</td>
<td>Promise(Array(Page))</td>
<td>获取所有打开的 Page 实例</td>
</tr>
<tr>
<td>browser.targets()</td>
<td>Array(Target)</td>
<td>获取所有活动的 targets</td>
</tr>
<tr>
<td>browser.version()</td>
<td>Promise(String)</td>
<td>获取浏览器的版本</td>
</tr>
<tr>
<td>browser.wsEndpoint()</td>
<td>String</td>
<td>返回浏览器实例的 socket 连接 URL, 可以通过这个 URL 重连接 chrome 实例</td>
</tr>
</tbody></table>
<p>官方提供的详细的 API， <a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md" target="_blank" rel="noopener">戳这里</a></p>
<h2 id="4、Puppeteer-实战"><a href="#4、Puppeteer-实战" class="headerlink" title="4、Puppeteer 实战"></a>4、Puppeteer 实战</h2><p>了解 API 之后我们就可以来一些实战了，在此之前，我们先了解一下 Puppeteer 的设计原理，简单来说 Puppeteer 跟 webdriver 以及 PhantomJS 最大的 的不同就是它是站在用户浏览的角度，而 webdriver 和 PhantomJS 最初设计就是用来做自动化测试的，所以它是站在机器浏览的角度来设计的，所以它们 使用的是不同的设计哲学。举个栗子，加入我需要打开京东的首页并进行一次产品搜索，分别看看使用 Puppeteer 和 webdriver 的实现流程：</p>
<p><strong>Puppeteer 的实现流程：</strong></p>
<ul>
<li>打开京东首页</li>
<li>将光标 focus 到搜索输入框</li>
<li>键盘点击输入文字</li>
<li>点击搜索按钮</li>
</ul>
<p><strong>webdriver 的实现流程：</strong></p>
<ul>
<li>打开京东首页</li>
<li>找到输入框的 input 元素</li>
<li>设置 input 的值为要搜索文字</li>
<li>触发搜索按钮的单机事件</li>
</ul>
<p>个人感觉 Puppeteer 设计哲学更符合任何的操作习惯，更自然一些。</p>
<p>下面我们就用一个简单的需求实现来进行 Puppeteer 的入门学习。这个简单的需求就是：</p>
<blockquote>
<p>在京东商城抓取10个手机商品，并把商品的详情页截图。</p>
</blockquote>
<ul>
<li>首先我们来梳理一下操作流程</li>
<li>打开京东首页</li>
<li>输入“手机”关键字并搜索</li>
<li>获取前10个商品的 A 标签，并获取 href 属性值，获取商品详情链接</li>
<li>分别打开10个商品的详情页，截取网页图片</li>
</ul>
<p>要实现上面的功能需要用到查找元素，获取属性，键盘事件等，那接下来我们就一个一个的讲解一下。</p>
<h3 id="4-1-获取元素"><a href="#4-1-获取元素" class="headerlink" title="4.1 获取元素"></a>4.1 获取元素</h3><p>Page 对象提供了2个 API 来获取页面元素</p>
<p>(1). Page.$(selector) 获取单个元素，底层是调用的是 document.querySelector() , 所以选择器的 selector 格式遵循 css 选择器规范</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> inputElement = <span class="keyword">await</span> page.$(<span class="string">"#search"</span>, input =&gt; input);</span><br><span class="line"><span class="comment">//下面写法等价</span></span><br><span class="line"><span class="keyword">let</span> inputElement = <span class="keyword">await</span> page.$(<span class="string">'#search'</span>);</span><br></pre></td></tr></table></figure>
<p>(2). Page.$$(selector) 获取一组元素，底层调用的是 document.querySelectorAll(). 返回 Promise(Array(ElemetHandle)) 元素数组.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> links = <span class="keyword">await</span> page.$$(<span class="string">"a"</span>);</span><br><span class="line"><span class="comment">//下面写法等价</span></span><br><span class="line"><span class="keyword">const</span> links = <span class="keyword">await</span> page.$$(<span class="string">"a"</span>, links =&gt; links);</span><br></pre></td></tr></table></figure>
<p>最终返回的都是 ElemetHandle 对象</p>
<h3 id="4-2-获取元素属性"><a href="#4-2-获取元素属性" class="headerlink" title="4.2 获取元素属性"></a>4.2 获取元素属性</h3><p>Puppeteer 获取元素属性跟我们平时写前段的js的逻辑有点不一样，按照通常的逻辑，应该是现获取元素，然后在获取元素的属性。但是上面我们知道 获取元素的 API 最终返回的都是 ElemetHandle 对象，而你去查看 ElemetHandle 的 API 你会发现，它并没有获取元素属性的 API.</p>
<p>事实上 Puppeteer 专门提供了一套获取属性的 API， Page.$eval() 和 Page.$$eval()</p>
<p>(1). Page.$$eval(selector, pageFunction[, …args]), 获取单个元素的属性，这里的选择器 selector 跟上面 Page.$(selector) 是一样的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> value = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'input[name=search]'</span>, input =&gt; input.value);</span><br><span class="line"><span class="keyword">const</span> href = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'#a", ele =&gt; ele.href);</span></span><br><span class="line"><span class="string">const content = await page.$eval('</span>.content<span class="string">', ele =&gt; ele.outerHTML);</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-执行自定义的-JS-脚本"><a href="#4-3-执行自定义的-JS-脚本" class="headerlink" title="4.3 执行自定义的 JS 脚本"></a>4.3 执行自定义的 JS 脚本</h3><p>Puppeteer 的 Page 对象提供了一系列 evaluate 方法，你可以通过他们来执行一些自定义的 js 代码，主要提供了下面三个 API</p>
<blockquote>
<p>(1). page.evaluate(pageFunction, …args) 返回一个可序列化的普通对象，pageFunction 表示要在页面执行的函数， args 表示传入给 pageFunction 的参数， 下面的 pageFunction 和 args 表示同样的意思。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">8</span> * <span class="number">7</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// prints "56"</span></span><br></pre></td></tr></table></figure>

<p>这个方法很有用，比如我们在获取页面的截图的时候，默认是只截图当前浏览器窗口的尺寸大小，默认值是800x600，那如果我们需要获取整个网页的完整 截图是没办法办到的。Page.screenshot() 方法提供了可以设置截图区域大小的参数，那么我们只要在页面加载完了之后获取页面的宽度和高度就可以解决 这个问题了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">	<span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;<span class="attr">headless</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">	<span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">	<span class="keyword">await</span> page.goto(<span class="string">'https://jr.dayi35.com'</span>);</span><br><span class="line">	<span class="keyword">await</span> page.setViewport(&#123;<span class="attr">width</span>:<span class="number">1920</span>, <span class="attr">height</span>:<span class="number">1080</span>&#125;);</span><br><span class="line">	<span class="keyword">const</span> documentSize = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">			height : <span class="built_in">document</span>.body.clientHeight,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>:<span class="string">"example.png"</span>, <span class="attr">clip</span> : &#123;<span class="attr">x</span>:<span class="number">0</span>, <span class="attr">y</span>:<span class="number">0</span>, <span class="attr">width</span>:<span class="number">1920</span>, <span class="attr">height</span>:documentSize.height&#125;&#125;);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>(2). Page.evaluateHandle(pageFunction, …args) 在 Page 上下文执行一个 pageFunction, 返回 JSHandle 实体</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aWindowHandle = <span class="keyword">await</span> page.evaluateHandle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Promise</span>.resolve(<span class="built_in">window</span>));</span><br><span class="line">aWindowHandle; <span class="comment">// Handle for the window object. </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> aHandle = <span class="keyword">await</span> page.evaluateHandle(<span class="string">'document'</span>); <span class="comment">// Handle for the 'document'.</span></span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看出，page.evaluateHandle() 方法也是通过 Promise.resolve 方法直接把 Promise 的最终处理结果返回， 只不过把最后返回的对象封装成了 JSHandle 对象。本质上跟 evaluate 没有什么区别。</p>
<p>下面这段代码实现获取页面的动态（包括js动态插入的元素） HTML 代码.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> aHandle = <span class="keyword">await</span> page.evaluateHandle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">document</span>.body);</span><br><span class="line"><span class="keyword">const</span> resultHandle = <span class="keyword">await</span> page.evaluateHandle(<span class="function"><span class="params">body</span> =&gt;</span> body.innerHTML, aHandle);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">await</span> resultHandle.jsonValue());</span><br><span class="line"><span class="keyword">await</span> resultHandle.dispose();</span><br></pre></td></tr></table></figure>

<h3 id="4-4-Page-exposeFunction"><a href="#4-4-Page-exposeFunction" class="headerlink" title="4.4 Page.exposeFunction"></a>4.4 Page.exposeFunction</h3><p>除此上面三个 API 之外，还有一类似的非常有用的 API， 那就是 <code>Page.exposeFunction</code>，这个 API 用来在页面注册全局函数，非常有用：</p>
<p>因为有时候需要在页面处理一些操作的时候需要用到一些函数，虽然可以通过 Page.evaluate() API 在页面定义函数，比如</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> docSize = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">getPageSize</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			width: <span class="built_in">document</span>.documentElement.clientWidth,</span><br><span class="line">			height : <span class="built_in">document</span>.body.clientHeight,</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> getPageSize();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>但是这样的函数不是全局的，需要在每个 evaluate 中去重新定义，无法做到代码复用<br>在一个就是 nodejs 有很多工具包可以很轻松的实现很复杂的功能 比如要实现 md5 加密函数，这个用纯 js 去实现就不太方便了，而用 nodejs 却是几行代码的事情。</p>
<p>下面代码实现给 Page 上下文的 window 对象添加 md5 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line">puppeteer.launch().then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  page.on(<span class="string">'console'</span>, msg =&gt; <span class="built_in">console</span>.log(msg.text));</span><br><span class="line">    <span class="comment">//注册全局函数   </span></span><br><span class="line">  <span class="keyword">await</span> page.exposeFunction(<span class="string">'md5'</span>, text =&gt;</span><br><span class="line">    crypto.createHash(<span class="string">'md5'</span>).update(text).digest(<span class="string">'hex'</span>)</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">await</span> page.evaluate(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// use window.md5 to compute hashes</span></span><br><span class="line">    <span class="keyword">const</span> myString = <span class="string">'PUPPETEER'</span>;</span><br><span class="line">    <span class="keyword">const</span> myHash = <span class="keyword">await</span> <span class="built_in">window</span>.md5(myString);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`md5 of <span class="subst">$&#123;myString&#125;</span> is <span class="subst">$&#123;myHash&#125;</span>`</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看出，Page.exposeFunction API 使用起来是很方便的，也非常有用，在比如给 window 对象注册 readfile 全局函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">puppeteer.launch().then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  page.on(<span class="string">'console'</span>, msg =&gt; <span class="built_in">console</span>.log(msg.text));</span><br><span class="line">  <span class="keyword">await</span> page.exposeFunction(<span class="string">'readfile'</span>, <span class="keyword">async</span> filePath =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      fs.readFile(filePath, <span class="string">'utf8'</span>, (err, text) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err)</span><br><span class="line">          reject(err);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          resolve(text);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">await</span> page.evaluate(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// use window.readfile to read contents of a file</span></span><br><span class="line">    <span class="keyword">const</span> content = <span class="keyword">await</span> <span class="built_in">window</span>.readfile(<span class="string">'/etc/hosts'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(content);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="5、Page-emulate-修改模拟器-客户端-运行配置"><a href="#5、Page-emulate-修改模拟器-客户端-运行配置" class="headerlink" title="5、Page.emulate 修改模拟器(客户端)运行配置"></a>5、Page.emulate 修改模拟器(客户端)运行配置</h2><p>Puppeteer 提供了一些 API 供我们修改浏览器终端的配置</p>
<ul>
<li>Page.setViewport() 修改浏览器视窗大小</li>
<li>Page.setUserAgent() 设置浏览器的 UserAgent 信息</li>
<li>Page.emulateMedia() 更改页面的CSS媒体类型，用于进行模拟媒体仿真。 可选值为 “screen”, “print”, “null”, 如果设置为 null 则表示禁用媒体仿真。</li>
<li>Page.emulate() 模拟设备，参数设备对象，比如 iPhone, Mac, Android 等</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">page.setViewport(&#123;<span class="attr">width</span>:<span class="number">1920</span>, <span class="attr">height</span>:<span class="number">1080</span>&#125;); <span class="comment">//设置视窗大小为 1920x1080</span></span><br><span class="line">page.setUserAgent(<span class="string">'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36'</span>);</span><br><span class="line">page.emulateMedia(<span class="string">'print'</span>); <span class="comment">//设置打印机媒体样式</span></span><br></pre></td></tr></table></figure>
<p>除此之外我们还可以模拟非 PC 机设备, 比如下面这段代码模拟 iPhone 6 访问google：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> devices = <span class="built_in">require</span>(<span class="string">'puppeteer/DeviceDescriptors'</span>);</span><br><span class="line"><span class="keyword">const</span> iPhone = devices[<span class="string">'iPhone 6'</span>];</span><br><span class="line"></span><br><span class="line">puppeteer.launch().then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.emulate(iPhone);</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://www.google.com'</span>);</span><br><span class="line">  <span class="comment">// other actions...</span></span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Puppeteer 支持很多设备模拟仿真，比如Galaxy, iPhone, IPad 等，想要知道详细设备支持，请戳这里 <a href="https://github.com/GoogleChrome/puppeteer/blob/master/DeviceDescriptors.js" target="_blank" rel="noopener">DeviceDescriptors.js</a></p>
<h2 id="6、键盘和鼠标"><a href="#6、键盘和鼠标" class="headerlink" title="6、键盘和鼠标"></a>6、键盘和鼠标</h2><p>键盘和鼠标的API比较简单，键盘的几个API如下：</p>
<ul>
<li>keyboard.down(key[, options]) 触发 keydown 事件</li>
<li>keyboard.press(key[, options]) 按下某个键，key 表示键的名称，比如 ‘ArrowLeft’ 向左键，详细的键名映射请戳这里</li>
<li>keyboard.sendCharacter(char) 输入一个字符</li>
<li>keyboard.type(text, options) 输入一个字符串</li>
<li>keyboard.up(key) 触发 keyup 事件<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">page.keyboard.press(<span class="string">"Shift"</span>); <span class="comment">//按下 Shift 键</span></span><br><span class="line">page.keyboard.sendCharacter(<span class="string">'嗨'</span>);</span><br><span class="line">page.keyboard.type(<span class="string">'Hello'</span>); <span class="comment">// 一次输入完成</span></span><br><span class="line">page.keyboard.type(<span class="string">'World'</span>, &#123;<span class="attr">delay</span>: <span class="number">100</span>&#125;); <span class="comment">// 像用户一样慢慢输入</span></span><br></pre></td></tr></table></figure>
鼠标操作：</li>
<li>mouse.click(x, y, [options]) 移动鼠标指针到指定的位置，然后按下鼠标，这个其实 mouse.move 和 mouse.down 或 mouse.up 的快捷操作</li>
<li>mouse.down([options]) 触发 mousedown 事件，options 可配置:<ul>
<li>options.button 按下了哪个键，可选值为[left, right, middle], 默认是 left, 表示鼠标左键</li>
<li>options.clickCount 按下的次数，单击，双击或者其他次数</li>
<li>delay 按键延时时间</li>
</ul>
</li>
<li>mouse.move(x, y, [options]) 移动鼠标到指定位置， options.steps 表示移动的步长</li>
<li>mouse.up([options]) 触发 mouseup 事件</li>
</ul>
<h2 id="7、另外几个有用的-API"><a href="#7、另外几个有用的-API" class="headerlink" title="7、另外几个有用的 API"></a>7、另外几个有用的 API</h2><p>Puppeteer 还提供几个非常有用的 API， 比如：</p>
<h3 id="7-1-Page-waitFor-系列-API"><a href="#7-1-Page-waitFor-系列-API" class="headerlink" title="7.1 Page.waitFor 系列 API"></a>7.1 Page.waitFor 系列 API</h3><ul>
<li><p>page.waitFor(selectorOrFunctionOrTimeout[, options[, …args]]) 下面三个的综合 API<br>  此方法根据第一个参数的不同有不同的结果：</p>
<ul>
<li>如果 selectorOrFunctionOrTimeout 是 string, 那么认为是 css 选择器或者一个xpath</li>
<li>如果 selectorOrFunctionOrTimeout 是 function, 那么认为是一个predicate，这时候此方法是page.waitForFunction()的简写</li>
<li>如果 selectorOrFunctionOrTimeout 是 number, 那么认为是超时时间，单位是毫秒，返回的是Promise对象,在指定时间后resolve</li>
</ul>
</li>
<li><p>page.waitForFunction(pageFunction[, options[, …args]]) 等待 pageFunction 执行完成之后</p>
</li>
<li><p>page.waitForNavigation(options) 等待页面基本元素加载完之后，比如同步的 HTML, CSS, JS 等代码</p>
</li>
<li><p>page.waitForSelector(selector[, options]) 等待某个选择器的元素加载之后，这个元素可以是异步加载的，这个 API 非常有用，你懂的。</p>
</li>
</ul>
<p>比如我想获取某个通过 js 异步加载的元素，那么直接获取肯定是获取不到的。这个时候就可以使用 page.waitForSelector 来解决：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待元素加载之后，否则获取不到异步加载的元素</span></span><br><span class="line"><span class="keyword">await</span> page.waitForSelector(<span class="string">'.gl-item'</span>); </span><br><span class="line"><span class="keyword">const</span> links = <span class="keyword">await</span> page.$$<span class="built_in">eval</span>(<span class="string">'.gl-item &gt; .gl-i-wrap &gt; .p-img &gt; a'</span>, links =&gt; &#123;</span><br><span class="line">	<span class="keyword">return</span> links.map(<span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			href: a.href.trim(),</span><br><span class="line">			name: a.title</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="7-2-page-getMetrics"><a href="#7-2-page-getMetrics" class="headerlink" title="7.2 page.getMetrics()"></a>7.2 page.getMetrics()</h3><p>通过 page.getMetrics() 可以得到一些页面性能数据， 捕获网站的时间线跟踪，以帮助诊断性能问题。</p>
<ul>
<li>Timestamp 度量标准采样的时间戳</li>
<li>Documents 页面文档数</li>
<li>Frames 页面 frame 数</li>
<li>JSEventListeners 页面内事件监听器数</li>
<li>Nodes 页面 DOM 节点数</li>
<li>LayoutCount 页面布局总数</li>
<li>RecalcStyleCount 样式重算数</li>
<li>LayoutDuration 所有页面布局的合并持续时间</li>
<li>RecalcStyleDuration 所有页面样式重新计算的组合持续时间。</li>
<li>ScriptDuration 所有脚本执行的持续时间</li>
<li>TaskDuration 所有浏览器任务时长</li>
<li>JSHeapUsedSize JavaScript 占用堆大小</li>
<li>JSHeapTotalSize JavaScript 堆总量</li>
</ul>
<h2 id="8、总结和源码"><a href="#8、总结和源码" class="headerlink" title="8、总结和源码"></a>8、总结和源码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//延时函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				resolve(<span class="number">1</span>)</span><br><span class="line">			&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">				reject(<span class="number">0</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, delay)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line">puppeteer.launch(&#123;</span><br><span class="line">	ignoreHTTPSErrors:<span class="literal">true</span>, </span><br><span class="line">	headless:<span class="literal">false</span>,<span class="attr">slowMo</span>:<span class="number">250</span>, </span><br><span class="line">	timeout:<span class="number">0</span>&#125;).then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">let</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">	<span class="keyword">await</span> page.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">await</span> page.goto(<span class="string">"https://www.jd.com/"</span>);</span><br><span class="line">	<span class="keyword">const</span> searchInput = <span class="keyword">await</span> page.$(<span class="string">"#key"</span>);</span><br><span class="line">	<span class="keyword">await</span> searchInput.focus(); <span class="comment">//定位到搜索框</span></span><br><span class="line">	<span class="keyword">await</span> page.keyboard.type(<span class="string">"手机"</span>);</span><br><span class="line">	<span class="keyword">const</span> searchBtn = <span class="keyword">await</span> page.$(<span class="string">".button"</span>);</span><br><span class="line">	<span class="keyword">await</span> searchBtn.click();</span><br><span class="line">	<span class="keyword">await</span> page.waitForSelector(<span class="string">'.gl-item'</span>); <span class="comment">//等待元素加载之后，否则获取不异步加载的元素</span></span><br><span class="line">	<span class="keyword">const</span> links = <span class="keyword">await</span> page.$$<span class="built_in">eval</span>(<span class="string">'.gl-item &gt; .gl-i-wrap &gt; .p-img &gt; a'</span>, links =&gt; &#123;</span><br><span class="line">		<span class="keyword">return</span> links.map(<span class="function"><span class="params">a</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> &#123;</span><br><span class="line">				href: a.href.trim(),</span><br><span class="line">				title: a.title</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">	page.close();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> aTags = links.splice(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; aTags.length; i++) &#123;</span><br><span class="line">		page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">		page.setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">await</span> page.setViewport(&#123;<span class="attr">width</span>:<span class="number">1920</span>, <span class="attr">height</span>:<span class="number">1080</span>&#125;);</span><br><span class="line">		<span class="keyword">var</span> a = aTags[i];</span><br><span class="line">		<span class="keyword">await</span> page.goto(a.href, &#123;<span class="attr">timeout</span>:<span class="number">0</span>&#125;); <span class="comment">//防止页面太长，加载超时</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//注入代码，慢慢把滚动条滑到最底部，保证所有的元素被全部加载</span></span><br><span class="line">		<span class="keyword">let</span> scrollEnable = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">let</span> scrollStep = <span class="number">500</span>; <span class="comment">//每次滚动的步长</span></span><br><span class="line">		<span class="keyword">while</span> (scrollEnable) &#123;</span><br><span class="line">			scrollEnable = <span class="keyword">await</span> page.evaluate(<span class="function">(<span class="params">scrollStep</span>) =&gt;</span> &#123;</span><br><span class="line">				<span class="keyword">let</span> scrollTop = <span class="built_in">document</span>.scrollingElement.scrollTop;</span><br><span class="line">				<span class="built_in">document</span>.scrollingElement.scrollTop = scrollTop + scrollStep;</span><br><span class="line">				<span class="keyword">return</span> <span class="built_in">document</span>.body.clientHeight &gt; scrollTop + <span class="number">1080</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line">			&#125;, scrollStep);</span><br><span class="line">			<span class="keyword">await</span> sleep(<span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">await</span> page.waitForSelector(<span class="string">"#footer-2014"</span>, &#123;<span class="attr">timeout</span>:<span class="number">0</span>&#125;); <span class="comment">//判断是否到达底部了</span></span><br><span class="line">		<span class="keyword">let</span> filename = <span class="string">"images/items-"</span>+i+<span class="string">".png"</span>;</span><br><span class="line">		<span class="comment">//这里有个Puppeteer的bug一直没有解决，发现截图的高度最大只能是16384px， 超出部分被截掉了。</span></span><br><span class="line">		<span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>:filename, <span class="attr">fullPage</span>:<span class="literal">true</span>&#125;);</span><br><span class="line">		page.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	browser.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="调试技巧"><a href="#调试技巧" class="headerlink" title="调试技巧"></a>调试技巧</h2><ul>
<li>关掉无界面模式，有时查看浏览器显示的内容是很有用的。使用以下命令可以启动完整版浏览器：  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;<span class="attr">headless</span>: <span class="literal">false</span>&#125;)</span><br></pre></td></tr></table></figure></li>
<li>减慢速度，slowMo选项以指定的毫秒减慢Puppeteer的操作。这是另一个看到发生了什么的方法：  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    headless:<span class="literal">false</span>,</span><br><span class="line">    slowMo:<span class="number">250</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li>捕获console的输出,通过监听console事件。在page.evaluate里调试代码时这也很方便：<pre><code class="js">page.on(<span class="string">'console'</span>, msg =&gt; <span class="built_in">console</span>.log(<span class="string">'PAGE LOG:'</span>, ...msg.args));
<span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`url is <span class="subst">${location.href}</span>`</span>));</code></pre>
</li>
<li>启动详细日志记录，所有公共API调用和内部协议流量都将通过puppeteer命名空间下的debug模块进行记录</li>
</ul>
]]></content>
      <categories>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoDB入门</title>
    <url>/2020/04/02/mongoDB%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="MongoDB介绍"><a href="#MongoDB介绍" class="headerlink" title="MongoDB介绍"></a>MongoDB介绍</h2><ul>
<li><p>MongoDB是一个NoSQL的数据库</p>
</li>
<li><p>MongoDB是一款文档型数据库</p>
</li>
<li><p>数据库指的就是一个存储数据的仓库<br>  数据库可以使我们完成对数据的持久化的操作</p>
</li>
<li><p>MongoDB数据库中存储的数据的基本单位就是文档，<br>  MongoDB中存储的就是文档，所谓文档其实就是一个“JSON”</p>
</li>
<li><p>MongoDB中的“JSON”我们称为BSON，比普通的JSON的功能要更加的强大</p>
</li>
<li><p>MongoDB数据库使用的是JavaScript进行操作的，在MongoDB含有一个对ES标准实现的引擎，<br>  在MongoDB中所有ES中的语法中都可以使用</p>
</li>
<li><p>MongoDB的基本的指令</p>
<ul>
<li>启动服务器<br>  mongod –dbpath 路径 –port 端口号</li>
<li>启动客户端<br>  mongo<a id="more"></a>
<h2 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h2></li>
</ul>
</li>
<li><p>安装</p>
</li>
<li><p>配置环境变量</p>
<ul>
<li>C:\Program Files\MongoDB\Server\3.2\bin</li>
</ul>
</li>
<li><p>在c盘根目录</p>
<ul>
<li>创建一个文件夹 data</li>
<li>在data中创建一个文件夹db</li>
</ul>
</li>
<li><p>启动mongodb服务器</p>
<ul>
<li>打开cmd命令行窗口</li>
<li>输入 <code>mongod</code> 启动mongodb服务器<ul>
<li>[ 参数 ] <code>mongod --dbpath 数据库路径 --port 端口号</code></li>
</ul>
</li>
<li>在打开一个cmd窗口</li>
<li>输入 mongo 连接mongodb ，出现 &gt;</li>
<li>成功</li>
</ul>
</li>
<li><p>数据库（database）</p>
<ul>
<li><p>数据库的服务器</p>
<ul>
<li>服务器用来保存数据</li>
<li>mongod 用来启动服务器</li>
</ul>
</li>
<li><p>数据库的客户端</p>
<ul>
<li>客户端用来操作服务器，对数据进行增删改查的操作</li>
<li>mongo 用来启动客户端</li>
</ul>
</li>
</ul>
</li>
<li><p>将MongoDB设置为系统服务，可以自动在后台启动，不需要每次都手动启动</p>
<ul>
<li><p>1.在c盘根目录创建data</p>
<ul>
<li>在data下创建db和log文件夹</li>
</ul>
</li>
<li><p>2 .创建配置文件<br>  在目录 C:\Program Files\MongoDB\Server\3.2 下添加一个配置文件<br>  mongod.cfg</p>
</li>
<li><p>3 .以管理员的身份打开命令行窗口    </p>
</li>
<li><p>4.执行如下的命令</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe create MongoDB binPath&#x3D; &quot;\&quot;C:\Program Files\MongoDB\Server\3.2\bin\mongod.exe\&quot; --service --config&#x3D;\&quot;C:\Program Files\MongoDB\Server\3.2\mongod.cfg\&quot;&quot; DisplayName&#x3D; &quot;MongoDB&quot; start&#x3D; &quot;auto&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sc.exe create MongoDB binPath&#x3D; &quot;\&quot;mongod的bin目录\mongod.exe\&quot; --service --config&#x3D;\&quot;mongo的安装目录\mongod.cfg\&quot;&quot; DisplayName&#x3D; &quot;MongoDB&quot; start&#x3D; &quot;auto&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.启动mongodb服务</p>
</li>
<li><p>6.如果启动失败，证明上边的操作有误，<br>  在控制台输入 sc delete MongoDB 删除之前配置的服务<br>  然后从第一步再来一次</p>
</li>
</ul>
</li>
<li><p>基本概念</p>
<ul>
<li>数据库（database）</li>
<li>集合（collection）</li>
<li>文档（document）<ul>
<li>在MongoDB中，数据库和集合都不需要手动创建，<br>  当我们创建文档时，如果文档所在的集合或数据库不存在会自动创建数据库和集合<h2 id="MongoDB的CRUD的操作"><a href="#MongoDB的CRUD的操作" class="headerlink" title="MongoDB的CRUD的操作"></a>MongoDB的CRUD的操作</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>基本指令</strong></p>
<ul>
<li><p>show dbs<br>show databases</p>
<ul>
<li>显示当前的所有数据库</li>
</ul>
</li>
<li><p>use 数据库名</p>
<ul>
<li>进入到指定的数据库中</li>
</ul>
</li>
<li><p>db</p>
<ul>
<li>db表示的是当前所处的数据库</li>
</ul>
</li>
<li><p>show collections</p>
<ul>
<li>显示数据库中所有的集合</li>
</ul>
</li>
</ul>
<h3 id="向数据库中插入文档"><a href="#向数据库中插入文档" class="headerlink" title="向数据库中插入文档"></a>向数据库中插入文档</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.insert()</span><br><span class="line">    - insert()可以向集合中插入一个或多个文档</span><br><span class="line">        - 当我们向集合中插入文档时，如果没有给文档指定_id属性，则数据库会自动为文档添加_id</span><br><span class="line">            该属性用来作为文档的唯一标识</span><br><span class="line">        - _id我们可以自己指定，如果我们指定了数据库就不会在添加了，如果自己指定_id 也必须确保它的唯一性</span><br><span class="line">    `例：`</span><br><span class="line">    db.stus.insert([</span><br><span class="line">     &#123;name:"沙和尚",age:38,gender:"男"&#125;,</span><br><span class="line">     &#123;name:"白骨精",age:16,gender:"女"&#125;,</span><br><span class="line">     &#123;name:"蜘蛛精",age:14,gender:"女"&#125;</span><br><span class="line">    ]);</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.insertOne()</span><br><span class="line">    - insert()向集合中插入一个文档</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.insertMany(</span><br><span class="line">    - insert()向集合中插入多个文档)</span><br></pre></td></tr></table></figure>

<h3 id="查询数据库中的文档"><a href="#查询数据库中的文档" class="headerlink" title="查询数据库中的文档"></a>查询数据库中的文档</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.find()</span><br><span class="line">    - 可以根据指定条件从集合中查询所有符合条件的文档</span><br><span class="line">	- 返回的是一个数组</span><br><span class="line">	`例子:`</span><br><span class="line">	db.stus.find(&#123;_id:"hello"&#125;);</span><br><span class="line">    db.stus.find(&#123;age:16 , name:"白骨精"&#125;);</span><br><span class="line">    db.stus.find(&#123;age:28&#125;);</span><br><span class="line">    db.stus.find(&#123;&#125;).count() 查询所有结果的数量</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.find()</span><br><span class="line">	- 可以根据指定条件从集合中查询所有符合条件的文档</span><br><span class="line">	- 返回的是一个数组</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.findOne()</span><br><span class="line">	- 查询第一个符合条件的文档</span><br><span class="line">	- 返回的是一个对象</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.find().count()</span><br><span class="line">	- 查询符合条件的文档的数量</span><br></pre></td></tr></table></figure>
<h3 id="修改数据库中的文档"><a href="#修改数据库中的文档" class="headerlink" title="修改数据库中的文档"></a>修改数据库中的文档</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.update(查询条件,新对象)</span><br><span class="line">	- 可以修改、替换集合中的一个或多个文档</span><br><span class="line">	- update()默认情况下会使用新对象来替换旧的对象</span><br><span class="line">        - 如果需要修改指定的属性，而不是替换需要使用“修改操作符”来完成修改</span><br><span class="line">            $set 可以用来修改文档中的指定属性</span><br><span class="line">            $unset 可以用来删除文档的指定属性</span><br><span class="line">        - update()默认只会修改一个</span><br><span class="line">        `例子：`</span><br><span class="line">        1、db.stus.update(&#123;name:"沙和尚"&#125;,&#123;age:28&#125;);</span><br><span class="line">        2、db.stus.update(</span><br><span class="line">            &#123;"_id" : ObjectId("59c219689410bc1dbecc0709")&#125;,</span><br><span class="line">            &#123;$set:&#123;</span><br><span class="line">                gender:"男",</span><br><span class="line">                address:"流沙河"</span><br><span class="line">            &#125;&#125;    </span><br><span class="line">        )</span><br><span class="line">        3、db.stus.update(</span><br><span class="line">            &#123;"_id" : ObjectId("59c219689410bc1dbecc0709")&#125;,</span><br><span class="line">            &#123;$unset:&#123;</span><br><span class="line">                address:1</span><br><span class="line">            &#125;&#125;    </span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.updateOne()</span><br><span class="line">	- 修改集合中的一个文档</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.updateMany()</span><br><span class="line">	- 修改集合中的多个文档</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.replaceOne()</span><br><span class="line">	- 替换集合中的一个文档</span><br></pre></td></tr></table></figure>
<h3 id="删除集合中的文档"><a href="#删除集合中的文档" class="headerlink" title="删除集合中的文档"></a>删除集合中的文档</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.remove()</span><br><span class="line">	- 删除集合中的一个或多个文档（默认删除多个）</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.deleteOne()</span><br><span class="line">	- 删除集合中的一个文档</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db.collection.deleteMany()</span><br><span class="line">	- 删除集合中的多个文档</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">清空一个集合</span><br><span class="line">	- db.collection.remove(&#123;&#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">删除一个集合</span><br><span class="line">	- db.collection.drop()</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">删除一个数据库</span><br><span class="line">	- db.dropDatabase()</span><br></pre></td></tr></table></figure>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//1.进入my_test数据库</span><br><span class="line">use my_test</span><br><span class="line"></span><br><span class="line">//2.向数据库的user集合中插入一个文档  </span><br><span class="line">db.users.insert(&#123;</span><br><span class="line">    username:"sunwukong"</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">//3.查询user集合中的文档</span><br><span class="line">db.users.find();</span><br><span class="line"></span><br><span class="line">//4.向数据库的user集合中插入一个文档   </span><br><span class="line">db.users.insert(&#123;</span><br><span class="line">    username:"zhubajie"</span><br><span class="line">&#125;);</span><br><span class="line">   </span><br><span class="line">//5.查询数据库user集合中的文档</span><br><span class="line">db.users.find();</span><br><span class="line"></span><br><span class="line">//6.统计数据库user集合中的文档数量</span><br><span class="line">db.users.find().count();</span><br><span class="line"></span><br><span class="line">//7.查询数据库user集合中username为sunwukong的文档</span><br><span class="line">db.users.find(&#123;username:"sunwukong"&#125;);</span><br><span class="line"></span><br><span class="line">//8.向数据库user集合中的username为sunwukong的文档，添加一个address属性，属性值为huaguoshan</span><br><span class="line">db.users.update(&#123;username:"sunwukong"&#125;,&#123;$set:&#123;address:"huaguoshan"&#125;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//9.使用&#123;username:"tangseng"&#125; 替换 username 为 zhubajie的文档</span><br><span class="line">db.users.replaceOne(&#123;username:"zhubajie"&#125;,&#123;username:"tangseng"&#125;);    </span><br><span class="line">    </span><br><span class="line">//10.删除username为sunwukong的文档的address属性</span><br><span class="line">db.users.update(&#123;username:"sunwukong"&#125;,&#123;$unset:&#123;address:1&#125;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//11.向username为sunwukong的文档中，添加一个hobby:&#123;cities:["beijing","shanghai","shenzhen"] , movies:["sanguo","hero"]&#125;</span><br><span class="line">//MongoDB的文档的属性值也可以是一个文档，当一个文档的属性值是一个文档时，我们称这个文档叫做 内嵌文档</span><br><span class="line">db.users.update(&#123;username:"sunwukong"&#125;,&#123;$set:&#123;hobby:&#123;cities:["beijing","shanghai","shenzhen"] , movies:["sanguo","hero"]&#125;&#125;&#125;);</span><br><span class="line">db.users.find();</span><br><span class="line"></span><br><span class="line">//12.向username为tangseng的文档中，添加一个hobby:&#123;movies:["A Chinese Odyssey","King of comedy"]&#125;</span><br><span class="line">db.users.update(&#123;username:"tangseng"&#125;,&#123;$set:&#123;hobby:&#123;movies:["A Chinese Odyssey","King of comedy"]&#125;&#125;&#125;)</span><br><span class="line"></span><br><span class="line">//13.查询喜欢电影hero的文档</span><br><span class="line">//MongoDB支持直接通过内嵌文档的属性进行查询，如果要查询内嵌文档则可以通过.的形式来匹配</span><br><span class="line">//如果要通过内嵌文档来对文档进行查询，此时属性名必须使用引号 </span><br><span class="line">db.users.find(&#123;'hobby.movies':"hero"&#125;);</span><br><span class="line"></span><br><span class="line">//14.向tangseng中添加一个新的电影Interstellar</span><br><span class="line"><span class="meta">//$</span><span class="bash">push 用于向数组中添加一个新的元素</span></span><br><span class="line"><span class="meta">//$</span><span class="bash">addToSet 向数组中添加一个新元素 ， 如果数组中已经存在了该元素，则不会添加</span></span><br><span class="line">db.users.update(&#123;username:"tangseng"&#125;,&#123;$push:&#123;"hobby.movies":"Interstellar"&#125;&#125;);</span><br><span class="line">db.users.update(&#123;username:"tangseng"&#125;,&#123;$addToSet:&#123;"hobby.movies":"Interstellar"&#125;&#125;);</span><br><span class="line">db.users.find();</span><br><span class="line"></span><br><span class="line">//15.删除喜欢beijing的用户</span><br><span class="line">db.users.remove(&#123;"hobby.cities":"beijing"&#125;);</span><br><span class="line"></span><br><span class="line">//16.删除user集合</span><br><span class="line">db.users.remove(&#123;&#125;);</span><br><span class="line">db.users.drop();</span><br><span class="line"></span><br><span class="line">show dbs;</span><br><span class="line"></span><br><span class="line">//17.向numbers中插入20000条数据 7.2s</span><br><span class="line">for(var i=1 ; i&lt;=20000 ; i++)&#123;</span><br><span class="line">    db.numbers.insert(&#123;num:i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.numbers.find()</span><br><span class="line"></span><br><span class="line">db.numbers.remove(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//0.4s</span><br><span class="line">var arr = [];</span><br><span class="line"></span><br><span class="line">for(var i=1 ; i&lt;=20000 ; i++)&#123;</span><br><span class="line">    arr.push(&#123;num:i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.numbers.insert(arr);</span><br><span class="line"></span><br><span class="line">//18.查询numbers中num为500的文档</span><br><span class="line">db.numbers.find(&#123;num:500&#125;)</span><br><span class="line"></span><br><span class="line">//19.查询numbers中num大于5000的文档</span><br><span class="line">db.numbers.find(&#123;num:&#123;$gt:500&#125;&#125;);</span><br><span class="line">db.numbers.find(&#123;num:&#123;$eq:500&#125;&#125;);</span><br><span class="line"></span><br><span class="line">//20.查询numbers中num小于30的文档</span><br><span class="line">db.numbers.find(&#123;num:&#123;$lt:30&#125;&#125;);</span><br><span class="line"></span><br><span class="line">//21.查询numbers中num大于40小于50的文档</span><br><span class="line">db.numbers.find(&#123;num:&#123;$gt:40 , $lt:50&#125;&#125;);</span><br><span class="line"></span><br><span class="line">//22.查询numbers中num大于19996的文档</span><br><span class="line">db.numbers.find(&#123;num:&#123;$gt:19996&#125;&#125;);</span><br><span class="line"></span><br><span class="line">//23.查看numbers集合中的前10条数据</span><br><span class="line">db.numbers.find(&#123;num:&#123;$lte:10&#125;&#125;);</span><br><span class="line"></span><br><span class="line">//limit()设置显示数据的上限</span><br><span class="line">db.numbers.find().limit(10);</span><br><span class="line">//在开发时，我们绝对不会执行不带条件的查询</span><br><span class="line">db.numbers.find();</span><br><span class="line"></span><br><span class="line">//24.查看numbers集合中的第11条到20条数据</span><br><span class="line">/*</span><br><span class="line">    分页 每页显示10条</span><br><span class="line">        1-10     0</span><br><span class="line">        11-20    10</span><br><span class="line">        21-30    20</span><br><span class="line">        。。。</span><br><span class="line">        </span><br><span class="line">        skip((页码-1) * 每页显示的条数).limit(每页显示的条数);</span><br><span class="line">        </span><br><span class="line">    skip()用于跳过指定数量的数据    </span><br><span class="line">    </span><br><span class="line">    MongoDB会自动调整skip和limit的位置</span><br><span class="line">*/</span><br><span class="line">db.numbers.find().skip(10).limit(10);</span><br><span class="line"></span><br><span class="line">//25.查看numbers集合中的第21条到30条数据</span><br><span class="line">db.numbers.find().skip(20).limit(10);</span><br><span class="line"></span><br><span class="line">db.numbers.find().limit(10).skip(10);</span><br><span class="line"></span><br><span class="line">//26.将dept和emp集合导入到数据库中</span><br><span class="line">db.dept.find()</span><br><span class="line">db.emp.find()</span><br><span class="line"></span><br><span class="line">//27.查询工资小于2000的员工</span><br><span class="line">db.emp.find(&#123;sal:&#123;$lt:2000&#125;&#125;);</span><br><span class="line"></span><br><span class="line">//28.查询工资在1000-2000之间的员工</span><br><span class="line">db.emp.find(&#123;sal:&#123;$lt:2000 , $gt:1000&#125;&#125;);</span><br><span class="line"></span><br><span class="line">//29.查询工资小于1000或大于2500的员工</span><br><span class="line">db.emp.find(&#123;$or:[&#123;sal:&#123;$lt:1000&#125;&#125; , &#123;sal:&#123;$gt:2500&#125;&#125;]&#125;);</span><br><span class="line"></span><br><span class="line">//30.查询财务部的所有员工</span><br><span class="line">//(depno)</span><br><span class="line">var depno = db.dept.findOne(&#123;dname:"财务部"&#125;).deptno;</span><br><span class="line">db.emp.find(&#123;depno:depno&#125;);</span><br><span class="line"></span><br><span class="line">//31.查询销售部的所有员工</span><br><span class="line">var depno = db.dept.findOne(&#123;dname:"销售部"&#125;).deptno;</span><br><span class="line">db.emp.find(&#123;depno:depno&#125;);</span><br><span class="line"></span><br><span class="line">//32.查询所有mgr为7698的所有员工</span><br><span class="line">db.emp.find(&#123;mgr:7698&#125;)</span><br><span class="line"></span><br><span class="line">//33.为所有薪资低于1000的员工增加工资400元</span><br><span class="line">db.emp.updateMany(&#123;sal:&#123;$lte:1000&#125;&#125; , &#123;$inc:&#123;sal:400&#125;&#125;);</span><br><span class="line">db.emp.find()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>mongoose入门</title>
    <url>/2020/03/30/mongoose%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>今天我们将学习Mongoose，什么是Mongoose呢，它于MongoDB又是什么关系呢，它可以用来做什么呢，介绍Mongoose之前，我们先简单了解一下MongoDB。</p>
<p>　<strong>Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具。本文将详细介绍如何使用Mongoose来操作MongoDB</strong></p>
<p>　　MongoDB是一个开源的NoSQL数据库，相比MySQL那样的关系型数据库，它更显得轻巧、灵活，非常适合在数据规模很大、事务性不强的场合下使用。同时它也是一个对象数据库，没有表、行等概念，也没有固定的模式和结构，所有的数据以文档的形式存储(文档，就是一个关联数组式的对象，它的内部由属性组成，一个属性对应的值可能是一个数、字符串、日期、数组，甚至是一个嵌套的文档。)，数据格式就是JSON。</p>
<p>介绍了MongoDB，我们下面就要认识Mongoose了。</p>
<p>Mongoose是什么？</p>
<p>　　Mongoose是MongoDB的一个对象模型工具，是基于node-mongodb-native开发的MongoDB nodejs驱动，可以在异步的环境下执行。同时它也是针对MongoDB操作的一个对象模型库，封装了MongoDB对文档的的一些增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。</p>
<p>Mongoose能做什么？</p>
<p>　　Mongoose，因为封装了对MongoDB对文档操作的常用处理方法，让NodeJS操作Mongodb数据库变得easy、easy、So easy!</p>
<p>　　学习了上面的介绍，相信你已经对Mongoose有了初步的认识和了解，千里之行，始于足下，奔跑吧，少年！</p>
<h2 id="安装引用"><a href="#安装引用" class="headerlink" title="安装引用"></a><strong>安装引用</strong></h2><p>前面我们已经认识了Mongoose，也了解了MongoDB，回顾一下：MongoDB是一个对象数据库，是用来存储数据的；Mongoose是封装了MongoDB操作的一个对象模型库,是用来操作这些数据的。</p>
<p>好，下面我们就来进行操作数据的第一步吧。</p>
<ol>
<li><p><strong>安装mongoose：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install mongoose</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>引用mongoose：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var mongoose = require("mongoose");</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用”mongoose”连接数据库：</strong></p>
</li>
</ol>
<p>使用connect()方法连接到MongoDB数据库<br>connect()最简单的使用方式，就是只要传入url参数即可，如下所示。连接到本地localhost的db1服务器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongoose.connect('mongodb://localhost/db1');</span><br></pre></td></tr></table></figure>

<p>如果还需要传递用户名、密码，则可以使用如下方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongoose.connect('mongodb://username:password@host:port/database?options...');</span><br></pre></td></tr></table></figure>
<p>  connect()方法还接受一个选项对象options，该对象将传递给底层驱动程序。这里所包含的所有选项优先于连接字符串中传递的选项</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongoose.connect(uri, options);</span><br></pre></td></tr></table></figure>
<p>可用选项如下所示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">db            -数据库设置</span><br><span class="line">server        -服务器设置</span><br><span class="line">replset       -副本集设置</span><br><span class="line">user          -用户名</span><br><span class="line">pass          -密码</span><br><span class="line">auth          -鉴权选项</span><br><span class="line">mongos        -连接多个数据库</span><br><span class="line">promiseLibrary</span><br></pre></td></tr></table></figure>
<p> <strong>栗子 :</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> var options = &#123;</span><br><span class="line">  db: &#123; native_parser: true &#125;,</span><br><span class="line">  server: &#123; poolSize: 5 &#125;,</span><br><span class="line">  replset: &#123; rs_name: 'myReplicaSetName' &#125;,</span><br><span class="line">  user: 'myUserName',</span><br><span class="line">  pass: 'myPassword'</span><br><span class="line">&#125;</span><br><span class="line">mongoose.connect(uri, options);</span><br></pre></td></tr></table></figure>
<p>如果要连接多个数据库，只需要设置多个url以,隔开，同时设置mongos为true</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongoose.connect('urlA,urlB,...', &#123;</span><br><span class="line">   mongos : true </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>connect()函数还接受一个回调参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mongoose.connect(uri, options, function(error) &#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行下列代码后，控制台输出“连接成功”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var mongoose = require('mongoose');</span><br><span class="line">mongoose.connect("mongodb://localhost/test", function(err) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log('连接失败');</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log('连接成功');</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p> <strong>栗子 :</strong><br> <strong>如果开启鉴权控制，以用户名”u1”，密码”123456”登录’db1’数据库。执行代码后，控制台输出“连接成功”</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> var mongoose = require('mongoose');</span><br><span class="line">mongoose.connect("mongodb://u1:123456@localhost/db1", function(err) &#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">        console.log('连接失败');</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        console.log('连接成功');</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>执行下面代码检查默认数据库test，是否可以正常连接成功?</strong><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var mongoose = require("mongoose");</span><br><span class="line">var db = mongoose.connect("mongodb://127.0.0.1:27017/test");</span><br><span class="line">db.connection.on("error", function (error) &#123;</span><br><span class="line">    console.log("数据库连接失败：" + error);</span><br><span class="line">&#125;);</span><br><span class="line">db.connection.on("open", function () &#123;</span><br><span class="line">    console.log("------数据库连接成功！------");</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>栗子：</strong></p>
<ul>
<li>1、使用require()方法引入mongodb数据库；然后使用MongoClient对象的connect()方法连接mongodb；最后通过node来对mongodb进行异步的增删改查</li>
<li>2、在mongodb数据库中建立db1数据库，然后通过以下代码，建立col集合，并插入{“a”:1}文档<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var mongodb = require('mongodb');</span><br><span class="line">mongodb.MongoClient.connect("mongodb://localhost/db1",function(err,db)&#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        db.collection("col").insert(&#123;"a":1&#125;,function(err,result)&#123;</span><br><span class="line">            if(!err)&#123;</span><br><span class="line">                console.log(result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
最后返回结果如下<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    result: &#123;</span><br><span class="line">        ok: 1,</span><br><span class="line">        n: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    ops: [&#123;</span><br><span class="line">        a: 1,</span><br><span class="line">        _id: 597077 dc271d092728caa362</span><br><span class="line">    &#125;],</span><br><span class="line">    insertedCount: 1,</span><br><span class="line">    insertedIds: [597077 dc271d092728caa362]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a><strong>概念理解</strong></h2><p>Mongoose是NodeJS的驱动，不能作为其他语言的驱动。Mongoose有两个特点</p>
<ul>
<li><p>1、通过关系型数据库的思想来设计非关系型数据库</p>
</li>
<li><p>2、基于mongodb驱动，简化操作</p>
</li>
</ul>
<p><img src="http://static.zybuluo.com/wp0214/jktjwns8ieb1iwtwrkj4jnvh/image_1c3vgq5iem5i1u6p18gi1l1h1gi9.png" alt="!\[\](images/screenshot_1516091179384.png)"></p>
<p> Mongooose中，有三个比较重要的概念，分别是Schema、Model、Entity。<br> 它们的关系是：</p>
<blockquote>
<p>Schema生成Model<br>Model创造Document<br>Model和Document都可对数据库操作造成影响，但Model比Document更具操作性</p>
</blockquote>
<p>Schema用于定义数据库的结构。类似创建表时的数据定义(不仅仅可以定义文档的结构和属性，还可以定义文档的实例方法、静态模型方法、复合索引等)，每个Schema会映射到mongodb中的一个collection，Schema不具备操作数据库的能力</p>
<p>Model是由Schema编译而成的构造器，具有抽象属性和行为，可以对数据库进行增删查改。Model的每一个实例（instance）就是一个文档document</p>
<p>Document是由Model创建的实体，它的操作也会影响数据库</p>
<h2 id="了解集合collection"><a href="#了解集合collection" class="headerlink" title="了解集合collection"></a><strong>了解集合collection</strong></h2><p>通过上节课程的学习我们已经打下了基础，本节课程就开始对MongoDB数据库进行具体操作。首先，我们再次简单介绍一下MongoDB数据库。</p>
<p>　　MongoDB —— 是一个对象数据库，没有表、行等概念，也没有固定的模式和结构，所有的数据以Document(以下简称文档)的形式存储(Document，就是一个关联数组式的对象，它的内部由属性组成，一个属性对应的值可能是一个数、字符串、日期、数组，甚至是一个嵌套的文档。)，后面我们会学习如何创建文档并插入内容。</p>
<p>　　<strong>在MongoDB中，多个Document可以组成Collection(以下简称集合)，多个集合又可以组成数据库。</strong></p>
<p>　　我们想要操作MongoDB数据，那就得先要具备上面所说的包含数据的<code>文档</code>，文档又是什么意思呢，请看如下介绍。</p>
<p>　　<strong>文档</strong> —— 是MongoDB的核心概念，是键值对的一个有序集，在JavaScript里文档被表示成对象。同时它也是MongoDB中数据的基本单元，非常类似于关系型数据库管理系统中的行，但更具表现力。</p>
<p>　　<strong>集合</strong> —— 由一组文档组成，如果将MongoDB中的一个文档比喻成关系型数据库中的一行，那么一个集合就相当于一张表。</p>
<p>　　如果我们要通过Mongoose去创建一个“集合”并对其进行增删改查，该怎么实现呢，到这里我们就要先了解Schema(数据属性模型)、Model、Entity了。</p>
<p>  好，下面就开始去深入了解它们吧！</p>
<h2 id="模型骨架Schema"><a href="#模型骨架Schema" class="headerlink" title="模型骨架Schema"></a><strong>模型骨架Schema</strong></h2><p><strong>Schema</strong> —— 一种以文件形式存储的数据库模型骨架，无法直接通往数据库端，也就是说它不具备对数据库的操作能力，仅仅只是数据库模型在程序片段中的一种表现，可以说是数据属性模型(传统意义的表结构)，又或着是“集合”的模型骨架。</p>
<p><strong>Schema主要用于定义MongoDB中集合Collection里文档document的结构</strong></p>
<p>定义Schema非常简单，指定字段名和类型即可，支持的类型包括以下8种</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">String      字符串</span><br><span class="line">Number      数字    </span><br><span class="line">Date        日期</span><br><span class="line">Buffer      二进制</span><br><span class="line">Boolean     布尔值</span><br><span class="line">Mixed       混合类型</span><br><span class="line">ObjectId    对象ID    </span><br><span class="line">Array       数组</span><br></pre></td></tr></table></figure>

<p><strong>通过mongoose.Schema来调用Schema，然后使用new方法来创建schema对象</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var mongoose = require('mongoose');</span><br><span class="line"></span><br><span class="line">var Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line">var mySchema = new Schema(&#123;</span><br><span class="line">  title:  String,</span><br><span class="line">  author: String,</span><br><span class="line">  body:   String,</span><br><span class="line">  comments: [&#123; body: String, date: Date &#125;],</span><br><span class="line">  date: &#123; type: Date, default: Date.now &#125;,	//类型为日期，默认为当前时间</span><br><span class="line">  hidden: Boolean,</span><br><span class="line">  meta: &#123;</span><br><span class="line">    votes: Number,</span><br><span class="line">    favs:  Number</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>创建Schema对象时，声明字段类型有两种方法，一种是首字母大写的字段类型，另一种是引号包含的小写字段类型</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var mySchema = new Schema(&#123;title:String, author:String&#125;);</span><br><span class="line">//或者 </span><br><span class="line">var mySchema = new Schema(&#123;title:'string', author:'string'&#125;);</span><br></pre></td></tr></table></figure>

<p>如果需要在Schema定义后添加其他字段，可以使用add()方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var MySchema = new Schema();</span><br><span class="line">MySchema.add(&#123; name: 'string', color: 'string', price: 'number' &#125;);</span><br></pre></td></tr></table></figure>


<h2 id="模型Model"><a href="#模型Model" class="headerlink" title="模型Model"></a><strong>模型Model</strong></h2><p><strong>模型Model是根据Schema编译出的构造器，或者称为类，通过Model可以实例化出文档对象document</strong></p>
<p>文档document的创建和检索都需要通过模型Model来处理</p>
<p>如何通过Schema来创建Model呢，如下示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mongoose.model(<span class="string">'test1'</span>,<span class="string">'TestSchema'</span>)</span><br></pre></td></tr></table></figure>
<p><strong>test1：数据库中的集合名称,当我们对其添加数据时如果test1已经存在，则会保存到其目录下，如果未存在，则会创建test1集合，然后在保存数据。</strong></p>
<p>拥有了Model，我们也就拥有了操作数据库的金钥匙，就可使用Model来进行增删改查的具体操作，</p>
<p>如果你想对某个集合有所作为，那就交给Model模型来处理吧，<br>创建一个Model模型，我们需要指定：<br>1、集合名称<br>2、集合的Schema结构对象</p>
<p>满足这两个条件，我们就会拥有一个操作数据库的金钥匙。</p>
<p><strong>栗子</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TestSchema = <span class="keyword">new</span> mongoose.Schema(&#123; </span><br><span class="line">    num:<span class="built_in">Number</span>, </span><br><span class="line">    name: <span class="built_in">String</span>, </span><br><span class="line">    size: <span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> MyModel = mongoose.model(<span class="string">'MyModel'</span>, TestSchema);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>　Mongoose会将集合名称设置为模型名称的小写版。如果名称的最后一个字符是字母，则会变成复数；如果名称的最后一个字符是数字，则不变；如果模型名称为”MyModel”，则集合名称为”mymodels”；如果模型名称为”Model1”，则集合名称为”model1”</p>
</blockquote>
<h2 id="实例Entity"><a href="#实例Entity" class="headerlink" title="实例Entity"></a><strong>实例Entity</strong></h2><p>通过对原型Model使用new方法，实例化出文档document对象</p>
<p><strong>document</strong> —— 由Model创建的实体，使用save方法保存数据，Model和document都有能影响数据库的操作，但Model比document更具操作性。</p>
<p>使用Model创建实例Entity，如下示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> TestEntity = <span class="keyword">new</span> TestModel(&#123;</span><br><span class="line">       name : <span class="string">"Lenka"</span>,</span><br><span class="line">       age  : <span class="number">36</span>,</span><br><span class="line">       email: <span class="string">"lenka@qq.com"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(TestEntity.name); <span class="comment">// Lenka</span></span><br><span class="line"><span class="built_in">console</span>.log(TestEntity.age); <span class="comment">// 36</span></span><br></pre></td></tr></table></figure>

<p><strong>通过对原型Model使用new方法，实例化出文档document对象</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">mongoose.connect(<span class="string">"mongodb://u1:123456@localhost/db1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'连接失败'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'连接成功'</span>);</span><br><span class="line">        <span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123; <span class="comment">//定义骨架</span></span><br><span class="line">            num:<span class="built_in">Number</span>, </span><br><span class="line">            name: <span class="built_in">String</span>, </span><br><span class="line">            size: <span class="built_in">String</span></span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> MyModel = mongoose.model(<span class="string">'MyModel'</span>, schema);<span class="comment">//应用模型</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> doc1 = <span class="keyword">new</span> MyModel(&#123; <span class="attr">size</span>: <span class="string">'small'</span> &#125;);	<span class="comment">//使用new方法，实例化出文档document对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="built_in">console</span>.log(doc1.size);	<span class="comment">//'small'</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>文档保存</strong></p>
<p>　通过 以上 new MyModel()创建的文档doc1，必须通过save()方法，才能将创建的文档保存到数据库的集合中，集合名称为模型名称的小写复数版</p>
<p>回调函数是可选项，第一个参数为err，第二个参数为保存的文档对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">save(<span class="function"><span class="keyword">function</span> (<span class="params">err, doc</span>) </span>&#123; &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"></span><br><span class="line">mongoose.connect(<span class="string">"mongodb://u1:123456@localhost/db1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">            num:<span class="built_in">Number</span>, </span><br><span class="line">            name: <span class="built_in">String</span>,</span><br><span class="line">            size: <span class="built_in">String</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">var</span> MyModel = mongoose.model(<span class="string">'MyModel'</span>, schema);</span><br><span class="line">        <span class="keyword">var</span> doc1 = <span class="keyword">new</span> MyModel(&#123; <span class="attr">size</span>: <span class="string">'small'</span> &#125;);</span><br><span class="line">        doc1.save(<span class="function"><span class="keyword">function</span> (<span class="params">err,doc</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//&#123; __v: 0, size: 'small', _id: 5970daba61162662b45a24a1 &#125;</span></span><br><span class="line">          <span class="built_in">console</span>.log(doc);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>由下所示，db1数据库中的集合名称为mymodels，里面有一个{size:”small”}的文档<br><img src="http://static.zybuluo.com/wp0214/jktjwns8ieb1iwtwrkj4jnvh/image_1c3vgq5iem5i1u6p18gi1l1h1gi9.png" alt="image_1c3vhncrl1mtoh4o131h1dfd8379.png-4.7kB"></p>
<h2 id="文档新增"><a href="#文档新增" class="headerlink" title="文档新增"></a><strong>文档新增</strong></h2><p><strong>文档新增常用方法:</strong></p>
<ul>
<li>一种是使用文档的<code>save()</code>方法，</li>
<li>另一种是使用模型model的<code>create()</code>方法，</li>
<li>一种是模型model的<code>insertMany()</code>方法    </li>
</ul>
<p><strong>save()</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Entity.save([options], [options.safe], [options.validateBeforeSave], [fn])</span><br></pre></td></tr></table></figure>
<p><strong>栗子</strong><br> 新建{age:10,name:’save’}文档，并保存</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"></span><br><span class="line">mongoose.connect(<span class="string">"mongodb://u1:123456@localhost/db1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123; </span><br><span class="line">            age:<span class="built_in">Number</span>, </span><br><span class="line">            name: <span class="built_in">String</span></span><br><span class="line">        &#125;);        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> temp = mongoose.model(<span class="string">'temp'</span>, schema);</span><br><span class="line">        <span class="comment">//使用链式写法    </span></span><br><span class="line">        <span class="keyword">new</span> temp(&#123;<span class="attr">age</span>:<span class="number">10</span>,<span class="attr">name</span>:<span class="string">'save'</span>&#125;).save(<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//[ &#123; _id: 59720bc0d2b1125cbcd60b3f, age: 10, name: 'save', __v: 0 &#125; ]</span></span><br><span class="line">            <span class="built_in">console</span>.log(doc);        </span><br><span class="line">        &#125;);         </span><br><span class="line">    &#125;           </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>create()</strong><br>使用save()方法，需要先实例化为文档，再使用save()方法保存文档。<br>而create()方法，则直接在模型Model上操作，并且可以同时新增多个文档</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Model.create(doc(s), [callback])</span><br></pre></td></tr></table></figure>
<p><strong>栗子</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">mongoose.connect(<span class="string">"mongodb://u1:123456@localhost/db1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">            age:<span class="built_in">Number</span>, </span><br><span class="line">            name: <span class="built_in">String</span></span><br><span class="line">        &#125;);        </span><br><span class="line">        <span class="keyword">var</span> temp = mongoose.model(<span class="string">'temp'</span>, schema);   </span><br><span class="line">        temp.create(</span><br><span class="line">            &#123;<span class="attr">name</span>:<span class="string">"xiaowang"</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">name</span>:<span class="string">"xiaoli"</span>&#125;,</span><br><span class="line">            <span class="function"><span class="keyword">function</span>(<span class="params">err,doc1,doc2</span>)</span>&#123;</span><br><span class="line">                <span class="comment">//&#123; __v: 0, name: 'xiaowang', _id: 59720d83ad8a953f5cd04664 &#125;</span></span><br><span class="line">                <span class="built_in">console</span>.log(doc1); </span><br><span class="line">                <span class="comment">//&#123; __v: 0, name: 'xiaoli', _id: 59720d83ad8a953f5cd04665 &#125;</span></span><br><span class="line">                <span class="built_in">console</span>.log(doc2); </span><br><span class="line">        &#125;);       </span><br><span class="line">    &#125;           </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>insertMany()</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Model.insertMany(doc(s), [options], [callback])</span><br></pre></td></tr></table></figure>

<p><strong>栗子</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">mongoose.connect(<span class="string">"mongodb://u1:123456@localhost/db1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123; </span><br><span class="line">            age:<span class="built_in">Number</span>, </span><br><span class="line">            name: <span class="built_in">String</span></span><br><span class="line">        &#125;);        </span><br><span class="line">        <span class="keyword">var</span> temp = mongoose.model(<span class="string">'temp'</span>, schema);   </span><br><span class="line">        temp.insertMany([</span><br><span class="line">            &#123;<span class="attr">name</span>:<span class="string">"a"</span>&#125;,</span><br><span class="line">            &#123;<span class="attr">name</span>:<span class="string">"b"</span>&#125;</span><br><span class="line">      	  ],</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//[ &#123; __v: 0, name: 'a', _id: 59720ea1bbf5792af824b30c &#125;,</span></span><br><span class="line">            <span class="comment">//&#123; __v: 0, name: 'b', _id: 59720ea1bbf5792af824b30d &#125; ]</span></span><br><span class="line">            <span class="built_in">console</span>.log(docs); </span><br><span class="line">        &#125;);       </span><br><span class="line">    &#125;           </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="文档查询"><a href="#文档查询" class="headerlink" title="文档查询"></a><strong>文档查询</strong></h2><p>查询就是返回一个集合中的文档的子集，Mongoose 模型提供了find、findOne、和findById方法用于文档查询。</p>
<p>使用Mongoose来查找文档很容易，有以下几种方法可供选择</p>
<ul>
<li>find()</li>
<li>findById()</li>
<li>findOne()</li>
</ul>
<p><strong>find()</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Model.find(conditions, [projection], [options], [callback])</span><br></pre></td></tr></table></figure>
<p>   第一个参数表示查询条件，第二个参数用于控制返回的字段，第三个参数用于配置查询参数，第四个参数是回调函数，回调函数的形式为function(err,docs){}</p>
<p><strong>栗子</strong><br>现在，使用find()方法找出所有数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mongoose &#x3D; require(&#39;mongoose&#39;);</span><br><span class="line">mongoose.connect(&quot;mongodb:&#x2F;&#x2F;u1:123456@localhost&#x2F;db1&quot;, function(err) &#123;</span><br><span class="line">    if(!err)&#123;</span><br><span class="line">        var schema &#x3D; new mongoose.Schema(&#123; age:Number, name: String&#125;);        </span><br><span class="line">        var temp &#x3D; mongoose.model(&#39;temp&#39;, schema);</span><br><span class="line">        temp.find(&#123;&#125;,function(err,docs)&#123;</span><br><span class="line">            &#x2F;&#x2F;若没有向find传递参数，默认的是显示所有文档</span><br><span class="line">        	 console.log(docs);</span><br><span class="line">            &#x2F;&#x2F;[ &#123; _id: 5971f93be6f98ec60e3dc86c, name: &#39;huochai&#39;, age: 27 &#125;,</span><br><span class="line">            &#x2F;&#x2F;&#123; _id: 5971f93be6f98ec60e3dc86d, name: &#39;wang&#39;, age: 18 &#125;,</span><br><span class="line">            &#x2F;&#x2F;&#123; _id: 5971f93be6f98ec60e3dc86e, name: &#39;huo&#39;, age: 30 &#125;,</span><br><span class="line">            &#x2F;&#x2F;&#123; _id: 5971f93be6f98ec60e3dc86f, name: &#39;li&#39;, age: 12 &#125; ]</span><br><span class="line">          </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>找出年龄大于18的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find(&#123;age:&#123;$gte:18&#125;&#125;,function(err,docs)&#123;</span><br><span class="line">     console.log(docs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>找出年龄小于18的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find(&#123;age:&#123;$lt:18&#125;&#125;,function(err,docs)&#123;</span><br><span class="line">     console.log(docs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>查询所有nage大于18小于60的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find(&#123;&quot;age&quot;:&#123;&quot;$gt&quot;:18,&quot;$lt&quot;:60&#125;&#125;,function(error,docs)&#123;</span><br><span class="line">   &#x2F;&#x2F;查询所有nage大于18小于60的数据</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>找出年龄大于18且名字里存在’huo’的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find(&#123;name:&#x2F;huo&#x2F;,age:&#123;$gte:18&#125;&#125;,function(err,docs)&#123;</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>找出名字里存在’a’的数据，且只输出’name’字段<br><em>注意id字段默认输出</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find(&#123;name:&#x2F;a&#x2F;&#125;,&#39;name&#39;,function(err,docs)&#123;</span><br><span class="line">    &#x2F;&#x2F;[ &#123; _id: 5971f93be6f98ec60e3dc86c, name: &#39;huochai&#39; &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5971f93be6f98ec60e3dc86d, name: &#39;wang&#39; &#125; ]</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果确实不需要_id字段输出，可以进行如下设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find(&#123;name:&#x2F;a&#x2F;&#125;,&#123;name:1,_id:0&#125;,function(err,docs)&#123;</span><br><span class="line">    &#x2F;&#x2F;[ &#123; name: &#39;huochai&#39; &#125;, &#123; name: &#39;wang&#39; &#125; ]</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>找出跳过前两条数据的其他所有数据<br><em>如果使用第三个参数，前两个参数如果没有值，需要设置为null</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find(null,null,&#123;skip:2&#125;,function(err,docs)&#123;</span><br><span class="line">    &#x2F;&#x2F;[ &#123; _id: 5971f93be6f98ec60e3dc86e, name: &#39;huo&#39;, age: 30 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5971f93be6f98ec60e3dc86f, name: &#39;li&#39;, age: 12 &#125; ]</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>findById()</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Model.findById(id, [projection], [options], [callback])</span><br></pre></td></tr></table></figure>
<p>显示第0个元素的所有字段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aIDArr = [];</span><br><span class="line">temp.find(<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">    docs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line">        aIDArr.push(item._id);</span><br><span class="line">    &#125;)</span><br><span class="line">    temp.findById(aIDArr[<span class="number">0</span>],<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//&#123; _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 &#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(doc);</span><br><span class="line">    &#125;)            </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以上代码的另一种写法如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> aIDArr = [];</span><br><span class="line">temp.find(<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">    docs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line">        aIDArr.push(item._id);</span><br><span class="line">    &#125;)</span><br><span class="line">    temp.findById(aIDArr[<span class="number">0</span>]).exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//&#123; _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 &#125;</span></span><br><span class="line">        <span class="built_in">console</span>.log(doc);</span><br><span class="line">    &#125;)            </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>只输出name字段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.findById(aIDArr[<span class="number">0</span>],&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">_id</span>:<span class="number">0</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123;  name: 'huochai'&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(doc);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>或者写成下面这种形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.findById(aIDArr[<span class="number">0</span>],&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">_id</span>:<span class="number">0</span>&#125;).exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123;  name: 'huochai'&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(doc);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>输出最少的字段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.findById(aIDArr[<span class="number">0</span>],&#123;<span class="attr">lean</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123; _id: 5971f93be6f98ec60e3dc86c &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(doc);</span><br><span class="line">&#125;)   </span><br><span class="line">temp.findById(aIDArr[<span class="number">0</span>],&#123;<span class="attr">lean</span>:<span class="literal">true</span>&#125;).exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123; _id: 5971f93be6f98ec60e3dc86c &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(doc);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>findOne()</strong><br>该方法返回查找到的所有实例的第一个</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Model.findOne([conditions], [projection], [options], [callback])</span><br></pre></td></tr></table></figure>

<p>找出age&gt;20的文档中的第一个文档</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.findOne(&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span> : <span class="number">20</span>&#125;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123; _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(doc);</span><br><span class="line">&#125;)   </span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">temp.findOne(&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span> : <span class="number">20</span>&#125;&#125;).exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123; _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 27 &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(doc);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>找出age&gt;20的文档中的第一个文档，且只输出name字段</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.findOne(&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span> : <span class="number">20</span>&#125;&#125;,&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">_id</span>:<span class="number">0</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123; name: 'huochai' &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(doc);</span><br><span class="line">&#125;)   </span><br><span class="line">或者</span><br><span class="line">temp.findOne(&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span> : <span class="number">20</span>&#125;&#125;,&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">_id</span>:<span class="number">0</span>&#125;).exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123; name: 'huochai' &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(doc);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>文档查询常用的查询条件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$or　　　　或关系</span><br><span class="line">$nor　　　 或关系取反</span><br><span class="line">$gt　　　　大于</span><br><span class="line">$gte　　　 大于等于</span><br><span class="line">$lt　　　　小于</span><br><span class="line">$lte　　　 小于等于</span><br><span class="line">$ne　　　　不等于</span><br><span class="line">$<span class="keyword">in</span>　　　　在多个值范围内</span><br><span class="line">$nin　　　 不在多个值范围内</span><br><span class="line">$all　　　 匹配数组中多个值</span><br><span class="line">$regex　　 正则，用于模糊查询</span><br><span class="line">$size　　　匹配数组大小</span><br><span class="line">$maxDistance　范围查询，距离（基于LBS）</span><br><span class="line">$mod　　　　取模运算</span><br><span class="line">$near　　　 邻域查询，查询附近的位置（基于LBS）</span><br><span class="line">$exists　　 字段是否存在</span><br><span class="line">$elemMatch　匹配内数组内的元素</span><br><span class="line">$within　　　范围查询（基于LBS）</span><br><span class="line">$box　　　　 范围查询，矩形范围（基于LBS）</span><br><span class="line">$center　　　范围醒询，圆形范围（基于LBS）</span><br><span class="line">$centerSphere　范围查询，球形范围（基于LBS）</span><br><span class="line">$slice　　　　查询字段集合中的元素（比如从第几个之后，第N到第M个元素</span><br></pre></td></tr></table></figure>
<p>###<strong>$where</strong></p>
<p>如果要进行更复杂的查询，需要使用<code>$where</code>操作符，<code>$where</code>操作符功能强大而且灵活，它可以使用任意的JavaScript作为查询的一部分，包含JavaScript表达式的字符串或者JavaScript函数</p>
<p>目前数据：<br><img src="http://static.zybuluo.com/wp0214/jktjwns8ieb1iwtwrkj4jnvh/image_1c3vgq5iem5i1u6p18gi1l1h1gi9.png" alt="image_1c3vjh8s51cvu95vv051ci21hjq9.png-8.6kB"></p>
<p><strong>使用字符串</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*查询当条数据的x值等于当条数据y值的文档*/</span></span><br><span class="line">temp.find(&#123;<span class="attr">$where</span>:<span class="string">"this.x == this.y"</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//[ &#123; _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 &#125;,</span></span><br><span class="line">    <span class="comment">//&#123; _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 &#125; ]</span></span><br><span class="line">    <span class="built_in">console</span>.log(docs);</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line">temp.find(&#123;<span class="attr">$where</span>:<span class="string">"obj.x == obj.y"</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//[ &#123; _id: 5972ed35e6f98ec60e3dc887,name: 'wang',age: 18,x: 1,y: 1 &#125;,</span></span><br><span class="line">    <span class="comment">//&#123; _id: 5972ed35e6f98ec60e3dc889, name: 'li', age: 20, x: 2, y: 2 &#125; ]</span></span><br><span class="line">    <span class="built_in">console</span>.log(docs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>使用函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.find(&#123;<span class="attr">$where</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj.x !== obj.y;</span><br><span class="line">    &#125;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//[ &#123; _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 &#125;,</span></span><br><span class="line">    <span class="comment">//&#123; _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 &#125; ]</span></span><br><span class="line">    <span class="built_in">console</span>.log(docs);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"></span><br><span class="line">temp.find(&#123;<span class="attr">$where</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x !== <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//[ &#123; _id: 5972ed35e6f98ec60e3dc886,name: 'huochai',age: 27,x: 1,y: 2 &#125;,</span></span><br><span class="line">    <span class="comment">//&#123; _id: 5972ed35e6f98ec60e3dc888, name: 'huo', age: 30, x: 2, y: 1 &#125; ]</span></span><br><span class="line">    <span class="built_in">console</span>.log(docs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="文档修改"><a href="#文档修改" class="headerlink" title="文档修改"></a>文档修改</h2><p>文档更新可以使用以下几种方法</p>
<ul>
<li>update()</li>
<li>updateMany()</li>
<li>find() + save()</li>
<li>updateOne()</li>
<li>findOne() + save()</li>
<li>findByIdAndUpdate()</li>
<li>fingOneAndUpdate()</li>
</ul>
<h3 id="update"><a href="#update" class="headerlink" title="update()"></a><strong>update()</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Model.update(conditions, doc, [options], [callback])</span><br></pre></td></tr></table></figure>
<blockquote>
<p>第一个参数conditions为查询条件<br>第二个参数doc为需要修改的数据<br>第三个参数options为控制选项<br>第四个参数是回调函数</p>
</blockquote>
<p>options有如下选项</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">safe (boolean)： 默认为<span class="literal">true</span>。安全模式。</span><br><span class="line">　　upsert (boolean)： 默认为<span class="literal">false</span>。如果不存在则创建新记录。</span><br><span class="line">　　multi (boolean)： 默认为<span class="literal">false</span>。是否更新多个查询记录。</span><br><span class="line">　　runValidators： 如果值为<span class="literal">true</span>，执行Validation验证。</span><br><span class="line">　　setDefaultsOnInsert： 如果upsert选项为<span class="literal">true</span>，在新建时插入文档定义的默认值。</span><br><span class="line">　　strict (boolean)： 以strict模式进行更新。</span><br><span class="line">　　overwrite (boolean)： 默认为<span class="literal">false</span>。禁用update-only模式，允许覆盖记录。</span><br></pre></td></tr></table></figure>
<p>数据库temps中现有数据如下:<br><img src="http://static.zybuluo.com/wp0214/jktjwns8ieb1iwtwrkj4jnvh/image_1c3vgq5iem5i1u6p18gi1l1h1gi9.png" alt="image_1c3vkaq1ui8k2k015orkjt1ia79.png-7.2kB"></p>
<p>现在使用update()方法查询age大于20的数据，并将其年龄更改为40岁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">mongoose.connect(<span class="string">"mongodb://u1:123456@localhost/db1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123; <span class="attr">age</span>:<span class="built_in">Number</span>, <span class="attr">name</span>: <span class="built_in">String</span>&#125;);        </span><br><span class="line">        <span class="keyword">var</span> temp = mongoose.model(<span class="string">'temp'</span>, schema);   </span><br><span class="line">        temp.update(&#123;<span class="attr">age</span>:&#123;<span class="attr">$gte</span>:<span class="number">20</span>&#125;&#125;,&#123;<span class="attr">age</span>:<span class="number">40</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,raw</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//&#123; n: 1, nModified: 1, ok: 1 &#125;</span></span><br><span class="line">            <span class="built_in">console</span>.log(raw);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;           </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>经过以上操作，数据库结果如下。只有第一个数据更改为40岁。而第三个数据没有发生变化<br><img src="http://static.zybuluo.com/wp0214/qyfdsm8pkaf13ljhoqvdjpo7/image_1c3vkdd629khvjlnn11cv5inem.png" alt="image_1c3vkdd629khvjlnn11cv5inem.png-7.2kB"></p>
<p>如果要同时更新多个记录，需要设置options里的multi为true。下面将名字中有’a’字符的年龄设置为10岁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">mongoose.connect(<span class="string">"mongodb://u1:123456@localhost/db1"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!err)&#123;</span><br><span class="line">        <span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123; <span class="attr">age</span>:<span class="built_in">Number</span>, <span class="attr">name</span>: <span class="built_in">String</span>&#125;);        </span><br><span class="line">        <span class="keyword">var</span> temp = mongoose.model(<span class="string">'temp'</span>, schema);   </span><br><span class="line">        temp.update(&#123;<span class="attr">name</span>:<span class="regexp">/a/</span>&#125;,&#123;<span class="attr">age</span>: <span class="number">10</span>&#125;,&#123;<span class="attr">multi</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,raw</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//&#123; n: 2, nModified: 2, ok: 1 &#125;</span></span><br><span class="line">            <span class="built_in">console</span>.log(raw);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;           </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>结果<br><img src="http://static.zybuluo.com/wp0214/hbqtyngmqo2qsyx1lr7n4muk/image_1c3vkrfahu171gp9u8pmms16i713.png" alt="image_1c3vkrfahu171gp9u8pmms16i713.png-7.4kB"></p>
<p>如果设置的查找条件，数据库里的数据并不满足，默认什么事都不发生</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.update(&#123;<span class="attr">age</span>:<span class="number">100</span>&#125;,&#123;<span class="attr">name</span>: <span class="string">"hundred"</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,raw</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123; n: 0, nModified: 0, ok: 1 &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(raw);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果设置options里的upsert参数为true，若没有符合查询条件的文档，mongo将会综合第一第二个参数向集合插入一个新的文档</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.update(&#123;<span class="attr">age</span>:<span class="number">100</span>&#125;,&#123;<span class="attr">name</span>: <span class="string">"hundred"</span>&#125;,&#123;<span class="attr">upsert</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,raw</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123; n: 1, nModified: 0,upserted: [ &#123; index: 0, _id: 5972c202d46b621fca7fc8c7 &#125; ], ok: 1 &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(raw);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/wp0214/s6ieypnrxz0zlsk1f77u85l2/image_1c3vl875k1kpo138s1ikh7ce1flu1g.png" alt="image_1c3vl875k1kpo138s1ikh7ce1flu1g.png-9.6kB"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.update(&#123;<span class="attr">name</span>:<span class="regexp">/aa/</span>&#125;,&#123;<span class="attr">age</span>: <span class="number">0</span>&#125;,&#123;<span class="attr">upsert</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,raw</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123; n: 1, nModified: 0,upserted: [ &#123; index: 0, _id: 5972c288d46b621fca7fdd8f &#125; ], ok: 1 &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(raw);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/wp0214/52zgf0pg756qjuntehu1azb7/image_1c3vl8f3c90r2np1lncamqg6d1t.png" alt="image_1c3vl8f3c90r2np1lncamqg6d1t.png-11.1kB"></p>
<p> <strong>update()方法中的回调函数不能省略，否则数据不会被更新。如果回调函数里并没有什么有用的信息，则可以使用exec()简化代码</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.update(&#123;<span class="attr">name</span>:<span class="regexp">/aa/</span>&#125;,&#123;<span class="attr">age</span>: <span class="number">0</span>&#125;,&#123;<span class="attr">upsert</span>:<span class="literal">true</span>&#125;).exec();</span><br></pre></td></tr></table></figure>
<h3 id="updateMany"><a href="#updateMany" class="headerlink" title="updateMany()"></a><strong>updateMany()</strong></h3><p>updateMany()与update()方法唯一的区别就是默认更新多个文档，即使设置{multi:false}也无法只更新第一个文档</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Model.updateMany(conditions, doc, [options], [callback])</span><br></pre></td></tr></table></figure>
<p>将数据库中名字中带有’huo’的数据，年龄变为50岁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.updateMany(&#123;<span class="attr">name</span>:<span class="regexp">/huo/</span>&#125;,&#123;<span class="attr">age</span>:<span class="number">50</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,raw</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123; n: 2, nModified: 2, ok: 1 &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(raw);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/wp0214/ce3gpjsnaw3ujir5xnphygfa/image_1c3vlcq8crf714451mufup2s8k2a.png" alt="image_1c3vlcq8crf714451mufup2s8k2a.png-7.2kB"></p>
<h3 id="find-save"><a href="#find-save" class="headerlink" title="find() + save()"></a><strong>find() + save()</strong></h3><p>如果需要更新的操作比较复杂，可以使用find()+save()方法来处理</p>
<p>找到年龄小于20岁的数据，名字后面添加’30’字符</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$lt</span>:<span class="number">20</span>&#125;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//[ &#123; _id: 5971f93be6f98ec60e3dc86d, name: 'wang', age: 10 &#125;,</span></span><br><span class="line">    <span class="comment">//&#123; _id: 5971f93be6f98ec60e3dc86f, name: 'li', age: 12 &#125;]</span></span><br><span class="line">    <span class="built_in">console</span>.log(docs);</span><br><span class="line">    docs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item,index,arr</span>)</span>&#123;</span><br><span class="line">        item.name += <span class="string">'30'</span>;</span><br><span class="line">        item.save();</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//[ &#123; _id: 5971f93be6f98ec60e3dc86d, name: 'wang30', age: 10 &#125;,</span></span><br><span class="line">    <span class="comment">// &#123; _id: 5971f93be6f98ec60e3dc86f, name: 'li30', age: 12 &#125;]</span></span><br><span class="line">    <span class="built_in">console</span>.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="updateOne"><a href="#updateOne" class="headerlink" title="updateOne()"></a><strong>updateOne()</strong></h3><p>updateOne()方法只能更新找到的第一条数据，即使设置{multi:true}也无法同时更新多个文档</p>
<p>将数据库中名字中带有’huo’的数据，年龄变为60岁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.updateOne(&#123;<span class="attr">name</span>:<span class="regexp">/huo/</span>&#125;,&#123;<span class="attr">age</span>:<span class="number">60</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,raw</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123; n: 1, nModified: 1, ok: 1 &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(raw);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/wp0214/ly52z99mrfkjsdgunf7a4ydm/image_1c3vloi85170s10ndml1jl5fj92n.png" alt="image_1c3vloi85170s10ndml1jl5fj92n.png-7.2kB"></p>
<h3 id="findOne-save"><a href="#findOne-save" class="headerlink" title="findOne() + save()"></a><strong>findOne() + save()</strong></h3><p>如果需要更新的操作比较复杂，可以使用findOne()+save()方法来处理</p>
<p>找到名字为’huochai’的数据，年龄加100岁</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">temp.findOne(&#123;<span class="attr">name</span>:<span class="string">'huochai'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//&#123; _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 10 &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(doc);</span><br><span class="line">    doc.age += <span class="number">100</span>;</span><br><span class="line">    doc.save();</span><br><span class="line">    <span class="comment">//&#123; _id: 5971f93be6f98ec60e3dc86c, name: 'huochai', age: 110 &#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(doc);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="文档删除"><a href="#文档删除" class="headerlink" title="文档删除"></a>文档删除</h2><p>常用的文档删除方法</p>
<ul>
<li>remove()</li>
<li>findOneAndRemove()</li>
<li>findByIdAndRemove()</li>
</ul>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a><strong>remove()</strong></h3><p>remove有两种形式，一种是文档的remove()方法，一种是Model的remove()方法</p>
<p>下面介绍Model的remove()方法，该方法的第一个参数conditions为查询条件，第二个参数回调函数的形式如下function(err){}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">model.remove(conditions, [callback])</span><br></pre></td></tr></table></figure>
<p>temp中数据：<br><img src="http://static.zybuluo.com/wp0214/jktjwns8ieb1iwtwrkj4jnvh/image_1c3vgq5iem5i1u6p18gi1l1h1gi9.png" alt="image_1c3vm1q1v104j1uetd63gk71l7j9.png-7.3kB"></p>
<p>删除数据库中名称包括’30’的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.remove(&#123;name:&#x2F;30&#x2F;&#125;,function(err)&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>结果：<br><img src="http://static.zybuluo.com/wp0214/qyfdsm8pkaf13ljhoqvdjpo7/image_1c3vkdd629khvjlnn11cv5inem.png" alt="image_1c3vm32b1p0iqbo10s6h4obbvm.png-4.1kB"></p>
<p><strong>[注意]remove()方法中的回调函数不能省略，否则数据不会被删除。当然，可以使用exec()方法来简写代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.remove(&#123;name:&#x2F;30&#x2F;&#125;).exec()</span><br></pre></td></tr></table></figure>
<p>下面介绍文档的remove()方法，该方法的参数回调函数的形式如下function(err,doc){}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.remove([callback])</span><br></pre></td></tr></table></figure>
<p>删除数据库中名称包含’huo’的数据</p>
<p>[注意]文档的remove()方法的回调函数参数可以省略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find(&#123;name:&#x2F;huo&#x2F;&#125;,function(err,doc)&#123;</span><br><span class="line">    doc.forEach(function(item,index,arr)&#123;</span><br><span class="line">        item.remove(function(err,doc)&#123;</span><br><span class="line">            &#x2F;&#x2F;&#123; _id: 5971f93be6f98ec60e3dc86c, name: &#39;huochai&#39;, age: 30 &#125;</span><br><span class="line">            &#x2F;&#x2F;&#123; _id: 5971f93be6f98ec60e3dc86e, name: &#39;huo&#39;, age: 60 &#125;</span><br><span class="line">            console.log(doc);</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="findOneAndRemove"><a href="#findOneAndRemove" class="headerlink" title="findOneAndRemove()"></a><strong>findOneAndRemove()</strong></h3><p>model的remove()会删除符合条件的所有数据，如果只删除符合条件的第一条数据，则可以使用model的findOneAndRemove()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Model.findOneAndRemove(conditions, [options], [callback])</span><br></pre></td></tr></table></figure>
<p>集合temps现有数据如下<br><img src="http://static.zybuluo.com/wp0214/hbqtyngmqo2qsyx1lr7n4muk/image_1c3vkrfahu171gp9u8pmms16i713.png" alt="image_1c3vmkjud1fj415l43a7hvk19ju13.png-7.3kB"></p>
<p>现在删除第一个年龄小于20的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.findOneAndRemove(&#123;age:&#123;$lt:20&#125;&#125;,function(err,doc)&#123;</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5972d3f3e6f98ec60e3dc873, name: &#39;wang&#39;, age: 18 &#125;</span><br><span class="line">    console.log(doc);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/wp0214/s6ieypnrxz0zlsk1f77u85l2/image_1c3vl875k1kpo138s1ikh7ce1flu1g.png" alt="image_1c3vmlltq1dfl17771hqg1tfn1dr51g.png-5.5kB"></p>
<p>与model的remove()方法相同，回调函数不能省略，否则数据不会被删除。当然，可以使用exec()方法来简写代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.findOneAndRemove(&#123;age:&#123;$lt:20&#125;&#125;).exec()</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/wp0214/52zgf0pg756qjuntehu1azb7/image_1c3vl8f3c90r2np1lncamqg6d1t.png" alt="image_1c3vmo3ff1quqoei1d8uq1r79e1t.png-7.5kB"></p>
<p>删除第0个元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var aIDArr &#x3D; [];</span><br><span class="line">temp.find(function(err,docs)&#123;</span><br><span class="line">    docs.forEach(function(item,index,arr)&#123;</span><br><span class="line">        aIDArr.push(item._id);</span><br><span class="line">    &#125;)</span><br><span class="line">    temp.findByIdAndRemove(aIDArr[0],function(err,doc)&#123;</span><br><span class="line">        &#x2F;&#x2F;&#123; _id: 5972d754e6f98ec60e3dc882, name: &#39;huochai&#39;, age: 27 &#125;</span><br><span class="line">        console.log(doc);</span><br><span class="line">    &#125;)            </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/wp0214/ce3gpjsnaw3ujir5xnphygfa/image_1c3vlcq8crf714451mufup2s8k2a.png" alt="image_1c3vmpbqi6cnm9j14r2e561ouv2a.png-5.6kB"></p>
<h2 id="前后钩子pre-和post"><a href="#前后钩子pre-和post" class="headerlink" title="前后钩子pre()和post()"></a>前后钩子pre()和post()</h2><p>前后钩子即pre()和post()方法，又称为中间件，是在执行某些操作时可以执行的函数。<br>中间件在schema上指定，类似于静态方法或实例方法等</p>
<p>可以在数据库执行下列操作时，设置前后钩子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init</span><br><span class="line">validate</span><br><span class="line">save</span><br><span class="line">remove</span><br><span class="line">count</span><br><span class="line">find</span><br><span class="line">findOne</span><br><span class="line">findOneAndRemove</span><br><span class="line">findOneAndUpdate</span><br><span class="line">insertMany</span><br><span class="line">update</span><br></pre></td></tr></table></figure>
<h3 id="pre"><a href="#pre" class="headerlink" title="pre()"></a><strong>pre()</strong></h3><p>以find()方法为例，在执行find()方法之前，执行pre()方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var schema &#x3D; new mongoose.Schema(&#123; </span><br><span class="line">    age:Number,</span><br><span class="line">    name: String,</span><br><span class="line">    x:Number,</span><br><span class="line">    y:Number</span><br><span class="line">    &#125;);  </span><br><span class="line">    </span><br><span class="line">schema.pre(&#39;find&#39;,function(next)&#123;</span><br><span class="line">    console.log(&#39;我是pre方法1&#39;);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">schema.pre(&#39;find&#39;,function(next)&#123;</span><br><span class="line">    console.log(&#39;我是pre方法2&#39;);</span><br><span class="line">    next();</span><br><span class="line">&#125;);  </span><br><span class="line">var temp &#x3D; mongoose.model(&#39;temp&#39;, schema);</span><br><span class="line">temp.find(function(err,docs)&#123;</span><br><span class="line">    console.log(docs[0]);</span><br><span class="line">&#125;)    </span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">我是pre方法1</span><br><span class="line">我是pre方法2</span><br><span class="line">&#123; _id: 5972ed35e6f98ec60e3dc886,name: &#39;huochai&#39;,age: 27,x: 1,y: 2 &#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="post"><a href="#post" class="headerlink" title="post()"></a><strong>post()</strong></h3><p>post()方法并不是在执行某些操作后再去执行的方法，而在执行某些操作前最后执行的方法，post()方法里不可以使用next()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var schema &#x3D; new mongoose.Schema(&#123;</span><br><span class="line">    age:Number, </span><br><span class="line">    name: String,</span><br><span class="line">    x:Number,</span><br><span class="line">    y:Number</span><br><span class="line">    &#125;);  </span><br><span class="line">    </span><br><span class="line">schema.post(&#39;find&#39;,function(docs)&#123;</span><br><span class="line">    console.log(&#39;我是post方法1&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">schema.post(&#39;find&#39;,function(docs)&#123;</span><br><span class="line">    console.log(&#39;我是post方法2&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">var temp &#x3D; mongoose.model(&#39;temp&#39;, schema);</span><br><span class="line">temp.find(function(err,docs)&#123;</span><br><span class="line">    console.log(docs[0]);</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">我是post方法1</span><br><span class="line">我是post方法2</span><br><span class="line">&#123; _id: 5972ed35e6f98ec60e3dc886,name: &#39;huochai&#39;,age: 27,x: 1,y: 2 &#125;</span><br><span class="line"> *&#x2F;</span><br></pre></td></tr></table></figure>
<h2 id="文档查询后处理"><a href="#文档查询后处理" class="headerlink" title="文档查询后处理"></a>文档查询后处理</h2><p>常用的查询后处理的方法如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort     排序</span><br><span class="line">skip     跳过</span><br><span class="line">limit    限制</span><br><span class="line">select   显示字段</span><br><span class="line">exect    执行</span><br><span class="line">count    计数</span><br><span class="line">distinct 去重</span><br></pre></td></tr></table></figure>

<p>当前数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var schema &#x3D; new mongoose.Schema(&#123; </span><br><span class="line">    age:Number, </span><br><span class="line">    name: String,</span><br><span class="line">    x:Number,</span><br><span class="line">    y:Number</span><br><span class="line">    &#125;);  </span><br><span class="line">    </span><br><span class="line">var temp &#x3D; mongoose.model(&#39;temp&#39;, schema);</span><br><span class="line"></span><br><span class="line">temp.find(function(err,docs)&#123;</span><br><span class="line">    &#x2F;&#x2F;[ &#123; _id: 5972ed35e6f98ec60e3dc886,name: &#39;huochai&#39;,age: 27,x: 1,y: 2 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5972ed35e6f98ec60e3dc887,name: &#39;wang&#39;,age: 18,x: 1,y: 1 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5972ed35e6f98ec60e3dc888, name: &#39;huo&#39;, age: 30, x: 2, y: 1 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5972ed35e6f98ec60e3dc889, name: &#39;li&#39;, age: 20, x: 2, y: 2 &#125; ]</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a><strong>sort()</strong></h3><p>sort函数可以将查询结果数据进行排序操作，该函数的参数是一个或多个键/值对，键代表要排序的键名，值代表排序的方向，1是升序，-1是降序或者值的正负号。</p>
<p>按age从小到大排序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find().sort(&quot;age&quot;).exec(function(err,docs)&#123;</span><br><span class="line">    &#x2F;&#x2F;[ &#123; _id: 5972ed35e6f98ec60e3dc887,name: &#39;wang&#39;,age: 18,x: 1,y: 1 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5972ed35e6f98ec60e3dc889, name: &#39;li&#39;, age: 20, x: 2, y: 2 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5972ed35e6f98ec60e3dc886,name: &#39;huochai&#39;,age: 27,x: 1,y: 2 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5972ed35e6f98ec60e3dc888, name: &#39;huo&#39;, age: 30, x: 2, y: 1 &#125; ]</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>按x从小到大，age从大到小排列</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find().sort(&quot;x -age&quot;).exec(function(err,docs)&#123;</span><br><span class="line">    &#x2F;&#x2F;[ &#123; _id: 5972ed35e6f98ec60e3dc886,name: &#39;huochai&#39;,age: 27,x: 1,y: 2 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123;  _id: 5972ed35e6f98ec60e3dc887,name: &#39;wang&#39;,age: 18,x: 1,y: 1 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5972ed35e6f98ec60e3dc888, name: &#39;huo&#39;, age: 30, x: 2, y: 1 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5972ed35e6f98ec60e3dc889, name: &#39;li&#39;, age: 20, x: 2, y: 2 &#125; ]</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>结果排序：find(Conditions,fields,options,callback);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find(&#123;&#125;,null,&#123;sort:&#123;age:-1&#125;&#125;,function(err,docs)&#123;</span><br><span class="line">  &#x2F;&#x2F;查询所有数据，并按照age降序顺序返回数据docs</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="skip"><a href="#skip" class="headerlink" title="skip()"></a><strong>skip()</strong></h3><p>skip函数的功能是略过指定数量的匹配结果，返回余下的查询结果</p>
<p>跳过1个，显示其他</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find().skip(1).exec(function(err,docs)&#123;</span><br><span class="line">    &#x2F;&#x2F;[ &#123; _id: 5972ed35e6f98ec60e3dc887,name: &#39;wang&#39;,age: 18,x: 1,y: 1 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5972ed35e6f98ec60e3dc888, name: &#39;huo&#39;, age: 30, x: 2, y: 1 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5972ed35e6f98ec60e3dc889, name: &#39;li&#39;, age: 20, x: 2, y: 2 &#125; ]</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="limit"><a href="#limit" class="headerlink" title="limit()"></a><strong>limit()</strong></h3><p>在查询操作中，有时数据量会很大，这时我们就需要对返回结果的数量进行限制，那么我们就可以使用limit函数，通过它来限制结果数量</p>
<p>显示2个</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find().limit(2).exec(function(err,docs)&#123;</span><br><span class="line">    &#x2F;&#x2F;[ &#123; _id: 5972ed35e6f98ec60e3dc886,name: &#39;huochai&#39;,age: 27,x: 1,y: 2 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; _id: 5972ed35e6f98ec60e3dc887,name: &#39;wang&#39;,age: 18,x: 1,y: 1 &#125; ]</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="select"><a href="#select" class="headerlink" title="select()"></a><strong>select()</strong></h3><p>对返回的结果进行选择显示</p>
<p>显示name、age字段，不显示_id字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find().select(&quot;name age -_id&quot;).exec(function(err,docs)&#123;</span><br><span class="line">    &#x2F;&#x2F;[ &#123; name: &#39;huochai&#39;, age: 27 &#125;,&#123; name: &#39;wang&#39;, age: 18 &#125;,&#123; name: &#39;huo&#39;, age: 30 &#125;,&#123; name: &#39;li&#39;, age: 20 &#125; ]</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find().select(&#123;name:1, age:1, _id:0&#125;).exec(function(err,docs)&#123;</span><br><span class="line">    &#x2F;&#x2F;[ &#123; name: &#39;huochai&#39;, age: 27 &#125;,&#123; name: &#39;wang&#39;, age: 18 &#125;,&#123; name: &#39;huo&#39;, age: 30 &#125;,&#123; name: &#39;li&#39;, age: 20 &#125; ]</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="综合栗子"><a href="#综合栗子" class="headerlink" title="综合栗子"></a><strong>综合栗子</strong></h3><p>下面将以上方法结合起来使用，<br>跳过第1个后，只显示2个数据，按照age由大到小排序，且不显示_id字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find().skip(1).limit(2).sort(&quot;-age&quot;).select(&quot;-_id&quot;).exec(function(err,docs)&#123;</span><br><span class="line">    &#x2F;&#x2F;[ &#123; name: &#39;huochai&#39;, age: 27, x: 1, y: 2 &#125;,</span><br><span class="line">    &#x2F;&#x2F;&#123; name: &#39;li&#39;, age: 20, x: 2, y: 2 &#125; ]</span><br><span class="line">    console.log(docs);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="count"><a href="#count" class="headerlink" title="count()"></a><strong>count()</strong></h3><p>显示集合temps中的文档数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find().count(function(err,count)&#123;</span><br><span class="line">    console.log(count);&#x2F;&#x2F;4</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a><strong>distinct()</strong></h3><p>返回集合temps中的x的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">temp.find().distinct(&#39;x&#39;,function(err,distinct)&#123;</span><br><span class="line">    console.log(distinct);&#x2F;&#x2F;[ 1, 2 ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="文档验证"><a href="#文档验证" class="headerlink" title="文档验证"></a>文档验证</h2><p>为什么需要文档验证呢？<br>以一个例子作为说明，schema进行如下定义</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> schema = <span class="keyword">new</span> mongoose.Schema(&#123; </span><br><span class="line">    age:<span class="built_in">Number</span>,</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    x:<span class="built_in">Number</span>,</span><br><span class="line">    y:<span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果不进行文档验证，保存文档时，就可以不按照Schema设置的字段进行设置，分为以下几种情况</p>
<p><strong>1、缺少字段的文档可以保存成功</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var temp &#x3D; mongoose.model(&#39;temp&#39;, schema);</span><br><span class="line">new temp(&#123;age:10&#125;).save(function(err,doc)&#123;</span><br><span class="line">    &#x2F;&#x2F;&#123; __v: 0, age: 10, _id: 597304442b70086a1ce3cf05 &#125;</span><br><span class="line">    console.log(doc);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>2、包含未设置的字段的文档也可以保存成功，未设置的字段不被保存</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new temp(&#123;age:100,abc:&quot;abc&quot;&#125;).save(function(err,doc)&#123;</span><br><span class="line">    &#x2F;&#x2F;&#123; __v: 0, age: 100, _id: 5973046a2bb57565b474f48b &#125;</span><br><span class="line">    console.log(doc);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>3、包含字段类型与设置不同的字段的文档也可以保存成功，不同字段类型的字段被保存为设置的字段类型</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new temp(&#123;age:true,name:10&#125;).save(function(err,doc)&#123;</span><br><span class="line">    &#x2F;&#x2F;&#123; __v: 0, age: 1, name: &#39;10&#39;, _id: 597304f7a926033060255366 &#125;</span><br><span class="line">    console.log(doc);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>而通过文档验证，就可以避免以下几种情况发生</p>
<p>文档验证在SchemaType中定义，格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;name: &#123;type:String, validator:value&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>常用验证包括以下几种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">required: 数据必须填写</span><br><span class="line">default: 默认值</span><br><span class="line">validate: 自定义匹配</span><br><span class="line">min: 最小值(只适用于数字)</span><br><span class="line">max: 最大值(只适用于数字)</span><br><span class="line">match: 正则匹配(只适用于字符串)</span><br><span class="line">enum:  枚举匹配(只适用于字符串)</span><br></pre></td></tr></table></figure>
<h3 id="required"><a href="#required" class="headerlink" title="required"></a><strong>required</strong></h3><p>必填项</p>
<p>将age设置为必填字段，如果没有age字段，文档将不被保存，且出现错误提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var schema &#x3D; new mongoose.Schema(&#123; </span><br><span class="line">    age:&#123;</span><br><span class="line">        type:Number,</span><br><span class="line">        required:true</span><br><span class="line">        &#125;,</span><br><span class="line">        name: String,</span><br><span class="line">        x:Number,</span><br><span class="line">        y:Number</span><br><span class="line">    &#125;);  </span><br><span class="line">var temp &#x3D; mongoose.model(&#39;temp&#39;, schema);</span><br><span class="line">new temp(&#123;name:&quot;abc&quot;&#125;).save(function(err,doc)&#123;</span><br><span class="line">    &#x2F;&#x2F;Path &#96;age&#96; is required.</span><br><span class="line">    console.log(err.errors[&#39;age&#39;].message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="default"><a href="#default" class="headerlink" title="default"></a><strong>default</strong></h3><p>默认值</p>
<p>设置age字段的默认值为18，如果不设置age字段，则会取默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var schema &#x3D; new mongoose.Schema(&#123; </span><br><span class="line">    age:&#123;type:Number,default:18&#125;,</span><br><span class="line">    name:String,</span><br><span class="line">    x:Number,</span><br><span class="line">    y:Number</span><br><span class="line">&#125;);  </span><br><span class="line">var temp &#x3D; mongoose.model(&#39;temp&#39;, schema);</span><br><span class="line">new temp(&#123;name:&#39;a&#39;&#125;).save(function(err,doc)&#123;</span><br><span class="line">    &#x2F;&#x2F;&#123; __v: 0, name: &#39;a&#39;, _id: 59730d2e7a751d81582210c1, age: 18 &#125;</span><br><span class="line">    console.log(doc);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="min-max"><a href="#min-max" class="headerlink" title="min | max"></a><strong>min | max</strong></h3><p>将age的取值范围设置为[0,10]。如果age取值为20，文档将不被保存，且出现错误提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var schema &#x3D; new mongoose.Schema(&#123; </span><br><span class="line">        age:&#123;type:Number,min:0,max:10&#125;,</span><br><span class="line">        name: String,</span><br><span class="line">        x:Number,</span><br><span class="line">        y:Number</span><br><span class="line">    &#125;);  </span><br><span class="line">var temp &#x3D; mongoose.model(&#39;temp&#39;, schema);</span><br><span class="line">new temp(&#123;age:20&#125;).save(function(err,doc)&#123;</span><br><span class="line">    &#x2F;&#x2F;Path &#96;age&#96; (20) is more than maximum allowed value (10).</span><br><span class="line">    console.log(err.errors[&#39;age&#39;].message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="match"><a href="#match" class="headerlink" title="match"></a><strong>match</strong></h3><p>将name的match设置为必须存在’a’字符。如果name不存在’a’，文档将不被保存，且出现错误提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var schema &#x3D; new mongoose.Schema(&#123; age:Number, name:&#123;type:String,match:&#x2F;a&#x2F;&#125;,x:Number,y:Number&#125;);  </span><br><span class="line">var temp &#x3D; mongoose.model(&#39;temp&#39;, schema);</span><br><span class="line">new temp(&#123;name:&#39;bbb&#39;&#125;).save(function(err,doc)&#123;</span><br><span class="line">    &#x2F;&#x2F;Path &#96;name&#96; is invalid (bbb).</span><br><span class="line">    console.log(err.errors[&#39;name&#39;].message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="validate"><a href="#validate" class="headerlink" title="validate"></a><strong>validate</strong></h3><p>validate实际上是一个函数，函数的参数代表当前字段，返回true表示通过验证，返回false表示未通过验证。利用validate可以自定义任何条件。比如，定义名字name的长度必须在4个字符以上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ar validateLength &#x3D; function(arg)&#123;</span><br><span class="line">    if(arg.length &gt; 4)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;;</span><br><span class="line">var schema &#x3D; new mongoose.Schema(&#123; name:&#123;type:String,validate:validateLength&#125;, age:Number,x:Number,y:Number&#125;);  </span><br><span class="line">var temp &#x3D; mongoose.model(&#39;temp&#39;, schema);</span><br><span class="line">new temp(&#123;name:&#39;abc&#39;&#125;).save(function(err,doc)&#123;</span><br><span class="line">    &#x2F;&#x2F;Validator failed for path &#96;name&#96; with value &#96;abc&#96;</span><br><span class="line">    console.log(err.errors[&#39;name&#39;].message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mongodb</tag>
        <tag>数据库</tag>
        <tag>mongoose</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer实践-qq音乐自动购买的ui自动化测试</title>
    <url>/2020/04/03/puppeteer%E5%AE%9E%E8%B7%B5-qq%E9%9F%B3%E4%B9%90%E8%87%AA%E5%8A%A8%E8%B4%AD%E4%B9%B0%E7%9A%84ui%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h2 id="1、Puppeteer-简介"><a href="#1、Puppeteer-简介" class="headerlink" title="1、Puppeteer 简介"></a>1、Puppeteer 简介</h2><p>Puppeteer 是一个node库，他提供了一组用来操纵Chrome的API, 通俗来说就是一个 headless chrome浏览器 (当然你也可以配置成有UI的，默认是没有的)。既然是浏览器，那么我们手工可以在浏览器上做的事情 Puppeteer 都能胜任, 另外，Puppeteer 翻译成中文是”木偶”意思，所以听名字就知道，操纵起来很方便，你可以很方便的操纵她去实现：</p>
<p><strong>Puppeteer能做什么</strong></p>
<ul>
<li>对网页进行截图保存为图片或 pdf</li>
<li>抓取单页应用(SPA)执行并渲染(解决传统 HTTP 爬虫抓取单页应用难以处理异步请求的问题)</li>
<li>做表单的自动提交、UI的自动化测试、模拟键盘输入等</li>
<li>用浏览器自带的一些调试工具和性能分析工具帮助我们分析问题</li>
<li>写爬虫做你想做的事情~<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line">yarn add puppeteer</span><br><span class="line"># or "npm i puppeteer"</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>建立 index.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://y.qq.com'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'yqq.png'</span>&#125;);</span><br><span class="line">    browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node  index.js</span><br></pre></td></tr></table></figure>
<p>这段代码会打开 <a href="https://y.qq.com" target="_blank" rel="noopener">https://y.qq.com</a> 并截图，我们运行</p>
<p>如果看到目录下有生成图片y.qq.png的话，恭喜你，我们可以开始继续往下</p>
<p><strong>这里测试的功能是自动拉登录购买一张数字专辑，并在购买成功后跳转到铭牌页，先看下整个流程吧。</strong></p>
<p>首先我们先创建一个设备，文档中(<a href="https://github.com/GoogleChrome/puppeteer/blob/master/DeviceDescriptors.js" target="_blank" rel="noopener">https://github.com/GoogleChrome/puppeteer/blob/master/DeviceDescriptors.js</a>)</p>
<p>我们能看到，默认支持的设备数量还是很多的，除了这些默认的设备之外，我们还可以自定义自己的设备，后面在调用emulate方法时会提到：</p>
<p>我们这里暂时先创建系统提供的iphone6设备，完了我们定义一个延时的timeout函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> devices = <span class="built_in">require</span>(<span class="string">'puppeteer/DeviceDescriptors'</span>);</span><br><span class="line"><span class="keyword">const</span> iPhone = devices[<span class="string">'iPhone 6'</span>];</span><br><span class="line"><span class="keyword">let</span> timeout = <span class="function"><span class="keyword">function</span> (<span class="params">delay</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;   </span><br><span class="line">           setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;   </span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      resolve(<span class="number">1</span>)</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                      reject(<span class="number">0</span>)</span><br><span class="line">                   &#125;</span><br><span class="line">           &#125;, delay);</span><br><span class="line">     &#125;)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p> 接下来我们创建一个浏览器实例，并打开一个页面</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">     headless:<span class="literal">false</span> <span class="comment">//设置为true就不会打开浏览器</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br></pre></td></tr></table></figure>

<h2 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h2><p> 1、<strong>第一步:我们打开页面，考虑到有数据需要异步加载，我们在延迟1000ms后调用screenshot方法截图留作日志。</strong><br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">console</span>.log(<span class="string">"进入页面"</span>);</span><br><span class="line"><span class="keyword">await</span> page.goto(<span class="string">'https://y.qq.com/m/digitalbum/gold/index.html?_video=true&amp;id=2210323&amp;g_f=tuijiannewupload#index/fans'</span>);</span><br><span class="line"><span class="keyword">await</span> timeout(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">     path: <span class="string">'1.png'</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure></p>
<p> 2、<strong>第二步: 模拟触发点击 立即购买按钮，这时候会因为没有登录态而打开QQ登录。</strong><br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="built_in">console</span>.log(<span class="string">"点击立即购买按钮"</span>);</span><br><span class="line"><span class="keyword">await</span> page.tap(<span class="string">'.js_sale_buyalbum'</span>);</span><br><span class="line"><span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">    path: <span class="string">'2.png'</span></span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200403170216.png" alt=""></p>
<p>3、<strong>在输入框中输入帐号密码</strong><br>模拟输入需要我们先调用tap方法模拟点击输入框，tap参数就是元素selector,再用type方法进行输入,输入完了之后在模拟点击登录按钮，登录完了之后我们延迟一段时间截图，顺利的话我们就能重新回到之前的售卖页首页，而底下usrbar因为有了登录态也展示了出来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"登录"</span>);</span><br><span class="line"><span class="keyword">await</span> page.tap(<span class="string">"#u"</span>); <span class="comment">//直接操作dom选择器，是不是很方便</span></span><br><span class="line"><span class="keyword">await</span> page.type(<span class="string">"521017853"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> page.tap(<span class="string">"#p"</span>);</span><br><span class="line"><span class="keyword">await</span> page.type(<span class="string">"*********"</span>);<span class="comment">//这里密码就不展示了哈</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> page.tap(<span class="string">"#go"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> timeout(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">     path: <span class="string">'3.png'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"登录成功"</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200403170315.png" alt=""></p>
<p>4、<strong>点击立即购买按钮</strong><br>这里会出现一个购买选择浮层,然后我们点击立即支付之后需要加载米大师，故这里我们延迟5000ms。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//点击购买</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"点击立即购买按钮"</span>);</span><br><span class="line"><span class="keyword">await</span> page.tap(<span class="string">'.js_sale_buyalbum'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">    path: <span class="string">'4.png'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"点击支付浮层上的立即支付"</span>);</span><br><span class="line"><span class="keyword">await</span> page.tap(<span class="string">".js_buyalbum_pay"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> timeout(<span class="number">5000</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200403170416.png" alt=""></p>
<p>5、<strong>点击提示中的确定按钮</strong><br>由于米大师是在iframe中打开的，所以我们需要先获取到我们当前页frame,这个可以调用刚创建的页面实例page的mainFrame()方法即可获得,如果我们需要获取子frame的话也只需要调用childFrames来进行获取。在获取到米大师对应的frame之后就可以调用midas_frame.$(selector)类jquery的方法进行元素的获取，之后再模拟点击。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"进入 米大师支付浮层"</span>)</span><br><span class="line"><span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">     path: <span class="string">'5.png'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> $frame = page.mainFrame();</span><br><span class="line"><span class="keyword">let</span> midas_frame = $frame.childFrames()[<span class="number">0</span>];<span class="comment">//获取到midas对应的frame</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"点击确定 米大师支付浮层测试环境提示 的确认按钮"</span>);</span><br><span class="line"><span class="keyword">let</span> $dom = <span class="keyword">await</span> midas_frame.$(<span class="string">".fusion-pm-fl-wrapper .fpm-default"</span>);</span><br><span class="line"><span class="keyword">await</span> $dom.tap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">    path: <span class="string">'6.png'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200403170600.png" alt=""></p>
<p>6、<strong>点击Q币支付</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"点击 米大师支付浮层 确认支付按钮"</span>);</span><br><span class="line">$dom = <span class="keyword">await</span> midas_frame.$(<span class="string">"#wrap .fpm-default"</span>);</span><br><span class="line"><span class="keyword">await</span> $dom.tap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> timeout(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">    path: <span class="string">'7.png'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200403170733.png" alt=""></p>
<p>7、<strong>测试完毕，关闭浏览器实例</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">"点击 米大师支付浮层 支付完成"</span>);</span><br><span class="line">$dom = <span class="keyword">await</span> midas_frame.$(<span class="string">"#wrap .btn-primary"</span>);</span><br><span class="line"><span class="keyword">await</span> $dom.tap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> timeout(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"已购铭牌页"</span>);</span><br><span class="line"><span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">     path: <span class="string">'8.png'</span></span><br><span class="line">&#125;);</span><br><span class="line">browser.close();</span><br></pre></td></tr></table></figure>

<p><strong>最后在项目目录中，我们看到，各个步骤的截图都已生成。</strong><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200403170840.png" alt=""></p>
]]></content>
      <categories>
        <category>puppeteer</category>
        <category>案例</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
        <tag>自动化测试</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer实践-批量下载图灵图书</title>
    <url>/2020/04/03/puppeteer%E5%AE%9E%E8%B7%B5-%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%81%B5%E5%9B%BE%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="puppeteer实践-批量下载图灵图书"><a href="#puppeteer实践-批量下载图灵图书" class="headerlink" title="puppeteer实践-批量下载图灵图书"></a>puppeteer实践-批量下载图灵图书</h1><h2 id="下载图灵图书"><a href="#下载图灵图书" class="headerlink" title="下载图灵图书"></a>下载图灵图书</h2><p>借助无头浏览器 Puppeteer 的无头模式，实现简单的下载已购买书籍为 pdf 到本地的脚本，支持批量下载已购买的书籍。</p>
<p><strong>Puppeteer能做什么</strong></p>
<ul>
<li>对网页进行截图保存为图片或 pdf</li>
<li>抓取单页应用(SPA)执行并渲染(解决传统 HTTP 爬虫抓取单页应用难以处理异步请求的问题)</li>
<li>做表单的自动提交、UI的自动化测试、模拟键盘输入等</li>
<li>用浏览器自带的一些调试工具和性能分析工具帮助我们分析问题</li>
<li>写爬虫做你想做的事情~</li>
</ul>
<a id="more"></a>

<h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><ul>
<li>启动浏览器</li>
<li>跳转登陆页</li>
<li>输入账号密码</li>
<li>登陆成功</li>
<li>找到已买的书籍</li>
<li>逐次点击书籍名称，进入书籍详情</li>
<li>将详情生成pdf，并保存</li>
</ul>
<p>使用方法，传入帐号密码和保存路径，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node ./demo/download-ituring-books.js <span class="string">'用户名'</span> <span class="string">'密码'</span> <span class="string">'./books'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：puppeteer 的 Page.pdf() 目前仅支持在无头模式中使用，所以要想看有头状态的抓取过程的话，执行到 Page.pdf() 这步会先报错</p>
</blockquote>
<p>所以启动这个脚本时，需要保持无头模式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    <span class="comment">// 关闭无头模式，方便我们看到这个无头浏览器执行的过程</span></span><br><span class="line">    <span class="comment">// 注意若调用了 Page.pdf 即保存为 pdf，则需要保持为无头模式</span></span><br><span class="line">    <span class="comment">// headless: false,</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>看下执行效果：<br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200403162959.png" alt=""></p>
<p>下载完后是这样子：<br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200403163112.png" alt=""></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>download-ituring-books.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下载图灵电子书</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> mkdirp = <span class="built_in">require</span>(<span class="string">'mkdirp'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> BASE_URL = <span class="string">'http://www.ituring.com.cn'</span>;</span><br><span class="line"><span class="keyword">const</span> SHELF_URL = <span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>/user/shelf`</span>;</span><br><span class="line"><span class="keyword">const</span> LOGIN_URL = <span class="string">`http://account.ituring.com.cn/log-in?returnUrl=<span class="subst">$&#123;<span class="built_in">encodeURIComponent</span>(SHELF_URL)&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> printIturingBooks = <span class="keyword">async</span> (userName, password, saveDir = <span class="string">'./books/'</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!userName) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'请输入用户名'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!password) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'请输入密码'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 设置统一的视窗大小</span></span><br><span class="line">        <span class="keyword">const</span> viewport = &#123;</span><br><span class="line">            width: <span class="number">1376</span>,</span><br><span class="line">            height: <span class="number">768</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'启动浏览器'</span>);</span><br><span class="line">        <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">            <span class="comment">// 关闭无头模式，方便我们看到这个无头浏览器执行的过程</span></span><br><span class="line">            <span class="comment">// 注意若调用了 Page.pdf 即保存为 pdf，则需要保持为无头模式</span></span><br><span class="line">            <span class="comment">// headless: false,</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'打开新页面'</span>);</span><br><span class="line">        <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">        page.setViewport(viewport);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'输入登录地址'</span>);</span><br><span class="line">        <span class="keyword">await</span> page.goto(LOGIN_URL);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> page.waitForSelector(<span class="string">'#loginForm'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'输入用户名和密码'</span>);</span><br><span class="line">        <span class="keyword">await</span> page.focus(<span class="string">'#Email'</span>);</span><br><span class="line">        <span class="keyword">await</span> page.type(userName);</span><br><span class="line">        <span class="keyword">await</span> page.focus(<span class="string">'#Password'</span>);</span><br><span class="line">        <span class="keyword">await</span> page.type(password);</span><br><span class="line">        <span class="keyword">await</span> page.click(<span class="string">'#loginForm  input[type="submit"]'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> page.waitForSelector(<span class="string">'.block-items'</span>);</span><br><span class="line">        <span class="keyword">const</span> books = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'.block-items'</span>, element =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> booksHTMLCollection = element.querySelectorAll(<span class="string">'.block-item'</span>);</span><br><span class="line">            <span class="keyword">const</span> booksElementArray = <span class="built_in">Array</span>.prototype.slice.call(booksHTMLCollection);</span><br><span class="line">            <span class="keyword">const</span> books = booksElementArray.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> a = item.querySelector(<span class="string">'.book-img a'</span>);</span><br><span class="line">                <span class="keyword">return</span> &#123;</span><br><span class="line">                    href: a.getAttribute(<span class="string">'href'</span>),</span><br><span class="line">                    title: a.getAttribute(<span class="string">'title'</span>),</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="keyword">return</span> books;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`书架上共找到<span class="subst">$&#123;books.length&#125;</span>本书`</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> book <span class="keyword">of</span> books) &#123;</span><br><span class="line">            <span class="keyword">const</span> bookPage = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">            bookPage.setViewport(viewport);</span><br><span class="line">            <span class="keyword">await</span> bookPage.goto(<span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>/<span class="subst">$&#123;book.href&#125;</span>`</span>);</span><br><span class="line">            <span class="keyword">await</span> bookPage.waitForSelector(<span class="string">'.bookmenu'</span>);</span><br><span class="line">            <span class="keyword">const</span> articles = <span class="keyword">await</span> bookPage.$<span class="built_in">eval</span>(<span class="string">'.bookmenu table tbody'</span>, element =&gt; &#123;</span><br><span class="line">                <span class="keyword">const</span> articlesHTMLCollection = element.querySelectorAll(<span class="string">'tr'</span>);</span><br><span class="line">                <span class="keyword">const</span> articlesElementArray = <span class="built_in">Array</span>.prototype.slice.call(articlesHTMLCollection);</span><br><span class="line">                <span class="keyword">const</span> articles = articlesElementArray.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="keyword">const</span> a = item.querySelector(<span class="string">'td a'</span>);</span><br><span class="line">                    <span class="keyword">return</span> &#123;</span><br><span class="line">                        href: a.getAttribute(<span class="string">'href'</span>),</span><br><span class="line">                        title: a.innerText.trim(),</span><br><span class="line">                    &#125;;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">return</span> articles;</span><br><span class="line">            &#125;);</span><br><span class="line">            bookPage.close();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> article <span class="keyword">of</span> articles) &#123;</span><br><span class="line">                <span class="keyword">const</span> articlePage = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">                articlePage.setViewport(viewport);</span><br><span class="line">                <span class="keyword">await</span> articlePage.goto(<span class="string">`<span class="subst">$&#123;BASE_URL&#125;</span>/<span class="subst">$&#123;article.href&#125;</span>`</span>);</span><br><span class="line">                <span class="keyword">await</span> articlePage.waitForSelector(<span class="string">'.article-detail'</span>);</span><br><span class="line">                <span class="keyword">await</span> articlePage.$<span class="built_in">eval</span>(<span class="string">'body'</span>, body =&gt; &#123;</span><br><span class="line">                    body.querySelector(<span class="string">'.layout-head'</span>).style.display = <span class="string">'none'</span>;</span><br><span class="line">                    body.querySelector(<span class="string">'.book-page .side'</span>).style.display = <span class="string">'none'</span>;</span><br><span class="line">                    body.querySelector(<span class="string">'#footer'</span>).style.display = <span class="string">'none'</span>;</span><br><span class="line">                    body.querySelector(<span class="string">'#toTop'</span>).style.display = <span class="string">'none'</span>;</span><br><span class="line">                    <span class="built_in">Promise</span>.resolve();</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">const</span> dirPath = <span class="string">`<span class="subst">$&#123;saveDir&#125;</span>/<span class="subst">$&#123;book.title&#125;</span>`</span>;</span><br><span class="line">                <span class="keyword">const</span> fileName = <span class="string">`<span class="subst">$&#123;article.title.replace(<span class="regexp">/\//g</span>, <span class="string">'、'</span>)&#125;</span>.pdf`</span>;</span><br><span class="line">                <span class="keyword">const</span> filePath = <span class="string">`<span class="subst">$&#123;dirPath&#125;</span>/<span class="subst">$&#123;fileName&#125;</span>`</span>;</span><br><span class="line">                mkdirp.sync(dirPath);</span><br><span class="line">                <span class="keyword">await</span> page.emulateMedia(<span class="string">'screen'</span>);</span><br><span class="line">                <span class="keyword">await</span> articlePage.pdf(&#123;</span><br><span class="line">                    path: filePath,</span><br><span class="line">                    format: <span class="string">'A4'</span></span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`保存成功: <span class="subst">$&#123;filePath&#125;</span>`</span>);</span><br><span class="line">                articlePage.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        browser.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> USER = process.argv[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> PASSWORD = process.argv[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">const</span> SAVE_DIR = process.argv[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!USER || !PASSWORD) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'invalid user or password'</span>);</span><br><span class="line">    process.exit();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printIturingBooks(USER, PASSWORD, SAVE_DIR);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>puppeteer</category>
        <category>案例</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
        <tag>自动化测试</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer实践-模拟饿了么外卖下单</title>
    <url>/2020/04/03/puppeteer%E5%AE%9E%E8%B7%B5-%E6%A8%A1%E6%8B%9F%E9%A5%BF%E4%BA%86%E4%B9%88%E5%A4%96%E5%8D%96%E4%B8%8B%E5%8D%95/</url>
    <content><![CDATA[<h2 id="外卖下单"><a href="#外卖下单" class="headerlink" title="外卖下单"></a>外卖下单</h2><p>借助无头浏览器 Puppeteer，以下这个例子仅作为展示模拟一个完整的人机交互：使用移动版饿了么点外卖。</p>
<p><strong>Puppeteer能做什么</strong></p>
<ul>
<li>对网页进行截图保存为图片或 pdf</li>
<li>抓取单页应用(SPA)执行并渲染(解决传统 HTTP 爬虫抓取单页应用难以处理异步请求的问题)</li>
<li>做表单的自动提交、UI的自动化测试、模拟键盘输入等</li>
<li>用浏览器自带的一些调试工具和性能分析工具帮助我们分析问题</li>
<li>写爬虫做你想做的事情~<a id="more"></a>
先看下效果：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200403163839.png" alt=""></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p>craw-spa.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在无头浏览器自动使用单页应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> devices = <span class="built_in">require</span>(<span class="string">'puppeteer/DeviceDescriptors'</span>);</span><br><span class="line"><span class="keyword">const</span> iPhone6 = devices[<span class="string">'iPhone 6'</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> crawSpa = <span class="keyword">async</span> url =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'启动浏览器'</span>);</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        <span class="comment">// 关闭无头模式，方便我们看到这个无头浏览器执行的过程</span></span><br><span class="line">        headless: <span class="literal">false</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'打开页面'</span>);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟 iPhone6</span></span><br><span class="line">    <span class="keyword">await</span> page.emulate(iPhone6);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'地址栏输入网页地址'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.goto(url);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'等待页面准备好'</span>);</span><br><span class="line">    <span class="comment">// 这里判断地比较粗暴</span></span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">'.foodentry'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">'.shoplist'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">'.search-wrapper .search'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'点击搜索框'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.tap(<span class="string">'.search-wrapper .search'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">'input[type="search"]'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log('===为了看清楚，傲娇地等两秒===');</span></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'输入世界上最好吃的食物吧！'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.type(<span class="string">'麦当劳'</span>, &#123;</span><br><span class="line">        delay: <span class="number">200</span>, <span class="comment">// 每个字母之间输入的间隔</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'回车开始搜索'</span>);</span><br><span class="line">    <span class="comment">// await page.press('Enter');</span></span><br><span class="line">    <span class="keyword">await</span> page.tap(<span class="string">'button'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'等待搜素结果渲染出来'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">'[class^="index-container"]'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log('===为了看清楚，傲娇地等两秒===');</span></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'找到搜索到的第一家外卖店！'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.tap(<span class="string">'[class^="index-container"]'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log('===为了看清楚，傲娇地等两秒===');</span></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'等待菜单渲染出来'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">'[class^="fooddetails-food-panel"]'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log('===为了看清楚，傲娇地等两秒===');</span></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'直接选一个菜品吧'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.tap(<span class="string">'[class^="fooddetails-cart-button"]'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log('===为了看清楚，傲娇地等两秒===');</span></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'等待加入购物车成功'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">'[class^="bottomNav-cartfooter"]'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log('===为了看清楚，傲娇地等两秒===');</span></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'点到了，把按钮变红以表高兴！'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">'[class^="submit-btn-submitbutton"]'</span>).style.backgroundColor = <span class="string">'red'</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log('===为了看清楚，傲娇地等两秒===');</span></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'检查购物车！'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.tap(<span class="string">'[class^="bottomNav-carticon"]'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// console.log('===为了看清楚，傲娇地等两秒===');</span></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">await</span> page.tap(<span class="string">'[class^="submit-btn-submitbutton"]'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'好了，到这里需要登录才能继续下单，演示到此结束啦！'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5秒后关闭浏览器'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">5000</span>);</span><br><span class="line">    <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = crawSpa;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">require</span>.main === <span class="built_in">module</span>) &#123;</span><br><span class="line">    <span class="comment">// for test</span></span><br><span class="line">    crawSpa(<span class="string">'https://h5.ele.me/msite/'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer系列教程-02元素获取以及操作</title>
    <url>/2020/04/03/puppeteer%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-02%E5%85%83%E7%B4%A0%E8%8E%B7%E5%8F%96%E4%BB%A5%E5%8F%8A%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><p>使用 $ 方法获取，输入元素的css selector定位元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取页面中的id为kw的dom元素</span></span><br><span class="line"><span class="keyword">const</span> input_area = <span class="keyword">await</span> page.$(<span class="string">"#kw"</span>);</span><br></pre></td></tr></table></figure>

<h2 id="操作-输入点击"><a href="#操作-输入点击" class="headerlink" title="操作-输入点击"></a>操作-输入点击</h2><ul>
<li>type 输入文本</li>
<li>click 元素点击<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// puppeteer.launch(&#123;headless:false,defaultViewport:&#123;width:1366,height:768&#125;&#125;).then((browser)=&gt;&#123;</span></span><br><span class="line"><span class="comment">//     browser.newPage().then(page=&gt;&#123;</span></span><br><span class="line"><span class="comment">//         page.goto('https://www.baidu.com')</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;<span class="attr">headless</span>:<span class="literal">false</span>,<span class="attr">defaultViewport</span>:&#123;<span class="attr">width</span>:<span class="number">1366</span>,<span class="attr">height</span>:<span class="number">768</span>&#125;&#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>);</span><br><span class="line">    <span class="keyword">const</span> input_area = <span class="keyword">await</span> page.$(<span class="string">"#kw"</span>);</span><br><span class="line">    <span class="keyword">await</span> input_area.type(<span class="string">"Hello Wrold"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> search_btn = <span class="keyword">await</span> page.$(<span class="string">'#su'</span>);</span><br><span class="line">    <span class="keyword">await</span> search_btn.click();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer实践-自动推荐思否的热门文章到掘金-ui自动化测试</title>
    <url>/2020/04/03/puppeteer%E5%AE%9E%E8%B7%B5-%E8%87%AA%E5%8A%A8%E6%8E%A8%E8%8D%90%E6%80%9D%E5%90%A6%E7%9A%84%E7%83%AD%E9%97%A8%E6%96%87%E7%AB%A0%E5%88%B0%E6%8E%98%E9%87%91-ui%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h1 id="爬取’思否’热门文章并转发到’掘金’"><a href="#爬取’思否’热门文章并转发到’掘金’" class="headerlink" title="爬取’思否’热门文章并转发到’掘金’"></a>爬取’思否’热门文章并转发到’掘金’</h1><h2 id="1、Puppeteer-简介"><a href="#1、Puppeteer-简介" class="headerlink" title="1、Puppeteer 简介"></a>1、Puppeteer 简介</h2><p>Puppeteer 是一个node库，他提供了一组用来操纵Chrome的API, 通俗来说就是一个 headless chrome浏览器 (当然你也可以配置成有UI的，默认是没有的)。既然是浏览器，那么我们手工可以在浏览器上做的事情 Puppeteer 都能胜任, 另外，Puppeteer 翻译成中文是”木偶”意思，所以听名字就知道，操纵起来很方便，你可以很方便的操纵她去实现：</p>
<p><strong>Puppeteer能做什么</strong></p>
<ul>
<li>对网页进行截图保存为图片或 pdf</li>
<li>抓取单页应用(SPA)执行并渲染(解决传统 HTTP 爬虫抓取单页应用难以处理异步请求的问题)</li>
<li>做表单的自动提交、UI的自动化测试、模拟键盘输入等</li>
<li>用浏览器自带的一些调试工具和性能分析工具帮助我们分析问题</li>
<li>写爬虫做你想做的事情~<a id="more"></a>

</li>
</ul>
<p><strong>先上动图/视频看效果</strong><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/sf-jj%20(1).gif" alt=""></p>
<p><strong>开始介绍，第一步，爬取 segmentfault 前30篇热门文章</strong></p>
<ul>
<li>跳转到<a href="https://segmentfault.com/news/frontend" target="_blank" rel="noopener">https://segmentfault.com/news/frontend</a></li>
<li>接着分析SF首页的Dom结构，爬取每篇文章的链接</li>
<li>然后取出每篇文章最重要的 href，title 等信息</li>
</ul>
<p>具体代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> page.goto(<span class="string">'https://segmentfault.com/news/frontend'</span>)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">var</span> SfFeArticleList = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">var</span> list = [...document.querySelectorAll(<span class="string">'.news__list .news__item-title a'</span>)]</span><br><span class="line">       <span class="keyword">return</span> list.map(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;<span class="attr">href</span>: el.href.trim(), <span class="attr">title</span>: el.innerText&#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'./sf-juejin/sf.png'</span>, <span class="attr">type</span>: <span class="string">'png'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>登录掘金 (这里我事先注册了个测试账号,大家可以替换成自己的)</strong></p>
<ul>
<li>跳转到掘金，模拟点击登录按钮</li>
<li>接着，会弹出一个的登录dialog，模拟输入用户名密码</li>
<li>模拟点击登录</li>
</ul>
<p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">await</span> page.goto(<span class="string">'https://juejin.im'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> login = <span class="keyword">await</span> page.$(<span class="string">'.login'</span>)</span><br><span class="line"><span class="keyword">await</span> login.click()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loginPhoneOrEmail = <span class="keyword">await</span> page.$(<span class="string">'[name=loginPhoneOrEmail]'</span>)</span><br><span class="line"><span class="keyword">await</span> loginPhoneOrEmail.click()</span><br><span class="line"><span class="keyword">await</span> page.type(<span class="string">'18516697699@163.com'</span>, &#123;<span class="attr">delay</span>: <span class="number">20</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> password = <span class="keyword">await</span> page.$(<span class="string">'[placeholder=请输入密码]'</span>)</span><br><span class="line"><span class="keyword">await</span> password.click()</span><br><span class="line"><span class="keyword">await</span> page.type(<span class="string">'123456'</span>, &#123;<span class="attr">delay</span>: <span class="number">20</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> authLogin = <span class="keyword">await</span> page.$(<span class="string">'.panel .btn'</span>)</span><br><span class="line"><span class="keyword">await</span> authLogin.click()</span><br></pre></td></tr></table></figure>
<p><strong>.推荐文章（使用第一步从SF爬取的文章信息）</strong></p>
<ul>
<li>模拟点击推荐文章 按钮 “＋”</li>
<li>这时从SF拿到的文章信息就派上用场了，随机取出一篇: Math.floor(Math.random() * 30)</li>
<li>模拟填写推荐表单，点击发布</li>
<li>有时会提示该文章已被分享，那就换一篇吧，再执行一次。</li>
</ul>
<p>代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> seed = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">30</span>)</span><br><span class="line"><span class="keyword">var</span> theArtile = SfFeArticleList[seed]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">await</span> page.$(<span class="string">'.main-nav .ion-android-add'</span>)</span><br><span class="line"><span class="keyword">await</span> add.click()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shareUrl = <span class="keyword">await</span> page.$(<span class="string">'.entry-form-input .url-input'</span>)</span><br><span class="line"><span class="keyword">await</span> shareUrl.click()</span><br><span class="line"><span class="keyword">await</span> page.type(theArtile.href, &#123;<span class="attr">delay</span>: <span class="number">20</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> page.press(<span class="string">'Tab'</span>)</span><br><span class="line"><span class="keyword">await</span> page.type(theArtile.title, &#123;<span class="attr">delay</span>: <span class="number">20</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> page.press(<span class="string">'Tab'</span>)</span><br><span class="line"><span class="keyword">await</span> page.type(theArtile.title, &#123;<span class="attr">delay</span>: <span class="number">20</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> li = [...document.querySelectorAll(<span class="string">'.category-list-box .category-list .item'</span>)]</span><br><span class="line">    li.forEach(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (el.innerText == <span class="string">'前端'</span>)</span><br><span class="line">            el.click()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> submitBtn = <span class="keyword">await</span> page.$(<span class="string">'.submit-btn'</span>)</span><br><span class="line"><span class="keyword">await</span> submitBtn.click()</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">delay</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resolve(<span class="number">1</span>)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">                reject(<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, delay)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> delay = <span class="number">1000</span></span><br><span class="line"><span class="comment">// 以下拿掘金开刀,贡献私人测试账号</span></span><br><span class="line">puppeteer.launch(&#123;<span class="attr">headless</span>: <span class="literal">false</span>&#125;).then(<span class="keyword">async</span> browser =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> page = <span class="keyword">await</span> browser.newPage()</span><br><span class="line">    page.setViewport(&#123;<span class="attr">width</span>: <span class="number">1200</span>, <span class="attr">height</span>: <span class="number">600</span>&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 1. 到sf获取最新的前端文章 **/</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> page.goto(<span class="string">'https://segmentfault.com/news/frontend'</span>)</span><br><span class="line">        <span class="keyword">await</span> timeout(delay)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> SfFeArticleList = <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> list = [...document.querySelectorAll(<span class="string">'.news__list .news__item-title a'</span>)]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> list.map(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">href</span>: el.href.trim(), <span class="attr">title</span>: el.innerText&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'SfFeArticleList:'</span>, SfFeArticleList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'./data/sf-juejin/sf.png'</span>, <span class="attr">type</span>: <span class="string">'png'</span>&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'sf err:'</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 登录juejin **/</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> timeout(<span class="number">3000</span>)</span><br><span class="line">        <span class="keyword">await</span> page.goto(<span class="string">'https://juejin.im'</span>)</span><br><span class="line">        <span class="keyword">await</span> timeout(<span class="number">3000</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> login = <span class="keyword">await</span> page.$(<span class="string">'.login'</span>)</span><br><span class="line">        <span class="keyword">await</span> login.click()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> loginPhoneOrEmail = <span class="keyword">await</span> page.$(<span class="string">'[name=loginPhoneOrEmail]'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'loginPhoneOrEmail:'</span>, loginPhoneOrEmail);</span><br><span class="line">        <span class="keyword">await</span> loginPhoneOrEmail.click()</span><br><span class="line">        <span class="keyword">await</span> page.type(<span class="string">'18516697699@163.com'</span>, &#123;<span class="attr">delay</span>: <span class="number">20</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> password = <span class="keyword">await</span> page.$(<span class="string">'[placeholder=请输入密码]'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'password:'</span>, password);</span><br><span class="line">        <span class="keyword">await</span> password.click()</span><br><span class="line">        <span class="keyword">await</span> page.type(<span class="string">'aaa123456'</span>, &#123;<span class="attr">delay</span>: <span class="number">20</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> authLogin = <span class="keyword">await</span> page.$(<span class="string">'.panel .btn'</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'authLogin:'</span>, authLogin);</span><br><span class="line">        <span class="keyword">await</span> authLogin.click()</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 随机推荐一篇从sf拿来的文章到掘金 **/</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> timeout(<span class="number">2500</span>)</span><br><span class="line">        <span class="keyword">var</span> seed = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">30</span>)</span><br><span class="line">        <span class="keyword">var</span> theArtile = SfFeArticleList[seed]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> add = <span class="keyword">await</span> page.$(<span class="string">'.main-nav .more'</span>)</span><br><span class="line">        <span class="keyword">await</span> add.click()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> addLink = <span class="keyword">await</span> page.$(<span class="string">'.more-list .item'</span>)</span><br><span class="line">        <span class="keyword">await</span> addLink.click()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> timeout(<span class="number">2500</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> shareUrl = <span class="keyword">await</span> page.$(<span class="string">'.entry-form-input .url-input'</span>)</span><br><span class="line">        <span class="keyword">await</span> shareUrl.click()</span><br><span class="line">        <span class="keyword">await</span> page.type(theArtile.href, &#123;<span class="attr">delay</span>: <span class="number">20</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> page.press(<span class="string">'Tab'</span>)</span><br><span class="line">        <span class="keyword">await</span> page.type(theArtile.title, &#123;<span class="attr">delay</span>: <span class="number">20</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> page.press(<span class="string">'Tab'</span>)</span><br><span class="line">        <span class="keyword">await</span> page.type(theArtile.title, &#123;<span class="attr">delay</span>: <span class="number">20</span>&#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> li = [...document.querySelectorAll(<span class="string">'.category-list-box .category-list .item'</span>)]</span><br><span class="line">            li.forEach(<span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (el.innerText == <span class="string">'前端'</span>)</span><br><span class="line">                    el.click()</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> submitBtn = <span class="keyword">await</span> page.$(<span class="string">'.submit-btn'</span>)</span><br><span class="line">        <span class="keyword">await</span> submitBtn.click()</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'./data/sf-juejin/err.png'</span>, <span class="attr">type</span>: <span class="string">'png'</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">path</span>: <span class="string">'./data/sf-juejin/done.png'</span>, <span class="attr">type</span>: <span class="string">'png'</span>&#125;);</span><br><span class="line">    <span class="comment">// await page.close()</span></span><br><span class="line">    <span class="comment">// browser.close()</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>puppeteer</category>
        <category>案例</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
        <tag>自动化测试</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer系列教程-Puppeteer 初探</title>
    <url>/2020/04/03/puppeteer%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-01puppeteer%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="Puppeteer是什么？"><a href="#Puppeteer是什么？" class="headerlink" title="Puppeteer是什么？"></a>Puppeteer是什么？</h2><p>Puppeteer是一个Node库，它提供了一个高级API来通过DevTools协议控制无头 Chrome或Chromium ，它也可以配置为使用完整（非无头）Chrome或Chromium。</p>
<p>你可以通过Puppeteer的提供的api直接控制Chrome模拟大部分用户操作来进行UI Test或者作为爬虫访问页面来收集数据。</p>
<a id="more"></a>

<h2 id="为什么会产生Puppeteer呢？"><a href="#为什么会产生Puppeteer呢？" class="headerlink" title="为什么会产生Puppeteer呢？"></a>为什么会产生Puppeteer呢？</h2><p>很早很早之前，前端就有了对 headless 浏览器的需求，最多的应用场景有两个</p>
<ul>
<li>UI 自动化测试：摆脱手工浏览点击页面确认功能模式</li>
<li>爬虫：解决页面内容异步加载等问题</li>
</ul>
<h2 id="Puppeteer能做什么？"><a href="#Puppeteer能做什么？" class="headerlink" title="Puppeteer能做什么？"></a>Puppeteer能做什么？</h2><p>你可以在浏览器中手动完成的大部分事情都可以使用Puppteer完成<br>比如：</p>
<ul>
<li>生成页面的屏幕截图和PDF。</li>
<li>抓取SPA并生成预先呈现的内容（即“SSR”）。</li>
<li>自动表单提交，UI测试，键盘输入等。</li>
<li>创建一个最新的自动化测试环境。使用最新的的JavaScript和浏览器功能，直接在最新版本的Chrome浏览器中运行测试。</li>
<li>捕获您网站的时间线跟踪，以帮助诊断性能问题。</li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li><a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/#/" target="_blank" rel="noopener">文档</a></li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>安装node.js  <a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></li>
<li>配置npm 源为国内淘宝源  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> registry=http://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li>
<li>设置puppeteer 中chromuim 下载地址为国内镜像  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> puppeteer_download_host=https://npm.taobao.org/mirrors</span><br></pre></td></tr></table></figure></li>
<li>安装 puppeteer  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install puppeteer</span><br><span class="line"> 或者</span><br><span class="line"> yarn add puppeteer</span><br></pre></td></tr></table></figure></li>
<li>运行  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- app.js --&gt;</span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">puppeteer.launch(&#123;<span class="attr">headless</span>:<span class="literal">false</span>,<span class="attr">defaultViewport</span>:&#123;<span class="attr">width</span>:<span class="number">1366</span>,<span class="attr">height</span>:<span class="number">768</span>&#125;&#125;).then(<span class="function">(<span class="params">browser</span>)=&gt;</span>&#123;</span><br><span class="line">    browser.newPage().then(<span class="function"><span class="params">page</span>=&gt;</span>&#123;</span><br><span class="line">        page.goto(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node app.js</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>初试 Puppeteer，截个图吧</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> (puppeteer.launch(&#123;</span><br><span class="line">    <span class="comment">//设置超时时间</span></span><br><span class="line">    timeout: <span class="number">15000</span>,</span><br><span class="line">    <span class="comment">//如果是访问https页面 此属性会忽略https错误</span></span><br><span class="line">    ignoreHTTPSErrors: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 打开开发者工具, 当此值为true时, headless总为false</span></span><br><span class="line">    devtools: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 关闭headless模式, 不会打开浏览器</span></span><br><span class="line">    headless: <span class="literal">false</span></span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">'https://www.jianshu.com/u/40909ea33e50'</span>);</span><br><span class="line">  <span class="keyword">await</span> page.screenshot(&#123;</span><br><span class="line">    path: <span class="string">'jianshu.png'</span>,</span><br><span class="line">    type: <span class="string">'png'</span>,</span><br><span class="line">    <span class="comment">// quality: 100, 只对jpg有效</span></span><br><span class="line">    fullPage: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 指定区域截图，clip和fullPage两者只能设置一个</span></span><br><span class="line">    <span class="comment">// clip: &#123;</span></span><br><span class="line">    <span class="comment">//   x: 0,</span></span><br><span class="line">    <span class="comment">//   y: 0,</span></span><br><span class="line">    <span class="comment">//   width: 1000,</span></span><br><span class="line">    <span class="comment">//   height: 40</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">  &#125;);</span><br><span class="line">  browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer系列教程-03获取文本值</title>
    <url>/2020/04/03/puppeteer%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-03%E8%8E%B7%E5%8F%96%E6%96%87%E6%9C%AC%E5%80%BC/</url>
    <content><![CDATA[<h2 id="获取文本值"><a href="#获取文本值" class="headerlink" title="获取文本值"></a>获取文本值</h2><p>$eval(selector,pagefunction)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;<span class="attr">headless</span>:<span class="literal">false</span>,<span class="attr">defaultViewport</span>:&#123;<span class="attr">width</span>:<span class="number">1366</span>,<span class="attr">height</span>:<span class="number">768</span>&#125;&#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>);</span><br><span class="line">    <span class="keyword">const</span> input_area = <span class="keyword">await</span> page.$(<span class="string">"#kw"</span>);</span><br><span class="line">    <span class="keyword">await</span> input_area.type(<span class="string">"Hello Wrold"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> search_btn = <span class="keyword">await</span> page.$(<span class="string">'#su'</span>);</span><br><span class="line">    <span class="keyword">await</span> search_btn.click();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="string">'div#content_left &gt; div.result-op.c-container.xpath-log'</span>,&#123;<span class="attr">visible</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> resultText = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'div#content_left &gt; div.result-op.c-container.xpath-log'</span>,ele=&gt; ele.innerText)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"result Text= "</span>,resultText);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工具</category>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer系列教程-05处理多个元素</title>
    <url>/2020/04/03/puppeteer%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-05%E5%A4%84%E7%90%86%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="多个元素处理"><a href="#多个元素处理" class="headerlink" title="多个元素处理"></a>多个元素处理</h2><ul>
<li>$$()</li>
<li>$$eval()<br>代码片段<br>京东手机列表<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">jd</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;<span class="attr">headless</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://www.jd.com'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> input = <span class="keyword">await</span> page.$(<span class="string">'#key'</span>)</span><br><span class="line">    <span class="keyword">await</span> input.type(<span class="string">'手机'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.press(<span class="string">'Enter'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">'ul.gl-warp&gt;li'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> list = <span class="keyword">await</span> page.$$<span class="built_in">eval</span>(<span class="string">'ul.gl-warp&gt;li'</span>,eles=&gt;eles.map(<span class="function"><span class="params">ele</span>=&gt;</span>ele.innerText))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'List =='</span>,list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jd();</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer系列教程-06切换frame进行安居客登陆操作</title>
    <url>/2020/04/03/puppeteer%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-06%E5%88%87%E6%8D%A2frame%E8%BF%9B%E8%A1%8C%E5%AE%89%E5%B1%85%E5%AE%A2%E7%99%BB%E9%99%86%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="切换frame"><a href="#切换frame" class="headerlink" title="切换frame"></a>切换frame</h2><p>使用api  <code>page.frames()</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">anjuke</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;<span class="attr">headless</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://login.anjuke.com/login/form'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换iframe</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.frames().map(<span class="function"><span class="params">frame</span> =&gt;</span> &#123;<span class="built_in">console</span>.log(frame.url())&#125;)</span><br><span class="line">    <span class="keyword">const</span> targetFrameUrl = <span class="string">'https://login.anjuke.com/login/iframeform'</span></span><br><span class="line">    <span class="keyword">const</span> frame =  <span class="keyword">await</span> page.frames().find(<span class="function"><span class="params">frame</span> =&gt;</span> frame.url().includes(targetFrameUrl));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> phone= <span class="keyword">await</span> frame.waitForSelector(<span class="string">'#phoneIpt'</span>)</span><br><span class="line">    <span class="keyword">await</span> phone.type(<span class="string">"13411112222"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">anjuke();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer系列教程-07拖拽验证码操作</title>
    <url>/2020/04/03/puppeteer%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-07%E6%8B%96%E6%8B%BD%E9%AA%8C%E8%AF%81%E7%A0%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="拖拽操作"><a href="#拖拽操作" class="headerlink" title="拖拽操作"></a>拖拽操作</h2><p>使用 api <code>mouse</code></p>
<p>自动化操作阿里云注册页面的验证码部分<br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200403130504.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">aliyun</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;<span class="attr">headless</span>:<span class="literal">false</span>,<span class="attr">ignoreDefaultArgs</span>:[<span class="string">'--enable-automation'</span>]&#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://account.aliyun.com/register/register.htm'</span>,&#123;<span class="attr">waitUntil</span>:<span class="string">"networkidle2"</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> frame = <span class="keyword">await</span> page.frames().find(<span class="function"><span class="params">frame</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(frame.url())</span><br><span class="line">        <span class="keyword">return</span> frame.url().includes(<span class="string">'https://passport.aliyun.com/member/reg/fast/fast_reg.htm'</span>)</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> span = <span class="keyword">await</span> frame.waitForSelector(<span class="string">'#nc_1_n1z'</span>);</span><br><span class="line">    <span class="keyword">const</span> spaninfo = <span class="keyword">await</span> span.boundingBox();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'spaninfo'</span>,spaninfo)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">await</span> page.mouse.move(spaninfo.x,spaninfo.y);</span><br><span class="line">    <span class="keyword">await</span> page.mouse.down();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> div = <span class="keyword">await</span> frame.waitForSelector(<span class="string">'div#nc_1__scale_text &gt; span.nc-lang-cnt'</span>);</span><br><span class="line">    <span class="keyword">const</span> divinfo = <span class="keyword">await</span> div.boundingBox();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'divinfo'</span>,divinfo)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;divinfo.width;i++)&#123;</span><br><span class="line">        <span class="keyword">await</span> page.mouse.move(spaninfo.x+i,spaninfo.y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> page.mouse.up();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">aliyun();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer系列教程-09模拟快捷键操作</title>
    <url>/2020/04/03/puppeteer%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-09%E6%A8%A1%E6%8B%9F%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="模拟快捷键"><a href="#模拟快捷键" class="headerlink" title="模拟快捷键"></a>模拟快捷键</h2><p>使用api <code>page.keyborder</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        headless:<span class="literal">false</span>,</span><br><span class="line">        defaultViewport:&#123;<span class="attr">width</span>:<span class="number">1200</span>,<span class="attr">height</span>:<span class="number">700</span>&#125;, </span><br><span class="line">        ignoreDefaultArgs:[<span class="string">'--enable-automation'</span>],</span><br><span class="line">        slowMo:<span class="number">200</span>,</span><br><span class="line">        args:[<span class="string">'--window-size=1200,700'</span>]&#125;)</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://39.107.96.138:3000/signin'</span>,&#123;<span class="attr">waitUntil</span>:<span class="string">'networkidle2'</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> username = <span class="keyword">await</span> page.waitForSelector(<span class="string">'#name'</span>);</span><br><span class="line">    <span class="keyword">await</span> username.click();</span><br><span class="line">    <span class="keyword">await</span> username.type(<span class="string">'user1'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> passwd = <span class="keyword">await</span> page.waitForSelector(<span class="string">'#pass'</span>);</span><br><span class="line">    <span class="keyword">await</span> passwd.click();</span><br><span class="line">    <span class="keyword">await</span> passwd.type(<span class="string">'123456'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> loginBtn = <span class="keyword">await</span> page.waitForSelector(<span class="string">'.span-primary'</span>);</span><br><span class="line">    <span class="keyword">await</span> loginBtn.click();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> createTopicBtn = <span class="keyword">await</span> page.waitForSelector(<span class="string">'#create_topic_btn'</span>);</span><br><span class="line">    <span class="keyword">await</span> createTopicBtn.click();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> inputTopic = <span class="keyword">await</span> page.waitForSelector(<span class="string">'.CodeMirror-code'</span>);</span><br><span class="line">    <span class="keyword">await</span> inputTopic.click();</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.type(<span class="string">'helloworld'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ctrl + a</span></span><br><span class="line">    <span class="keyword">await</span> page.keyboard.down(<span class="string">'Control'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.down(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.up(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.down(<span class="string">'Control'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.keyboard.down(<span class="string">'Control'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.down(<span class="string">'b'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.up(<span class="string">'b'</span>);</span><br><span class="line">    <span class="keyword">await</span> page.keyboard.down(<span class="string">'Control'</span>);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">run();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer系列教程-08自动化发布微博</title>
    <url>/2020/04/03/puppeteer%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-08%E8%87%AA%E5%8A%A8%E5%8C%96%E5%8F%91%E5%B8%83%E5%BE%AE%E5%8D%9A/</url>
    <content><![CDATA[<h2 id="自动化发布微博"><a href="#自动化发布微博" class="headerlink" title="自动化发布微博"></a>自动化发布微博</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;username,password&#125; = <span class="built_in">require</span>(<span class="string">'./config'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">        headless:<span class="literal">false</span>,</span><br><span class="line">        defaultViewport:&#123;<span class="attr">width</span>:<span class="number">1200</span>,<span class="attr">height</span>:<span class="number">700</span>&#125;, </span><br><span class="line">        ignoreDefaultArgs:[<span class="string">'--enable-automation'</span>],</span><br><span class="line">        slowMo:<span class="number">200</span>,</span><br><span class="line">        args:[<span class="string">'--window-size=1200,700'</span>]&#125;)</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://wufazhuce.com/'</span>,&#123;<span class="attr">waitUntil</span>:<span class="string">'networkidle2'</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> OneText = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">'div.fp-one-cita &gt; a'</span>,ele=&gt;ele.innerText);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'OneText:'</span>,OneText);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://weibo.com/'</span>,&#123;<span class="attr">waitUntil</span>:<span class="string">'networkidle2'</span>&#125;);</span><br><span class="line">    <span class="keyword">await</span> page.waitFor(<span class="number">2</span>*<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">await</span> page.reload();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> loginUserInput = <span class="keyword">await</span> page.waitForSelector(<span class="string">'input#loginname'</span>);</span><br><span class="line">    <span class="keyword">await</span> loginUserInput.click();</span><br><span class="line">    <span class="keyword">await</span> loginUserInput.type(username);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> loginUserPasswdInput = <span class="keyword">await</span> page.waitForSelector(<span class="string">'input[type="password"]'</span>);</span><br><span class="line">    <span class="keyword">await</span> loginUserPasswdInput.click();</span><br><span class="line">    <span class="keyword">await</span> loginUserPasswdInput.type(password);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> loginBtn = <span class="keyword">await</span> page.waitForSelector(<span class="string">'a[action-type="btn_submit"]'</span>)</span><br><span class="line">    <span class="keyword">await</span> loginBtn.click();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> textarea = <span class="keyword">await</span> page.waitForSelector(<span class="string">'textarea[class="W_input"]'</span>)</span><br><span class="line">    <span class="keyword">await</span> textarea.click();</span><br><span class="line">    <span class="keyword">await</span> textarea.type(OneText);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> sendBtn = <span class="keyword">await</span> page.waitForSelector(<span class="string">'a[node-type="submit"]'</span>);</span><br><span class="line">    <span class="keyword">await</span> sendBtn.click();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer系列教程-10切换浏览器tab页</title>
    <url>/2020/04/03/puppeteer%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-10%E5%88%87%E6%8D%A2%E6%B5%8F%E8%A7%88%E5%99%A8tab%E9%A1%B5/</url>
    <content><![CDATA[<h2 id="切换浏览器tab页"><a href="#切换浏览器tab页" class="headerlink" title="切换浏览器tab页"></a>切换浏览器tab页</h2><p><code>browser.waitForTarget</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">switchWindows</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;<span class="attr">headless</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'http://news.baidu.com/'</span>,&#123;<span class="attr">waitUntil</span>:<span class="string">'networkidle2'</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> link = <span class="keyword">await</span> page.waitForSelector(<span class="string">'li.hdline0&gt; strong'</span>)</span><br><span class="line">    <span class="keyword">await</span> link.click();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> target= <span class="keyword">await</span> browser.waitForTarget(<span class="function"><span class="params">target</span>=&gt;</span>target.url().includes(<span class="string">'cpc.people.com.cn'</span>));</span><br><span class="line">    <span class="keyword">const</span> newpage = <span class="keyword">await</span> target.page();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> newpage.waitForSelector(<span class="string">'div.text_con.text_con01'</span>);</span><br><span class="line">    <span class="keyword">const</span> innerText = <span class="keyword">await</span> newpage.$<span class="built_in">eval</span>(<span class="string">'div.text_con.text_con01'</span>,ele=&gt;ele.innerText);</span><br><span class="line">    <span class="built_in">console</span>.log(innerText);</span><br><span class="line">&#125;</span><br><span class="line">switchWindows();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer系列教程-12执行JavaScript方法</title>
    <url>/2020/04/03/puppeteer%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-12%E6%89%A7%E8%A1%8CJavaScript%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h2 id="执行JavaScript方法"><a href="#执行JavaScript方法" class="headerlink" title="执行JavaScript方法"></a>执行JavaScript方法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;<span class="attr">headless</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://www.ctrip.com/'</span>,&#123;<span class="attr">waitUntil</span>:<span class="string">'networkidle2'</span>&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> page.evaluate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.querySelector(<span class="string">'#HD_CheckIn'</span>).value = <span class="string">"2019-7-20"</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title>puppeteer系列教程-11处理alert窗口</title>
    <url>/2020/04/03/puppeteer%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-11%E5%A4%84%E7%90%86alert%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="处理alert窗口"><a href="#处理alert窗口" class="headerlink" title="处理alert窗口"></a>处理alert窗口</h2><p>dialog api</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;点击显示一个确认对话框.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;button id='btn1' onclick="myFunction1()"&gt;点击&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;p&gt;点击显示一个输入文本的对话框.&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;button id="btn2" onclick="myFunction2()"&gt;Try it&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p id=<span class="string">"demo"</span>&gt;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;script&gt;</span></span><br><span class="line"><span class="regexp">        function myFunction1() &#123;</span></span><br><span class="line"><span class="regexp">            confirm("Press a button!");</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">        function myFunction2() &#123;</span></span><br><span class="line"><span class="regexp">            var person = prompt("Please enter your name", "Harry Potter");</span></span><br><span class="line"><span class="regexp">            if (person != null) &#123;</span></span><br><span class="line"><span class="regexp">                document.getElementById("demo").innerHTML =</span></span><br><span class="line"><span class="regexp">                    "Hello " + person + "! How are you today?";</span></span><br><span class="line"><span class="regexp">            &#125;</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title>pupputeer系列教程-04文件上传</title>
    <url>/2020/04/03/pupputeer%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B-04%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
    <content><![CDATA[<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;<span class="attr">headless</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">'https://www.baidu.com'</span>);</span><br><span class="line">    <span class="keyword">const</span> soutuBtn = <span class="keyword">await</span> page.waitForSelector(<span class="string">'span.soutu-btn'</span>);</span><br><span class="line">    <span class="keyword">await</span> soutuBtn.click();</span><br><span class="line">    <span class="keyword">const</span> uploadPic = <span class="keyword">await</span> page.waitForSelector(<span class="string">'input.upload-pic'</span>)</span><br><span class="line">    <span class="keyword">await</span> uploadPic.uploadFile(<span class="string">'C:\\Users\\zyzhao\\Documents\\puppeteer_teach\\puppeteer.png'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upload();</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
        <category>puppeteer</category>
      </categories>
      <tags>
        <tag>puppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title>python系列-Python输入-输出</title>
    <url>/2020/03/31/python%E7%B3%BB%E5%88%97-Python%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA/</url>
    <content><![CDATA[<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="print-函数"><a href="#print-函数" class="headerlink" title="print 函数"></a>print 函数</h3><p>语法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(values, sep, end, file, flush)</span><br></pre></td></tr></table></figure>
<p><strong>values</strong><br>需要输出的值<br>多个值, 使用 “,” 进行分割</p>
<p><strong>sep</strong><br>分割符<br>多个值, 被输出出来之后, 值与值之间, 会添加指定的分隔符</p>
<p><strong>end</strong><br>输出完毕之后, 以指定的字符, 结束<br>默认是换行 ‘\n’</p>
<p><strong>file</strong><br>表示输出的目标<br>默认是标准的输出(控制台)<code>file=sys.stdout</code><br>还可以是一个可写入的文件句柄</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(<span class="string">"xxx"</span>, <span class="string">"w"</span>)</span><br><span class="line">file=f</span><br></pre></td></tr></table></figure>

<p><strong>flush</strong><br>表示立即输出的意思<br>值为Bool类型,默认False</p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="输出一个值"><a href="#输出一个值" class="headerlink" title="输出一个值"></a>输出一个值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>

<h3 id="输出一个变量"><a href="#输出一个变量" class="headerlink" title="输出一个变量"></a>输出一个变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">55</span></span><br><span class="line">print(num)</span><br></pre></td></tr></table></figure>

<h3 id="输出多个变量"><a href="#输出多个变量" class="headerlink" title="输出多个变量"></a>输出多个变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">num = <span class="number">55</span></span><br><span class="line">num2 = <span class="number">155</span></span><br><span class="line">print(num,num2)</span><br></pre></td></tr></table></figure>

<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="string">'sz'</span></span><br><span class="line">age = <span class="number">18</span></span><br><span class="line">我的名字是xxx, 年龄是xxx</span><br><span class="line">print(<span class="string">"我的名字是%s, 年龄是%d"</span>%(name, age))</span><br><span class="line">print(<span class="string">"我的名字是&#123;0&#125;, 年龄是&#123;1&#125;"</span>.format(name, age))</span><br></pre></td></tr></table></figure>

<h3 id="输出到文件中"><a href="#输出到文件中" class="headerlink" title="输出到文件中"></a>输出到文件中</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">print</span> &gt;&gt;open(<span class="string">"test.txt"</span>, <span class="string">"w"</span>), <span class="string">"12345"</span></span><br><span class="line">f = open(<span class="string">"test.txt"</span>, <span class="string">"w"</span>)</span><br><span class="line">print(<span class="string">"xxxxxxxx"</span>, file=sys.stdout)</span><br></pre></td></tr></table></figure>

<h3 id="输出不自动换行"><a href="#输出不自动换行" class="headerlink" title="输出不自动换行"></a>输出不自动换行</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"abc"</span>, end=<span class="string">""</span>)</span><br></pre></td></tr></table></figure>

<h3 id="输出-使用分隔符分割"><a href="#输出-使用分隔符分割" class="headerlink" title="输出,使用分隔符分割"></a>输出,使用分隔符分割</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, sep=<span class="string">"&amp;&amp;&amp;&amp;&amp;"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python系列-Python介绍一</title>
    <url>/2020/03/31/python%E7%B3%BB%E5%88%97-Python%E4%BB%8B%E7%BB%8D%E4%B8%80/</url>
    <content><![CDATA[<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ul>
<li>一门解释型的高级编程语言</li>
</ul>
<h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><ul>
<li>荷兰人</li>
<li>Guido van Rossum（吉多·范罗苏姆）, 人称“龟叔”</li>
<li>1991年初，Python发布了第一个公开发行版</li>
</ul>
<h2 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h2><ul>
<li>Web全栈开发</li>
<li>图形界面开发</li>
<li>大数据</li>
<li>人工智能</li>
<li>爬虫</li>
<li>系统网络运维</li>
<li>云计算系统管理</li>
</ul>
<h2 id="Python版本"><a href="#Python版本" class="headerlink" title="Python版本"></a>Python版本</h2><p>目前流行版本两个</p>
<ul>
<li>Python2.x</li>
<li>Python3.x</li>
</ul>
<h2 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h2><p>作用:将源码转换成为二进制代码进行运行</p>
<ul>
<li>CPython<br>用C语言开发的，所以叫CPython,官方版本的解释器</li>
<li>IPython<br>基于CPython之上的一个交互式解释器</li>
<li>PyPy<br>目标是为了提高执行速度,采用JIT技术，对Python代码进行动态编译</li>
<li>Jython<br>运行在Java平台上的Python解释器</li>
<li>IronPython<br>和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>reactjs中使用css的方式</title>
    <url>/2020/03/29/reactjs%E4%B8%AD%E4%BD%BF%E7%94%A8css%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>由于 React的JSX语法，能在React中使用样式的方式有很多，本文主要介绍在React中经常使用CSS样式的五种方法：</p>
<ul>
<li>1、行内样式</li>
<li>2、声明样式</li>
<li>3、引入样式</li>
<li>4、CSS Modules模块化</li>
<li>5、Styled-component<a id="more"></a>
<h2 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h2>行内样式是一种最基本的写法，也就是我们最开始学HTML时写的内联样式那样，在项目中可能会比较少用到<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;&#123; <span class="attr">background</span>: <span class="string">'#eee'</span>, <span class="attr">width</span>: <span class="string">'200px'</span>, <span class="attr">height</span>: <span class="string">'200px'</span>&#125;&#125;&gt;</span><br><span class="line">        &lt;p style= &#123;&#123;<span class="attr">color</span>:<span class="string">'red'</span>, <span class="attr">fontSize</span>:<span class="string">'40px'</span>&#125;&#125;&gt;行内样式&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="声明样式"><a href="#声明样式" class="headerlink" title="声明样式"></a>声明样式</h2>声明样式其实是行内样式的一种改进写法，在render函数外部创建style对象，然后传递给组件，让css与标签分离<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"> <span class="keyword">const</span> style1=&#123;    </span><br><span class="line">      background:<span class="string">'#eee'</span>,</span><br><span class="line">      width:<span class="string">'200px'</span>,</span><br><span class="line">      height:<span class="string">'200px'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> style2=&#123;    </span><br><span class="line">      color:<span class="string">'red'</span>,</span><br><span class="line">      fontSize:<span class="string">'40px'</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div style=&#123;style1&#125;&gt;</span><br><span class="line">        &lt;p style= &#123;style2&#125;&gt;行内样式&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="引入样式"><a href="#引入样式" class="headerlink" title="引入样式"></a>引入样式</h2><p>引入样式就是将CSS文件写下外部，在引入jsx使用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* person.css */</span></span><br><span class="line"></span><br><span class="line"><span class="selector-class">.person</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60%</span>;</span><br><span class="line">    <span class="attribute">margin</span>:<span class="number">16px</span> auto;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#eee</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">3px</span> <span class="number">#ccc</span>;</span><br><span class="line">    <span class="attribute">padding</span>:<span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// App.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'./Person.css'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//....  </span></span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=<span class="string">'person'</span>&gt;</span><br><span class="line">        &lt;p&gt;person:Hello world&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt; </span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>
<p> <strong>注意</strong></p>
<blockquote>
<p>因为CSS的规则都是全局的，任何一个组件的样式规则，都对整个页面有效，这可能会导致大量的冲突。</p>
</blockquote>
<h2 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h2><p>CSS Modules 的做法就是通过配置将.css文件进行编译，编译后在每个用到css的组件中的css类名都是独一无二的，从而实现CSS的局部作用域。</p>
<p>create-react-app自从2.0.版本就已经开始支持CSS Modules了</p>
<h3 id="局部样式"><a href="#局部样式" class="headerlink" title="局部样式"></a>局部样式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">命名规则: xxx.module.css     </span><br><span class="line"></span><br><span class="line">引入方式 <span class="keyword">import</span> xxx <span class="keyword">from</span> <span class="string">'xxx.module.css'</span></span><br><span class="line"></span><br><span class="line">用法：&lt;div className=&#123;xxx.styleName&#125;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">命名规则: xxx.css   </span><br><span class="line"></span><br><span class="line">引入方式 <span class="keyword">import</span> ‘xxx.css’</span><br><span class="line"></span><br><span class="line">用法：&lt;div className=<span class="string">'styleName'</span>&gt;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">### 案例：</span></span><br><span class="line"><span class="string">`</span>person.module.css<span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> css</span><br><span class="line"></span><br><span class="line">.person&#123;</span><br><span class="line">    width: <span class="number">60</span>%;</span><br><span class="line">    margin:<span class="number">16</span>px auto;</span><br><span class="line">    border: 1px solid #eee;</span><br><span class="line">    box-shadow: 0 2px 3px #ccc;</span><br><span class="line">    padding:<span class="number">16</span>px;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>person.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部样式</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./Person.module.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../App.css'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;styles.person&#125;&gt;</span><br><span class="line">        &lt;p className=<span class="string">'fz'</span>&gt;person:Hello world&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt; </span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>

<h2 id="Styled-Components"><a href="#Styled-Components" class="headerlink" title="Styled Components"></a>Styled Components</h2><p>随着组件化时代的来临，前端应用开始从组件的层面对 CSS 进行封装：也就是通过 JS 来声明、抽象样式从而提高组件的可维护性；在组件加载时动态的加载样式，动态生成类名从而避免全局污染。Styled Component以组件的形式来声明样式，让样式也成为组件从而分离逻辑组件与展示组件</p>
<p>Styled Component是react的一个第三方库，是CSS in JS 的优秀实践和代表，将CSS写在JS中，可以实现常规CSS所不好处理的逻辑复杂、函数方法、复用、避免干扰。样式书写将直接依附在JSX上面，HTML、CSS、JS三者再次内聚，同时也实现H5的语义化标签表现形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install --save styled-components</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Title 组件,它将渲染一个附加了样式的 &lt;h1&gt; 标签</span></span><br><span class="line"><span class="keyword">const</span> Title = styled.h1<span class="string">`</span></span><br><span class="line"><span class="string">  font-size: 1.5em;</span></span><br><span class="line"><span class="string">  text-align: center;</span></span><br><span class="line"><span class="string">  color: palevioletred;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 Wrapper 组件,它将渲染一个附加了样式的 &lt;section&gt; 标签</span></span><br><span class="line"><span class="keyword">const</span> Wrapper = styled.section<span class="string">`</span></span><br><span class="line"><span class="string">  padding: 4em;</span></span><br><span class="line"><span class="string">  background: papayawhip;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 就像使用常规 React 组件一样使用 Title 和 Wrapper </span></span><br><span class="line">render(</span><br><span class="line">  &lt;Wrapper&gt;</span><br><span class="line">    &lt;Title&gt;</span><br><span class="line">      Hello World!</span><br><span class="line">    &lt;<span class="regexp">/Title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Wrapper&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>vue+node移动电商项目-全栈</title>
    <url>/2016/04/22/vue-node%E7%A7%BB%E5%8A%A8%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE-%E5%85%A8%E6%A0%88/</url>
    <content><![CDATA[<h2 id="koa-vue移动电商"><a href="#koa-vue移动电商" class="headerlink" title="koa+vue移动电商"></a>koa+vue移动电商</h2><p>移动电商系统，包括首页展示，类别展示，购物功能，注册登录，积分系统，查找页面，后台接口设置，数据库采用在线mlab在线的mongo数据库</p>
<a id="more"></a>
<h2 id="主要技术栈列表"><a href="#主要技术栈列表" class="headerlink" title="主要技术栈列表"></a>主要技术栈列表</h2><ul>
<li>Vue</li>
<li>Vuex</li>
<li>Router</li>
<li>Vant</li>
<li>Node</li>
<li>Koa2</li>
<li>Mongoose</li>
<li>MongoDB</li>
</ul>
<h2 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h2><ul>
<li>首页展示</li>
<li>类别展示</li>
<li>购物功能</li>
<li>注册登录</li>
<li>积分系统</li>
<li>查找页面</li>
<li>后台接口设置</li>
</ul>
<h2 id="ScreenShot"><a href="#ScreenShot" class="headerlink" title="ScreenShot"></a>ScreenShot</h2><p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200422173308.png" alt=""><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200422173332.png" alt=""><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200422173350.png" alt=""><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200422173404.png" alt=""></p>
]]></content>
      <categories>
        <category>案例</category>
      </categories>
      <tags>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli3开发Chrome插件实践</title>
    <url>/2020/03/31/vue-cli3%E5%BC%80%E5%8F%91Chrome%E6%8F%92%E4%BB%B6%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>之前找了不少如何开发谷歌插件的文章，结果发现都是些很基础的内容，并没有写到如何快速编译打包插件。我就在想为什么不能通过webpack来打包插件呢？如果通过webpack编译的话，就能使开发过程变得更舒服，使文件结构趋向模块化，并且打包的时候直接编译压缩代码。后来发现了vue-cli-plugin-chrome-ext插件，通过这个插件能很方便地用vue-cli3来开发谷歌插件，并能直接引用各种UI框架跟npm插件。</p>
<a id="more"></a>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ul>
<li>创建一个vue-cli3项目： vue create vue-extension，对话流程选择默认就行。</li>
<li>进入项目cd vue-extension</li>
<li>安装vue-cli-plugin-chrome-ext插件：vue add chrome-ext,根据安装对话选项设置好。</li>
<li>删除vue-cli3无用文件跟文件夹：src/main.js、src/components</li>
</ul>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build-watch</span><br></pre></td></tr></table></figure>
<p>运行开发环境<br>对修改文件进行实时编译并自动在根目录下生成dist文件夹，然后在浏览器上加载dist文件夹完成插件安装。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>
<p>运行生产环境编译打包，将所有文件进行整合打包。</p>
<h2 id="引入element-UI"><a href="#引入element-UI" class="headerlink" title="引入element UI"></a>引入element UI</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install element-ui</span><br></pre></td></tr></table></figure>
<p>考虑到插件打包后的文件大小，最后通过按需加载的方式来引入组件，按照element-ui官方的按需加载方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install babel-plugin-component -D</span><br></pre></td></tr></table></figure>
<p>然后，将babel.config.js修改为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  presets: [</span><br><span class="line">    <span class="string">'@vue/app'</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"component"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">"libraryName"</span>: <span class="string">"element-ui"</span>,</span><br><span class="line">        <span class="string">"styleLibraryName"</span>: <span class="string">"theme-chalk"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来修改popup相关文件引入所需组件， src/popup/index.js内容:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> AppComponent <span class="keyword">from</span> <span class="string">"./App/App.vue"</span>;</span><br><span class="line"> </span><br><span class="line">Vue.component(<span class="string">"app-component"</span>, AppComponent);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  Card</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"> </span><br><span class="line">Vue.use(Card);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">"#app"</span>,</span><br><span class="line">  render: <span class="function"><span class="params">createElement</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(AppComponent);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>src/popup/App/App.vue 内容：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-card</span> <span class="attr">class</span>=<span class="string">"box-card"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">slot</span>=<span class="string">"header"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"clearfix"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>卡片名称<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">"float: right; padding: 3px 0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">      &gt;</span>操作按钮<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">"o in 4"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">:key</span>=<span class="string">"o"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"text item"</span></span></span><br><span class="line"><span class="tag">    &gt;</span></span><br><span class="line">      &#123;&#123;'列表内容 ' + o &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">el-card</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">'app'</span>,</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.box-card</span> &#123;</span></span><br><span class="line">  width: 300px;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>content.js使用element-ui组件</strong><br>content.js主要作用于浏览网页，对打开的网页进行插入、修改DOM，对其进行操作交互</p>
<blockquote>
<p>根据评论的朋友提示，可以通过Chrome插件的chrome.extension.getURLAPI来引入字体文件，解决element-ui无法引入相对路径的字体文件问题。</p>
</blockquote>
<p>首先我们创建src/content/index文件，在里面我们通过chrome.extension.getURLAPI来引入插件的字体文件，内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">    Message,</span><br><span class="line">    MessageBox</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'element-ui'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过Chrome插件的API加载字体文件</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">insertElementIcons</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> elementIcons = <span class="built_in">document</span>.createElement(<span class="string">'style'</span>)</span><br><span class="line">    elementIcons.type = <span class="string">'text/css'</span>;</span><br><span class="line">    elementIcons.textContent = <span class="string">`</span></span><br><span class="line"><span class="string">        @font-face &#123;</span></span><br><span class="line"><span class="string">            font-family: "element-icons";</span></span><br><span class="line"><span class="string">            src: url('<span class="subst">$&#123; <span class="built_in">window</span>.chrome.extension.getURL(<span class="string">"fonts/element-icons.woff"</span>)&#125;</span>') format('woff'),</span></span><br><span class="line"><span class="string">            url('<span class="subst">$&#123; <span class="built_in">window</span>.chrome.extension.getURL(<span class="string">"fonts/element-icons.ttf "</span>)&#125;</span>') format('truetype'); /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    `</span></span><br><span class="line">    <span class="built_in">document</span>.head.appendChild(elementIcons);</span><br><span class="line">&#125;)();</span><br><span class="line"> </span><br><span class="line">MessageBox.alert(<span class="string">'这是一段内容'</span>, <span class="string">'标题名称'</span>, &#123;</span><br><span class="line">    confirmButtonText: <span class="string">'确定'</span>,</span><br><span class="line">    callback: <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">        Message(&#123;</span><br><span class="line">            type: <span class="string">'info'</span>,</span><br><span class="line">            message: <span class="string">`action: <span class="subst">$&#123; action &#125;</span>`</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>vue.config.js增加content.js文件的打包配置，因为content.js（background.js同样可以只生成js文件）只有js文件，不用像app模式那样打包生成相应的html文件。这里我们还要对字体打包配置处理下，因为默认打包后的文件名是带有hash值的，在这里我们要去除掉，完整内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> CopyWebpackPlugin = <span class="built_in">require</span>(<span class="string">"copy-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">"path"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Generate pages object</span></span><br><span class="line"><span class="keyword">const</span> pagesObj = &#123;&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> chromeName = [<span class="string">"popup"</span>, <span class="string">"options"</span>];</span><br><span class="line"> </span><br><span class="line">chromeName.forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">  pagesObj[name] = &#123;</span><br><span class="line">    entry: <span class="string">`src/<span class="subst">$&#123;name&#125;</span>/index.js`</span>,</span><br><span class="line">    template: <span class="string">"public/index.html"</span>,</span><br><span class="line">    filename: <span class="string">`<span class="subst">$&#123;name&#125;</span>.html`</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 生成manifest文件</span></span><br><span class="line"><span class="keyword">const</span> manifest =</span><br><span class="line">  process.env.NODE_ENV === <span class="string">"production"</span> ? &#123;</span><br><span class="line">    <span class="keyword">from</span>: path.resolve(<span class="string">"src/manifest.production.json"</span>),</span><br><span class="line">    to: <span class="string">`<span class="subst">$&#123;path.resolve(<span class="string">"dist"</span>)&#125;</span>/manifest.json`</span></span><br><span class="line">  &#125; : &#123;</span><br><span class="line">    <span class="keyword">from</span>: path.resolve(<span class="string">"src/manifest.development.json"</span>),</span><br><span class="line">    to: <span class="string">`<span class="subst">$&#123;path.resolve(<span class="string">"dist"</span>)&#125;</span>/manifest.json`</span></span><br><span class="line">  &#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> plugins = [</span><br><span class="line">  CopyWebpackPlugin([</span><br><span class="line">    manifest</span><br><span class="line">  ])</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  pages: pagesObj,</span><br><span class="line">  <span class="comment">// // 生产环境是否生成 sourceMap 文件</span></span><br><span class="line">  productionSourceMap: <span class="literal">false</span>,</span><br><span class="line"> </span><br><span class="line">  configureWebpack: &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      <span class="string">'content'</span>: <span class="string">'./src/content/index.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">      filename: <span class="string">'js/[name].js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [CopyWebpackPlugin(plugins)]</span><br><span class="line">  &#125;,</span><br><span class="line">  css: &#123;</span><br><span class="line">    extract: &#123;</span><br><span class="line">      filename: <span class="string">'css/[name].css'</span></span><br><span class="line">      <span class="comment">// chunkFilename: 'css/[name].css'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  chainWebpack: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 处理字体文件名，去除hash值</span></span><br><span class="line">    <span class="keyword">const</span> fontsRule = config.module.rule(<span class="string">'fonts'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 清除已有的所有 loader。</span></span><br><span class="line">    <span class="comment">// 如果你不这样做，接下来的 loader 会附加在该规则现有的 loader 之后。</span></span><br><span class="line">    fontsRule.uses.clear()</span><br><span class="line">    fontsRule.test(<span class="regexp">/\.(woff2?|eot|ttf|otf)(\?.*)?$/i</span>)</span><br><span class="line">      .use(<span class="string">'url'</span>)</span><br><span class="line">      .loader(<span class="string">'url-loader'</span>)</span><br><span class="line">      .options(&#123;</span><br><span class="line">        limit: <span class="number">1000</span>,</span><br><span class="line">        name: <span class="string">'fonts/[name].[ext]'</span></span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最后在manifest.development.json加载content.js文件，以及将字体文件添加到网页可加载资源字段web_accessible_resources里去：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"vue-extension"</span>,</span><br><span class="line">    <span class="string">"description"</span>: <span class="string">"a chrome extension with vue-cli3"</span>,</span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">    <span class="string">"options_page"</span>: <span class="string">"options.html"</span>,</span><br><span class="line">    <span class="string">"browser_action"</span>: &#123;</span><br><span class="line">        <span class="string">"default_popup"</span>: <span class="string">"popup.html"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"content_security_policy"</span>: <span class="string">"script-src 'self' 'unsafe-eval'; object-src 'self'"</span>,</span><br><span class="line">    <span class="string">"content_scripts"</span>: [&#123;</span><br><span class="line">        <span class="string">"matches"</span>: [</span><br><span class="line">            <span class="string">"*://*.baidu.com/*"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"js"</span>: [</span><br><span class="line">            <span class="string">"js/content.js"</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"run_at"</span>: <span class="string">"document_end"</span></span><br><span class="line">    &#125;],</span><br><span class="line">    <span class="string">"web_accessible_resources"</span>: [<span class="string">"fonts/*"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实时刷新插件"><a href="#实时刷新插件" class="headerlink" title="实时刷新插件"></a>实时刷新插件</h2><p>之前写的时候发现单纯地通过vue-cli3更新代码并不能使插件的background.js、content.js也跟着更新，因为代码已经加载到浏览器了，浏览器并不会监听这些文件的变化。也是通过评论的朋友推荐，通过crx-hotreload可以完美实现实时刷新功能，而不用重新手动加载。代码还简单易用，在这里我们直接将代码复制到src/utils/hot-reload.js文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 代码来源：https://github.com/xpl/crx-hotreload/edit/master/hot-reload.js</span></span><br><span class="line"><span class="keyword">const</span> filesInDirectory = <span class="function"><span class="params">dir</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span></span><br><span class="line">    dir.createReader().readEntries(<span class="function"><span class="params">entries</span> =&gt;</span></span><br><span class="line">        <span class="built_in">Promise</span>.all(entries.filter(<span class="function"><span class="params">e</span> =&gt;</span> e.name[<span class="number">0</span>] !== <span class="string">'.'</span>).map(<span class="function"><span class="params">e</span> =&gt;</span></span><br><span class="line">            e.isDirectory ?</span><br><span class="line">            filesInDirectory(e) :</span><br><span class="line">            <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> e.file(resolve))</span><br><span class="line">        ))</span><br><span class="line">        .then(<span class="function"><span class="params">files</span> =&gt;</span> [].concat(...files))</span><br><span class="line">        .then(resolve)</span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> timestampForFilesInDirectory = <span class="function"><span class="params">dir</span> =&gt;</span></span><br><span class="line">    filesInDirectory(dir).then(<span class="function"><span class="params">files</span> =&gt;</span></span><br><span class="line">        files.map(<span class="function"><span class="params">f</span> =&gt;</span> f.name + f.lastModifiedDate).join())</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> reload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.chrome.tabs.query(&#123;</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        currentWindow: <span class="literal">true</span></span><br><span class="line">    &#125;, tabs =&gt; &#123; <span class="comment">// NB: see https://github.com/xpl/crx-hotreload/issues/5</span></span><br><span class="line">        <span class="keyword">if</span> (tabs[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="built_in">window</span>.chrome.tabs.reload(tabs[<span class="number">0</span>].id)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">window</span>.chrome.runtime.reload()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> watchChanges = <span class="function">(<span class="params">dir, lastTimestamp</span>) =&gt;</span> &#123;</span><br><span class="line">    timestampForFilesInDirectory(dir).then(<span class="function"><span class="params">timestamp</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lastTimestamp || (lastTimestamp === timestamp)) &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> watchChanges(dir, timestamp), <span class="number">1000</span>) <span class="comment">// retry after 1s</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reload()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">window</span>.chrome.management.getSelf(<span class="function"><span class="params">self</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (self.installType === <span class="string">'development'</span>) &#123;</span><br><span class="line">        <span class="built_in">window</span>.chrome.runtime.getPackageDirectoryEntry(<span class="function"><span class="params">dir</span> =&gt;</span> watchChanges(dir))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后在vue.config.js对热刷新代码进行处理，如果是开发环境的话就将其复制到assets文件夹里面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// vue.config.js</span></span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 在这段下面添加</span></span><br><span class="line"><span class="keyword">const</span> plugins = [</span><br><span class="line">  CopyWebpackPlugin([</span><br><span class="line">    manifest</span><br><span class="line">  ])</span><br><span class="line">]</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 开发环境将热加载文件复制到dist文件夹</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  plugins.push(</span><br><span class="line">    CopyWebpackPlugin([&#123;</span><br><span class="line">      <span class="keyword">from</span>: path.resolve(<span class="string">"src/utils/hot-reload.js"</span>),</span><br><span class="line">      to: path.resolve(<span class="string">"dist"</span>)</span><br><span class="line">    &#125;])</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后只要在开发环境manifest.development.json里配置一下，将hot-reload.js加载到background运行环境中即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"background"</span>: &#123; <span class="string">"scripts"</span>: [<span class="string">"hot-reload.js"</span>] &#125;</span><br></pre></td></tr></table></figure>

<p>搞定收工！</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>浏览器插件开发</category>
        <category>案例</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>浏览器插件开发</tag>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>vue+小程序+app保险综合平台</title>
    <url>/2016/04/22/vue-%E5%B0%8F%E7%A8%8B%E5%BA%8F-app%E4%BF%9D%E9%99%A9%E7%BB%BC%E5%90%88%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<h2 id="晟联-保信平台"><a href="#晟联-保信平台" class="headerlink" title="晟联/保信平台"></a>晟联/保信平台</h2><p>基于保险，法律，广告的整合传播平台， 负责整个项目PC、移动、小程序、APP端的前端工作</p>
<h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><h3 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h3><ul>
<li><p>开发模式：前后端分离</p>
</li>
<li><p>前后通信:axios</p>
</li>
<li><p>UI框架：bootstarp、layui</p>
</li>
<li><p>JS框架：jquery</p>
</li>
<li><p>可视化框架：echarts</p>
</li>
<li><p>涉及功能：</p>
<ul>
<li>登陆权限验证、商品展示、jsonp、前后端交互、文档撰写</li>
<li>懒加载、标签云、无缝轮播、二维码生成、<a id="more"></a>
<h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3></li>
</ul>
</li>
<li><p>开发模式：前后端分离</p>
</li>
<li><p>前端框架：VUE、vueRouter、vant</p>
</li>
<li><p>可视化框架：echarts</p>
</li>
<li><p>前后通信:axios</p>
</li>
<li><p>css预处理：less</p>
</li>
<li><p>构建工具：webpack</p>
</li>
</ul>
<h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><p>css框架 ：weui</p>
<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200422173747.png" alt=""><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200422173801.png" alt=""><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200422173817.png" alt=""><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200422173829.png" alt=""></p>
]]></content>
      <categories>
        <category>案例</category>
      </categories>
      <tags>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>react组件的6种通信方式</title>
    <url>/2020/04/04/react%E7%BB%84%E4%BB%B6%E7%9A%846%E7%A7%8D%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>问React组件有哪些通信方式？</p>
<ul>
<li>1.props父子通信</li>
<li>2.回调函数，子父通信</li>
<li>3.变量提升，兄弟组建通信</li>
<li>4.Context,跨组建通信</li>
<li>5.node的events模块的单例通信</li>
<li>6.redux共享数据通信</li>
</ul>
<a id="more"></a>

<h2 id="1-props父子通信"><a href="#1-props父子通信" class="headerlink" title="1.props父子通信"></a>1.props父子通信</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Children</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;p&gt;Children&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;p&gt;&#123;props.text&#125;&lt;/</span>p&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Parent() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;Parent&lt;/</span>p&gt;</span><br><span class="line">      &lt;Children text=<span class="string">"这是爸爸传给你的东西"</span>&gt;&lt;<span class="regexp">/Children&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Parent</span><br></pre></td></tr></table></figure>

<h2 id="2-回调函数，子父通信"><a href="#2-回调函数，子父通信" class="headerlink" title="2.回调函数，子父通信"></a>2.回调函数，子父通信</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Children</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Children&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;props.text&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;button </span><br><span class="line">        onClick=&#123;() =&gt; &#123; props.handleChange(<span class="string">'改变了'</span>) &#125;&#125;&gt;</span><br><span class="line">        点击我改变爸爸传给我的东西</span><br><span class="line">      &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [text, setText] = useState(<span class="string">'这是爸爸传给你的东西'</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleChange</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    setText(val)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Parent&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Children handleChange=&#123;handleChange&#125; text=&#123;text&#125;&gt;&lt;/</span>Children&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Parent</span></span><br></pre></td></tr></table></figure>

<h2 id="3-变量提升，兄弟组建通信"><a href="#3-变量提升，兄弟组建通信" class="headerlink" title="3.变量提升，兄弟组建通信"></a>3.变量提升，兄弟组建通信</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Children</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Children&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button </span></span><br><span class="line"><span class="regexp">        onClick=&#123;() =&gt; &#123; props.setText('我是Children发的信息') &#125;&#125;&gt;</span></span><br><span class="line"><span class="regexp">        给Children1发信息&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function Children1(props) &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;Children1&lt;/</span>p&gt;</span><br><span class="line">      &lt;p&gt;&#123;props.text&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [text, setText] = useState(<span class="string">''</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;div&gt;APP&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Children setText=&#123;setText&#125;&gt;&lt;/</span>Children&gt;</span><br><span class="line">      &lt;Children1 text=&#123;text&#125;&gt;&lt;<span class="regexp">/Children1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>

<h2 id="4-Context-跨组建通信"><a href="#4-Context-跨组建通信" class="headerlink" title="4.Context,跨组建通信"></a>4.Context,跨组建通信</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; Consumer, Provider &#125; = React.createContext()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Children</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Consumer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          (value) =&gt; (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">              &lt;p&gt;Children1&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">              &lt;p&gt;&#123;value.text&#125;&lt;/</span>p&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">          )</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Consumer&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider value=&#123;&#123; <span class="attr">text</span>: <span class="string">'我是context'</span> &#125;&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;p&gt;Parent&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Children1&gt;&lt;/</span>Children1&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Parent</span><br></pre></td></tr></table></figure>

<h2 id="5-node的events模块的单例通信"><a href="#5-node的events模块的单例通信" class="headerlink" title="5.node的events模块的单例通信"></a>5.node的events模块的单例通信</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Children</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Children&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;p&gt;&#123;props.text&#125;&lt;/</span>p&gt;</span><br><span class="line">      &lt;button </span><br><span class="line">        onClick=&#123;() =&gt; &#123; props.event.emit(<span class="string">'foo'</span>) &#125;&#125;&gt;点击我改变爸爸传给我的东西&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [text, setText] = useState(<span class="string">'这是爸爸传给你的东西'</span>)</span><br><span class="line">  <span class="keyword">let</span> event = <span class="keyword">new</span> Events()</span><br><span class="line">  event.on(<span class="string">'foo'</span>, () =&gt; &#123; setText(<span class="string">'改变了'</span>) &#125;)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;Parent&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Children event=&#123;event&#125; text=&#123;text&#125;&gt;&lt;/</span>Children&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default Parent</span></span><br></pre></td></tr></table></figure>
<p>注意</p>
<blockquote>
<p>这种通信记住在顶部引入events模块，无需安装，node自身模块。</p>
</blockquote>
<h2 id="6-redux共享数据通信"><a href="#6-redux共享数据通信" class="headerlink" title="6.redux共享数据通信"></a>6.redux共享数据通信</h2><p>store.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> defaultState = &#123;</span><br><span class="line">    text: <span class="string">'我是store'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reducer = <span class="function">(<span class="params">state = defaultState, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(reducer)</span><br></pre></td></tr></table></figure>
<p>child.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div&gt;Child&lt;p&gt;&#123;<span class="keyword">this</span>.props.text&#125;&lt;<span class="regexp">/p&gt;&lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> mapStataToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        text: state.text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStataToProps, <span class="literal">null</span>)(Child)</span><br></pre></td></tr></table></figure>
<p>Parent.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;p&gt;Parent&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Child&gt;&lt;/</span>Child&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Provider&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Parent</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack配置详解</title>
    <url>/2020/04/21/webpack%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>上官方文档镇楼</strong></p>
<p><a href="https://www.webpackjs.com/concepts/" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p>目录结构</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421165252.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  entry: 入口起点</span></span><br><span class="line"><span class="comment">    1. string --&gt; './src/index.js'</span></span><br><span class="line"><span class="comment">      单入口</span></span><br><span class="line"><span class="comment">      打包形成一个chunk。 输出一个bundle文件。</span></span><br><span class="line"><span class="comment">      此时chunk的名称默认是 main</span></span><br><span class="line"><span class="comment">    2. array  --&gt; ['./src/index.js', './src/add.js']</span></span><br><span class="line"><span class="comment">      多入口</span></span><br><span class="line"><span class="comment">      所有入口文件最终只会形成一个chunk, 输出出去只有一个bundle文件。</span></span><br><span class="line"><span class="comment">        --&gt; 只有在HMR功能中让html热更新生效~</span></span><br><span class="line"><span class="comment">    3. object</span></span><br><span class="line"><span class="comment">      多入口</span></span><br><span class="line"><span class="comment">      有几个入口文件就形成几个chunk，输出几个bundle文件</span></span><br><span class="line"><span class="comment">      此时chunk的名称是 key</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      --&gt; 特殊用法</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">          // 所有入口文件最终只会形成一个chunk, 输出出去只有一个bundle文件。</span></span><br><span class="line"><span class="comment">          index: ['./src/index.js', './src/count.js'], </span></span><br><span class="line"><span class="comment">          // 形成一个chunk，输出一个bundle文件。</span></span><br><span class="line"><span class="comment">          add: './src/add.js'</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    index: [<span class="string">'./src/index.js'</span>, <span class="string">'./src/count.js'</span>], </span><br><span class="line">    add: <span class="string">'./src/add.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> HtmlWebpackPlugin()],</span><br><span class="line">  mode: <span class="string">'development'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>目录结构</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421165252.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 文件名称（指定名称+目录）</span></span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">    <span class="comment">// 输出文件目录（将来所有资源输出的公共目录）</span></span><br><span class="line">    path: resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">    <span class="comment">// 所有资源引入公共路径前缀 --&gt; 'imgs/a.jpg' --&gt; '/imgs/a.jpg'</span></span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    chunkFilename: <span class="string">'js/[name]_chunk.js'</span>, <span class="comment">// 非入口chunk的名称</span></span><br><span class="line">    <span class="comment">// library: '[name]', // 整个库向外暴露的变量名</span></span><br><span class="line">    <span class="comment">// libraryTarget: 'window' // 变量名添加到哪个上 browser</span></span><br><span class="line">    <span class="comment">// libraryTarget: 'global' // 变量名添加到哪个上 node</span></span><br><span class="line">    <span class="comment">// libraryTarget: 'commonjs'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> HtmlWebpackPlugin()],</span><br><span class="line">  mode: <span class="string">'development'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="module"><a href="#module" class="headerlink" title="module"></a>module</h2><p>目录结构</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421165252.png" alt=""></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">    path: resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      <span class="comment">// loader的配置</span></span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        <span class="comment">// 多个loader用use</span></span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        <span class="comment">// 排除node_modules下的js文件</span></span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        <span class="comment">// 只检查 src 下的js文件</span></span><br><span class="line">        include: resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">        <span class="comment">// 优先执行</span></span><br><span class="line">        enforce: <span class="string">'pre'</span>,</span><br><span class="line">        <span class="comment">// 延后执行</span></span><br><span class="line">        <span class="comment">// enforce: 'post',</span></span><br><span class="line">        <span class="comment">// 单个loader用loader</span></span><br><span class="line">        loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">        options: &#123;&#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 以下配置只会生效一个</span></span><br><span class="line">        oneOf: []</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> HtmlWebpackPlugin()],</span><br><span class="line">  mode: <span class="string">'development'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/js/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">    path: resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> HtmlWebpackPlugin()],</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="comment">// 解析模块的规则</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 配置解析模块路径别名: 优点简写路径 缺点路径没有提示</span></span><br><span class="line">    alias: &#123;</span><br><span class="line">      $css: resolve(__dirname, <span class="string">'src/css'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 配置省略文件路径的后缀名</span></span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.jsx'</span>, <span class="string">'.css'</span>],</span><br><span class="line">    <span class="comment">// 告诉 webpack 解析模块是去找哪个目录</span></span><br><span class="line">    modules: [resolve(__dirname, <span class="string">'../../node_modules'</span>), <span class="string">'node_modules'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="devServer"><a href="#devServer" class="headerlink" title="devServer"></a>devServer</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; resolve &#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/js/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'js/[name].js'</span>,</span><br><span class="line">    path: resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [<span class="keyword">new</span> HtmlWebpackPlugin()],</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      $css: resolve(__dirname, <span class="string">'src/css'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.json'</span>, <span class="string">'.jsx'</span>, <span class="string">'.css'</span>],</span><br><span class="line">    modules: [resolve(__dirname, <span class="string">'../../node_modules'</span>), <span class="string">'node_modules'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    <span class="comment">// 运行代码的目录</span></span><br><span class="line">    contentBase: resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    <span class="comment">// 监视 contentBase 目录下的所有文件，一旦文件变化就会 reload</span></span><br><span class="line">    watchContentBase: <span class="literal">true</span>,</span><br><span class="line">    watchOptions: &#123;</span><br><span class="line">      <span class="comment">// 忽略文件</span></span><br><span class="line">      ignored: <span class="regexp">/node_modules/</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 启动gzip压缩</span></span><br><span class="line">    compress: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 端口号</span></span><br><span class="line">    port: <span class="number">5000</span>,</span><br><span class="line">    <span class="comment">// 域名</span></span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    <span class="comment">// 自动打开浏览器</span></span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 开启HMR功能</span></span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 不要显示启动服务器日志信息</span></span><br><span class="line">    clientLogLevel: <span class="string">'none'</span>,</span><br><span class="line">    <span class="comment">// 除了一些基本启动信息以外，其他内容都不要显示</span></span><br><span class="line">    quiet: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 如果出错了，不要全屏提示~</span></span><br><span class="line">    overlay: <span class="literal">false</span>,</span><br><span class="line">    <span class="comment">// 服务器代理 --&gt; 解决开发环境跨域问题</span></span><br><span class="line">    proxy: &#123;</span><br><span class="line">      <span class="comment">// 一旦devServer(5000)服务器接受到 /api/xxx 的请求，就会把请求转发到另外一个服务器(3000)</span></span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">        target: <span class="string">'http://localhost:3000'</span>,</span><br><span class="line">        <span class="comment">// 发送请求时，请求路径重写：将 /api/xxx --&gt; /xxx （去掉/api）</span></span><br><span class="line">        pathRewrite: &#123;</span><br><span class="line">          <span class="string">'^/api'</span>: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>一行代码实现移动端适配方案(rem+vw)</title>
    <url>/2020/03/06/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%96%B9%E6%A1%88-rem-vw/</url>
    <content><![CDATA[<p>rem 这个单位对于前端来说并不陌生了,在移动端适配方面,我们经常会用到它,通常我们会采用类似淘宝flexible.js 的方案, 写px,然后通过插件转化成rem,然后得出一堆小数值的rem单位.淘宝这个方案已经用了很多年,兼容性很好,然而现在,许多兼容性问题现在不再那么头疼了,因此我们现在有了更好的适配方案.</p>
<a id="more"></a>

<p>在很早以前,vw 这个单位就已经被列入w3c规范了,如果基本都支持了,vw 表示屏幕的1%,可能有人会问到那跟百分比有什么区别呢? 通常,很多情况确实可以被百分比替代,但是要知道百分比如果要子n代元素都生效,那得所有父级元素都得相对html,body 100%宽才能有作用,而vw则永远相对 屏幕1%.说了vw的含义来说说怎么结合rem适配吧.<br>这里直接给出结果,只需一行代码即可</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>&#123;<span class="attribute">font-size</span>:<span class="number">13.33333333vw</span>&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们即可根据设计稿(前提设计稿是750px的),这样我们写1rem即为设计稿上的100px</p>
<p><strong>设置meta为移动端</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是不感觉很诧异,写的width:1rem,heigth:1rem的div 就是50px 50px (iphone6为2倍屏,即对应750px设计稿上的100px100px) 怎么搞定的,1句代码就能实现,太神奇.不信可以看看上图或者自己试一下.恩,就是这么简单,1句css代码就搞定,无需任何的js代码.</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>上面我们说了vw表示1%的屏幕宽度,而我们的设计稿通常是750px的,屏幕一共是100vw,对应750px,那么1px就是0.1333333vw </p>
<p>为了方便计算,我们放大100倍,同时我们知道另一个单位rem,rem是相对html元素,为了方便计算,我们取html是100px,通过上面的计算结果1px是0.13333333vw,那么100px就是13.333333vw了 </p>
<p>这样后面的用rem就很好计算了,这样就得到13.3333333vw对应100px(750px的 设计稿),然后我们就可以很愉快的写rem单位了, 由于倍率是100,我们也不需要啥计算插件之类的了,除以100,直接小数点向左移动2位,1rem是100px,那么10px就是0.1rem,1px就是0.01rem</p>
<p>小学生都会算了, 不需要用postcss-px-to-viewport这种工具转成一堆小数位特长的rem单位了,而且这个很方便,直接写rem,并不需要转换,用了转换工具 如果想写px的地方还得设置白名单或者黑名单,这个就不存在这种问题了, 想用相对的就rem,想绝对的就直接写px即可,并不需要其他的各种设置.是不是很简单?</p>
<h2 id="改进版"><a href="#改进版" class="headerlink" title="改进版:"></a>改进版:</h2><p>经过一些实践,发现此方案只能兼容手机,甚至连ipad兼容都不好,当然,此处的兼容不是兼容问题,是效果问题,只要兼容vw的设备都能用这个方案,但是由于适配的根本是vw这个, 这个会随着设备的宽度越来越大,那么用rem做单位的元素也会越来越大,以至于如果这个在pc上,那么没法预览了,效果会很差,字太大了.这样我们可以设置一下当屏幕过大的时候的情况,我们可以加一句代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">min-width:</span> <span class="number">560px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">54px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上这句代码,在pc上效果也很不错了</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>知识点</tag>
        <tag>技巧</tag>
        <tag>前端</tag>
        <tag>适配</tag>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>从零搭建React项目全家桶</title>
    <url>/2020/03/30/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAReact%E9%A1%B9%E7%9B%AE%E5%85%A8%E5%AE%B6%E6%A1%B6/</url>
    <content><![CDATA[<p>React是近几年来前端项目开发非常火的一个框架，其背景是Facebook团队的技术支持，市场占有率也很高。很多初学者纠结一开始是学react还是vue。个人觉得，有时间的话，最好两个都掌握一下。从学习难度上来说，react要比vue稍难一些。万事开头难，但是掌握了react对于大幅提高前端技能还是非常有帮助的。本文一步步详细梳理了从创建react、精简项目、集成插件、初步优化等过程。对于react开发者来说，能够节省很多探索的时间。下面请跟着我来一步步操作。</p>
<a id="more"></a>

<h2 id="先睹为快"><a href="#先睹为快" class="headerlink" title="先睹为快"></a>先睹为快</h2><p>正式开始前，先看下通过本次分享，能掌握什么？</p>
<ul>
<li>从零创建React项目</li>
<li>支持Sass/Scss/Less/Stylus</li>
<li>路由使用：react-router-dom</li>
<li>组件的创建与引用</li>
<li>React Developer Tools浏览器插件</li>
<li>redux、react-redux使用</li>
<li>redux-thunk</li>
<li>store的创建与使用</li>
<li>Redux DevTools安装与使用</li>
<li>immutable.js使用</li>
<li>Mock.js使用</li>
<li>解决本地跨域反向代理</li>
<li>其他常用工具汇总</li>
<li>超值附赠：集成Ant Design</li>
</ul>
<p>即使你是新手，跟着操作一遍以后，也可以快速上手React项目啦！</p>
<blockquote>
<p>※注：本文代码区域每行开头的“+”表示新增，“-”表示删除，“M”表示修改；代码中的“…”表示省略。</p>
</blockquote>
<h2 id="1-创建React-APP"><a href="#1-创建React-APP" class="headerlink" title="1 创建React-APP"></a>1 创建React-APP</h2><p>为了加速npm下载速度，先把npm设置为淘宝镜像地址。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm config <span class="keyword">set</span> registry http://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure>
<p>通过官方的create-react-app，找个喜欢的目录，执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npx create-react-app react-app</span><br></pre></td></tr></table></figure>
<p>命令最后的react-app是项目的名称，可以自行更改。</p>
<p>稍等片刻即可完成安装。安装完成后，可以使用npm或者yarn启动项目。</p>
<p>进入项目目录，并启动项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd react-app</span><br><span class="line">yarn start  （或者使用npm start）</span><br></pre></td></tr></table></figure>
<p>启动后，可以通过<code>http://localhost:3000/</code>地址访问项目：</p>
<h2 id="2-精简项目"><a href="#2-精简项目" class="headerlink" title="2 精简项目"></a>2 精简项目</h2><h3 id="2-1-删除文件"><a href="#2-1-删除文件" class="headerlink" title="2.1 删除文件"></a>2.1 删除文件</h3><p>接下来，删除一般项目中用不到的文件，最简化项目。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    ├─ /node_modules</span><br><span class="line">    ├─ package.json</span><br><span class="line">    ├─ /public</span><br><span class="line">    |  ├─ favicon.ico</span><br><span class="line">    |  ├─ index.html</span><br><span class="line">-   |  ├─ logo192.png</span><br><span class="line">-   |  ├─ logo512.png</span><br><span class="line">-   |  ├─ mainfest.json</span><br><span class="line">-   |  └─ robots.txt</span><br><span class="line">    ├─ README.md</span><br><span class="line">    ├─ /src</span><br><span class="line">-   |  ├─ App.css</span><br><span class="line">    |  ├─ App.js</span><br><span class="line">-   |  ├─ App.test.js      (jTest自动化测试)</span><br><span class="line">-   |  ├─ index.css</span><br><span class="line">-   |  ├─ index.js</span><br><span class="line">-   |  ├─ logo.svg</span><br><span class="line">-   |  ├─ serviceWorker.js</span><br><span class="line">-   |  └─ setuoTests.js    (PWA)</span><br><span class="line">    └─ yarn.lock</span><br></pre></td></tr></table></figure>
<p>以上文件删除后，页面会报错。这是因为相应的文件引用已不存在。需要继续修改代码。</p>
<h3 id="2-2-简化代码"><a href="#2-2-简化代码" class="headerlink" title="2.2 简化代码"></a>2.2 简化代码</h3><p>现在目录结构如下，清爽许多：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">├─ /node_modules</span><br><span class="line">├─ package.json</span><br><span class="line">├─ /public</span><br><span class="line">|  ├─ favicon.ico</span><br><span class="line">|  └─ index.html</span><br><span class="line">├─ README.md</span><br><span class="line">├─ /src</span><br><span class="line">|  ├─ App.js</span><br><span class="line">|  └─ index.js</span><br><span class="line">└─ yarn.lock</span><br></pre></td></tr></table></figure>
<blockquote>
<p>记的删除文件中引用的代码</p>
</blockquote>
<h3 id="2-3-使用Fragment去掉组件外层标签"><a href="#2-3-使用Fragment去掉组件外层标签" class="headerlink" title="2.3 使用Fragment去掉组件外层标签"></a>2.3 使用Fragment去掉组件外层标签</h3><p>react要求每个组件HTML的最外层必须是由一个标签包裹，且不能存在并列的标签。例如，在src/App.js中，如果是这样就会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 以下代码将会报错，最外层不能存在并列的标签。</span></span><br><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"App"</span>&gt;</span><br><span class="line">      &lt;h1&gt;This is React App.&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"App-other"</span>&gt;</span><br><span class="line">      &lt;h1&gt;This is React App-other.&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果确实需要这样的HTML，并且不想再添加一个父级标签，可以使用Fragment作为最外层。代码修改如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">M   <span class="keyword">import</span> React, &#123; Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">+           <span class="xml"><span class="tag">&lt;<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line">                &lt;div className="App"&gt;</span><br><span class="line">                    &lt;h1&gt;This is React App.&lt;/h1&gt;</span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">                &lt;div className="App-other"&gt;</span><br><span class="line">                    &lt;h1&gt;This is React App-ohter.&lt;/h1&gt;</span><br><span class="line"><span class="xml">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">+           <span class="tag">&lt;/<span class="name">Fragment</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> App</span><br></pre></td></tr></table></figure>
<p>以上仅为了说明Fragment的使用效果。在某些组件嵌套的使用场景下，非常适合使用Fragment。例如父组件是<code>&lt;table&gt;</code>，而子组件可以用<code>&lt;Fragment&gt;</code>包裹多个<code>&lt;tr&gt;</code>。</p>
<h2 id="3-项目目录结构"><a href="#3-项目目录结构" class="headerlink" title="3 项目目录结构"></a>3 项目目录结构</h2><p>项目目录结构可根据项目实际灵活制定。这里分享下我常用的结构，仅供参考。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">├─ /node_modules</span><br><span class="line">├─ package.json</span><br><span class="line">├─ /public</span><br><span class="line">|  ├─ favicon.ico        &lt;-- 网页图标</span><br><span class="line">|  └─ index.html         &lt;-- HTML页模板</span><br><span class="line">├─ README.md</span><br><span class="line">├─ /src</span><br><span class="line">|  ├─ /common            &lt;-- 全局公用目录</span><br><span class="line">|  |  ├─ /fonts          &lt;-- 字体文件目录</span><br><span class="line">|  |  ├─ /images         &lt;-- 图片文件目录</span><br><span class="line">|  |  ├─ /js             &lt;-- 公用js文件目录</span><br><span class="line">|  |  └─ /style          &lt;-- 公用样式文件目录</span><br><span class="line">|  |  |  ├─ frame.css    &lt;-- 全部公用样式（<span class="keyword">import</span>其他css）</span><br><span class="line">|  |  |  ├─ reset.css    &lt;-- 清零样式</span><br><span class="line">|  |  |  └─ global.css   &lt;-- 全局公用样式</span><br><span class="line">|  ├─ /components        &lt;-- 公共模块组件目录</span><br><span class="line">|  |  ├─ /header         &lt;-- 头部导航模块</span><br><span class="line">|  |  |  ├─ index.js     &lt;-- header主文件</span><br><span class="line">|  |  |  └─ header.css   &lt;-- header样式文件</span><br><span class="line">|  |  └─ ...             &lt;-- 其他模块</span><br><span class="line">|  ├─ /pages             &lt;-- 页面组件目录</span><br><span class="line">|  |  ├─ /home           &lt;-- home页目录</span><br><span class="line">|  |  |  ├─ index.js     &lt;-- home主文件</span><br><span class="line">|  |  |  └─ home.css     &lt;-- home样式文件</span><br><span class="line">|  |  ├─ /login          &lt;-- login页目录</span><br><span class="line">|  |  |  ├─ index.js     &lt;-- login主文件</span><br><span class="line">|  |  |  └─ login.css    &lt;-- login样式文件</span><br><span class="line">|  |  └─ ...             &lt;-- 其他页面</span><br><span class="line">|  ├─ App.js             &lt;-- 项目主模块</span><br><span class="line">|  └─ index.js           &lt;-- 项目入口文件</span><br><span class="line">└─ yarn.lock</span><br></pre></td></tr></table></figure>
<h3 id="3-1-引入全局公用样式"><a href="#3-1-引入全局公用样式" class="headerlink" title="3.1 引入全局公用样式"></a>3.1 引入全局公用样式</h3><p>在frame.css里引入其他公用样式： src/common/style/frame.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">'./reset.css'</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">'./global.css'</span>;</span><br></pre></td></tr></table></figure>
<p>然后在src/index.js里引入frame.css</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    import React from &#39;react&#39;</span><br><span class="line">    import ReactDOM from &#39;react-dom&#39;</span><br><span class="line">    import App from &#39;.&#x2F;App&#39;</span><br><span class="line">+   import &#39;.&#x2F;common&#x2F;style&#x2F;frame.css&#39;</span><br><span class="line"></span><br><span class="line">    ReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#39;root&#39;))</span><br></pre></td></tr></table></figure>
<h3 id="3-2-支持Sass-Less-Stylus"><a href="#3-2-支持Sass-Less-Stylus" class="headerlink" title="3.2 支持Sass/Less/Stylus"></a>3.2 支持Sass/Less/Stylus</h3><p>工欲善其事必先利其器，这么高大上的react怎能好意思用最原始的css搭配呢？create-react-app默认情况下未暴露配置文件。要更灵活配置项目，需要将配置文件暴露出来。</p>
<p>执行以下命令，暴露配置文件：</p>
<blockquote>
<p>※注意：暴露配置的文件的操作不可逆！</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run eject</span><br></pre></td></tr></table></figure>
<p>如果之前没有提及git的话，可能会报以下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Remove untracked files, stash or commit any changes, and try again</span><br></pre></td></tr></table></figure>
<p>需要先在项目根目录下执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m "初始化项目(备注)"</span><br></pre></td></tr></table></figure>
<p>稍等片刻，eject成功，目录变化如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">+   ├─ /config</span><br><span class="line">+   |  ├─ /jest</span><br><span class="line">+   |  ├─ env.js</span><br><span class="line">+   |  ├─ <span class="built_in">module</span>.js</span><br><span class="line">+   |  ├─ paths.js</span><br><span class="line">+   |  ├─ pnpTs.js</span><br><span class="line">+   |  ├─ webpack.config.js   &lt;-- webpack配置文件</span><br><span class="line">+   |  └─ webpackDevServer.config.js</span><br><span class="line">    ├─ /node_modules</span><br><span class="line">    ├─ package.json</span><br><span class="line">    ├─ /public</span><br><span class="line">    |  ├─ favicon.ico</span><br><span class="line">    |  └─ index.html</span><br><span class="line">    ├─ README.md</span><br><span class="line">+   ├─ /scripts</span><br><span class="line">+   |  ├─ build.js</span><br><span class="line">+   |  ├─ start.js</span><br><span class="line">+   |  └─ test.js</span><br><span class="line">    ├─ /src</span><br><span class="line">    |  ├─ /common         &lt;-- 全局公用目录</span><br><span class="line">    |  ├─ /components     &lt;-- 公共模块组件目录</span><br><span class="line">    |  ├─ /pages          &lt;-- 页面组件目录</span><br><span class="line">    |  ├─ App.js          &lt;-- 项目主模块</span><br><span class="line">    |  └─ index.js        &lt;-- 项目入口文件</span><br><span class="line">    └─ yarn.lock</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1-支持Sass-Scss"><a href="#3-2-1-支持Sass-Scss" class="headerlink" title="3.2.1 支持Sass/Scss"></a>3.2.1 支持Sass/Scss</h3><p>eject后，虽然package.json以及webpack.config.js里有了sass相关代码，但是要正确使用Sass/Scss，还要再安装node-sass。</p>
<p>执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install node-sass -D</span><br><span class="line">  or</span><br><span class="line">yarn add node-sass -D</span><br></pre></td></tr></table></figure>
<p>安装完成后，项目已支持Sass/Scss，可以将原css文件后缀名修改为sacc/scss，别忘了把src/index.js中引入的frame.css后缀名修改为sacc/scss。</p>
<h3 id="3-2-2-支持Less"><a href="#3-2-2-支持Less" class="headerlink" title="3.2.2 支持Less"></a>3.2.2 支持Less</h3><p>支持Less稍微多一点步骤，首先安装less和less-loader：<br>执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install less-loader -D</span><br><span class="line">  or</span><br><span class="line">yarn add less-loader -D</span><br></pre></td></tr></table></figure>
<p>然后修改config/webpack.config.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// style files regexes</span></span><br><span class="line">    <span class="keyword">const</span> cssRegex = <span class="regexp">/\.css$/</span>;</span><br><span class="line">    <span class="keyword">const</span> cssModuleRegex = <span class="regexp">/\.module\.css$/</span>;</span><br><span class="line">    <span class="keyword">const</span> sassRegex = <span class="regexp">/\.(scss|sass)$/</span>;</span><br><span class="line">    <span class="keyword">const</span> sassModuleRegex = <span class="regexp">/\.module\.(scss|sass)$/</span>;</span><br><span class="line">+   <span class="keyword">const</span> lessRegex = <span class="regexp">/\.less$/</span>;</span><br><span class="line">+   <span class="keyword">const</span> lessModuleRegex = <span class="regexp">/\.module\.less$/</span>;</span><br><span class="line">    ...(略)</span><br><span class="line">    <span class="comment">// Opt-in support for SASS (using .scss or .sass extensions).</span></span><br><span class="line">    <span class="comment">// By default we support SASS Modules with the</span></span><br><span class="line">    <span class="comment">// extensions .module.scss or .module.sass</span></span><br><span class="line">    &#123;</span><br><span class="line">        test: sassRegex,</span><br><span class="line">        exclude: sassModuleRegex,</span><br><span class="line">        use: getStyleLoaders(</span><br><span class="line">            &#123;</span><br><span class="line">                importLoaders: <span class="number">2</span>,</span><br><span class="line">                sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'sass-loader'</span></span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// Don't consider CSS imports dead code even if the</span></span><br><span class="line">        <span class="comment">// containing package claims to have no side effects.</span></span><br><span class="line">        <span class="comment">// Remove this when webpack adds a warning or an error for this.</span></span><br><span class="line">        <span class="comment">// See https://github.com/webpack/webpack/issues/6571</span></span><br><span class="line">        sideEffects: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// Adds support for CSS Modules, but using SASS</span></span><br><span class="line">    <span class="comment">// using the extension .module.scss or .module.sass</span></span><br><span class="line">    &#123;</span><br><span class="line">        test: sassModuleRegex,</span><br><span class="line">        use: getStyleLoaders(</span><br><span class="line">            &#123;</span><br><span class="line">                importLoaders: <span class="number">2</span>,</span><br><span class="line">                sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">                modules: &#123;</span><br><span class="line">                    getLocalIdent: getCSSModuleLocalIdent,</span><br><span class="line">                  &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'sass-loader'</span></span><br><span class="line">        ),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 以下这里仿照上面sass的代码，配置下less。</span></span><br><span class="line">+   &#123;</span><br><span class="line">+       test: lessRegex,</span><br><span class="line">+           exclude: lessModuleRegex,</span><br><span class="line">+           use: getStyleLoaders(</span><br><span class="line">+               &#123;</span><br><span class="line">+                   importLoaders: <span class="number">2</span>,</span><br><span class="line">+                   sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">+               &#125;,</span><br><span class="line">+               <span class="string">'less-loader'</span></span><br><span class="line">+            ),</span><br><span class="line">+           sideEffects: <span class="literal">true</span>,</span><br><span class="line">+   &#125;,</span><br><span class="line">+   &#123;</span><br><span class="line">+       test: lessModuleRegex,</span><br><span class="line">+       use: getStyleLoaders(</span><br><span class="line">+           &#123;</span><br><span class="line">+               importLoaders: <span class="number">2</span>,</span><br><span class="line">+               sourceMap: isEnvProduction &amp;&amp; shouldUseSourceMap,</span><br><span class="line">+               modules: &#123;</span><br><span class="line">+                   getLocalIdent: getCSSModuleLocalIdent,</span><br><span class="line">+               &#125;,</span><br><span class="line">+           &#125;,</span><br><span class="line">+           <span class="string">'less-loader'</span></span><br><span class="line">+       ),</span><br><span class="line">+   &#125;,</span><br></pre></td></tr></table></figure>
<p>修改后需要执行yarn start重启项目。</p>
<p>然后将原css文件的后缀名修改为less，src/index.js中引入的frame.less，页面已正常解析less。</p>
<h3 id="3-2-3-支持Stylus"><a href="#3-2-3-支持Stylus" class="headerlink" title="3.2.3 支持Stylus"></a>3.2.3 支持Stylus</h3><p>支持Stylus跟Less完全一样，首先安装stylus和stylus-loader：</p>
<p>执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install stylus-loader -D</span><br><span class="line">  or</span><br><span class="line">yarn add stylus-loader -D</span><br></pre></td></tr></table></figure>
<p>安装完成后，按照上一小节介绍的支持less的方法，修改config/webpack.config.js。完成后重启项目，引入stylus文件可以正常解析了。</p>
<p>我个人习惯使用Stylus，因此后续的讲解中使用Stylus。同时，把src/common/下的style目录也更名为stylus。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    ├─ /config</span><br><span class="line">    ├─ /node_modules</span><br><span class="line">    ├─ package.json</span><br><span class="line">    ├─ /public</span><br><span class="line">    ├─ README.md</span><br><span class="line">    ├─ /scripts</span><br><span class="line">    ├─ /src</span><br><span class="line">    |  ├─ /common       &lt;-- 全局公用目录    </span><br><span class="line">    |  |  ├─ /fonts       </span><br><span class="line">    |  |  ├─ /images </span><br><span class="line">    |  |  ├─ /js </span><br><span class="line">M   |  |  └─ /stylus</span><br><span class="line">M   |  |  |  ├─ frame.styl</span><br><span class="line">M   |  |  |  ├─ reset.styl</span><br><span class="line">M   |  |  |  └─ global.styl  </span><br><span class="line">    |  ├─ /components   &lt;-- 公共模块组件目录</span><br><span class="line">    |  ├─ /pages        &lt;-- 页面组件目录</span><br><span class="line">    |  ├─ App.js        &lt;-- 项目主模块</span><br><span class="line">    |  └─ index.js      &lt;-- 项目入口文件</span><br><span class="line">    └─ yarn.lock</span><br></pre></td></tr></table></figure>
<p>最基本的配置搞定了，接下来要开始引入页面（pages）了。页面的切换需要使用路由（Router），请继续阅读下面的章节。</p>
<h2 id="4-路由"><a href="#4-路由" class="headerlink" title="4 路由"></a>4 路由</h2><h3 id="4-1-页面构建"><a href="#4-1-页面构建" class="headerlink" title="4.1 页面构建"></a>4.1 页面构建</h3><p>首先，构建home和login页面。</p>
<p>src/pages/home/index.js代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./home.styl'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"P-home"</span>&gt;</span><br><span class="line">                &lt;h1&gt;Home page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure>
<p>src/pages/home/home.styl代码</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.P-home</span></span><br><span class="line">    <span class="selector-tag">h1</span></span><br><span class="line">        <span class="selector-tag">padding</span>: 20<span class="selector-tag">px</span> 0</span><br><span class="line">        <span class="selector-tag">font-size</span>: 30<span class="selector-tag">px</span></span><br><span class="line">        <span class="selector-tag">color</span>: <span class="selector-id">#fff</span></span><br><span class="line">        <span class="selector-tag">background</span>: <span class="selector-id">#67C23A</span></span><br><span class="line">        <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span></span><br></pre></td></tr></table></figure>
<p>src/pages/login/index.js代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./login.styl'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"P-login"</span>&gt;</span><br><span class="line">                &lt;h1&gt;Login page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Login</span><br></pre></td></tr></table></figure>

<p>接下来，我们使用react-router-dom实现路由。</p>
<h3 id="4-2-使用react-router-dom"><a href="#4-2-使用react-router-dom" class="headerlink" title="4.2 使用react-router-dom"></a>4.2 使用react-router-dom</h3><p>执行安装命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install react-router-dom --save</span><br><span class="line">  or</span><br><span class="line">yarn add react-router-dom</span><br></pre></td></tr></table></figure>
<p>修改src/App.js，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'./pages/login'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'./pages/home'</span></span><br><span class="line"><span class="keyword">import</span> &#123; HashRouter, Route, Switch, Redirect &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Fragment&gt;</span><br><span class="line">      &lt;HashRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/login"</span> component=&#123;Login&#125; /&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/home"</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">          &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125; /&gt;</span><br><span class="line">          &lt;Redirect to=&#123;<span class="string">"/home"</span>&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>HashRouter&gt;</span><br><span class="line">    &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default App</span></span><br></pre></td></tr></table></figure>
<p>App.js引入了Home和Login两个页面级组件。然后使用react-router-dom分别设置了路径。</p>
<p>import的机制是默认寻找index.js，所以每个组件的主文件名设为index.js，在引用的时候就可以省略文件名。</p>
<p>这里说明一下<code>&lt;Route&gt;</code>的属性：</p>
<ul>
<li>path表示路径，这个很好理解。</li>
<li>component表示绑定的组件。</li>
<li>exact表示是否精确匹配。</li>
</ul>
<p>如果没有设置exact，那么：</p>
<ul>
<li>localhost:3000/会显示Home页，</li>
<li>localhost:3000/abc也会显示Home页。</li>
<li>因为匹配到了前面的”/“，路由就会成功。</li>
</ul>
<p>最后的<code>&lt;Redirect&gt;</code>表示以上都没有匹配成功的会，默认跳转的路由。</p>
<h3 id="4-3-路由跳转"><a href="#4-3-路由跳转" class="headerlink" title="4.3 路由跳转"></a>4.3 路由跳转</h3><p>接下来，简单介绍下如果在页面之间进行路由跳转。</p>
<p>在Login页面添加一个用于跳转至Home页的按钮，代码修改如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line">    <span class="keyword">import</span> <span class="string">'./login.styl'</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">               &lt;div className=<span class="string">"P-login"</span>&gt;</span><br><span class="line">                    &lt;h1&gt;Login page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">+                   &lt;button onClick=&#123;this.gotoHome.bind(this)&#125;&gt;跳转Home页&lt;/</span>button&gt;</span><br><span class="line">                &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">            )</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">+       gotoHome() &#123;</span></span><br><span class="line"><span class="regexp">+           this.props.history.push('/</span>home<span class="string">')</span></span><br><span class="line"><span class="string">+       &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    export default Login</span></span><br></pre></td></tr></table></figure>
<p>注意button的onClick里要bind(this)，否则，在gotoHome里的this是undefined。</p>
<p>当然，也可以这么写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;() =&gt; &#123;<span class="keyword">this</span>.gotoHome()&#125;&#125;&gt;跳转Home页&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>最终目的都是要让gotoHome中的this指向正确的作用域。</p>
<h2 id="5-组件引入"><a href="#5-组件引入" class="headerlink" title="5 组件引入"></a>5 组件引入</h2><p>这章节内容也很容易，接触过vue的同学应该也很清楚，为了教程的完整性，还是简单说一下。下面来简单实现一个公用的头部组件。</p>
<h3 id="5-1-创建header组件"><a href="#5-1-创建header组件" class="headerlink" title="5.1 创建header组件"></a>5.1 创建header组件</h3><p>目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">    |  ├─ /components   &lt;-- 公共模块组件目录</span><br><span class="line">+   |  |  ├─ /header    &lt;-- 公用header组件</span><br><span class="line">+   |  |  |  ├─ index.js </span><br><span class="line">+   |  |  |  └─ header.styl</span><br></pre></td></tr></table></figure>
<p>src/components/header/index.js代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./header.styl'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;div className=<span class="string">"M-header"</span>&gt;</span><br><span class="line">                Header</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default Header</span></span><br></pre></td></tr></table></figure>
<p>src/components/header/header.styl代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.M-header</span></span><br><span class="line">    <span class="selector-tag">height</span>: 40<span class="selector-tag">px</span></span><br><span class="line">    <span class="selector-tag">line-height</span>: 40<span class="selector-tag">px</span></span><br><span class="line">    <span class="selector-tag">font-size</span>: 36<span class="selector-tag">px</span></span><br><span class="line">    <span class="selector-tag">color</span>: <span class="selector-id">#fff</span></span><br><span class="line">    <span class="selector-tag">background</span>: <span class="selector-id">#409EFF</span></span><br></pre></td></tr></table></figure>
<h3 id="5-2-引入Header组件"><a href="#5-2-引入Header组件" class="headerlink" title="5.2 引入Header组件"></a>5.2 引入Header组件</h3><p>然后，在Home和Login页面里引入Header组件。</p>
<p>以Home页面为例，修改src/pages/home/index.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line">+   <span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'../../components/header'</span></span><br><span class="line">    <span class="keyword">import</span> <span class="string">'./home.styl'</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;div className=<span class="string">"P-home"</span>&gt;</span><br><span class="line">+                   <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line">                    &lt;h1&gt;Home page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> Home</span><br></pre></td></tr></table></figure>
<h3 id="5-3-组件传参"><a href="#5-3-组件传参" class="headerlink" title="5.3 组件传参"></a>5.3 组件传参</h3><p>使用过vue的同学都知道，vue组件有data和props。对应react的是state和props。</p>
<p>react向子组件传参使用以下方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;Header </span><br><span class="line">    param1=<span class="string">"abc"</span></span><br><span class="line">    param2=<span class="string">"c"</span></span><br><span class="line">    func1=&#123;()=&gt;&#123;<span class="built_in">console</span>.log(<span class="string">'func1'</span>)&#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p>在Header组件内部，直接使用this.props就可以接收。例如：this.props.param1。</p>
<h2 id="6-React-Developer-Tools浏览器插件"><a href="#6-React-Developer-Tools浏览器插件" class="headerlink" title="6 React Developer Tools浏览器插件"></a>6 React Developer Tools浏览器插件</h2><p>为了更方便调试react项目，建议安装chrome插件。</p>
<p>先科学上网，在chrome网上应用店里搜索“React Developer Tools”并安装。</p>
<p>安装完成后，打开chrome调试工具，可以清晰的看到react项目代码结构。</p>
<h2 id="7-Redux及相关插件"><a href="#7-Redux及相关插件" class="headerlink" title="7 Redux及相关插件"></a>7 Redux及相关插件</h2><p>做过vue开发的同学都知道vuex，react对应的工具就是Redux，当然还有一些附属工具，比如react-redux、redux-thunk、immutable。</p>
<h3 id="7-1-安装redux"><a href="#7-1-安装redux" class="headerlink" title="7.1 安装redux"></a>7.1 安装redux</h3><p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install  redux --save</span><br><span class="line">or</span><br><span class="line">yarn add redux</span><br></pre></td></tr></table></figure>
<p>仅安装redux也是可以使用的，但是比较麻烦。redux里更新store里的数据，需要手动订阅(subscribe)更新。可以借助另一个插件（react-redux）提高开发效率。</p>
<h3 id="7-2-安装react-redux"><a href="#7-2-安装react-redux" class="headerlink" title="7.2 安装react-redux"></a>7.2 安装react-redux</h3><p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install  react-redux --save</span><br><span class="line">or</span><br><span class="line">yarn add react-redux</span><br></pre></td></tr></table></figure>

<p>react-redux允许通过connect方法，将store中的数据映射到组件的props，省去了store订阅。原state中读取store的属性改用props读取。</p>
<h3 id="7-3-安装redux-thunk"><a href="#7-3-安装redux-thunk" class="headerlink" title="7.3 安装redux-thunk"></a>7.3 安装redux-thunk</h3><p>执行：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install  redux-thunk --save</span><br><span class="line">or</span><br><span class="line">yarn add redux-thunk</span><br></pre></td></tr></table></figure>

<p>redux-thunk允许在actionCreators里返回函函数。这样可以把业务逻辑（例如接口请求）集中写在actionCreator.js，方便复用的同时，可以使组件的主文件更简洁。</p>
<h3 id="7-4-安装浏览器Redux插件"><a href="#7-4-安装浏览器Redux插件" class="headerlink" title="7.4 安装浏览器Redux插件"></a>7.4 安装浏览器Redux插件</h3><p>为了更方便跟踪redux状态，建议安装chrome插件。</p>
<p>先科学上网，在chrome网上应用店里搜索“Redux DevTools”并安装。</p>
<p>安装完成后还不能直接使用，需要在项目代码中进行配置。接下来进行说明。</p>
<h3 id="7-5-创建store"><a href="#7-5-创建store" class="headerlink" title="7.5 创建store"></a>7.5 创建store</h3><p>安装以上各种插件后，可以store用来管理状态数据了。</p>
<p>如果项目比较简单，只有一两个页面，可以只创建一个总store管理整体项目。目录结构参考如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">    ├─ /src   </span><br><span class="line">+   |  ├─ /store</span><br><span class="line">+   |  |  ├─ actionCreators.js</span><br><span class="line">+   |  |  ├─ contants.js       &lt;-- 定义方法的常量</span><br><span class="line">+   |  |  ├─ index.js</span><br><span class="line">+   |  |  └─ reducer.js</span><br></pre></td></tr></table></figure>
<p>以下是各文件的代码示例：</p>
<p>src/store/actionCreators.js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import * as constans from &#39;.&#x2F;constants&#39;</span><br><span class="line"></span><br><span class="line">export const getData &#x3D; (data) &#x3D;&gt; (&#123;</span><br><span class="line">  type: constans.SET_DATA,</span><br><span class="line">  data</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>src/store/contants.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_DATA = <span class="string">'SET_DATA'</span></span><br></pre></td></tr></table></figure>
<p>src/store/index.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware, compose &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里让项目支持浏览器插件Redux DevTools</span></span><br><span class="line"><span class="keyword">const</span> composeEnhancers = <span class="keyword">typeof</span> <span class="built_in">window</span> === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">  <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ?</span><br><span class="line">  <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__(&#123;&#125;) : compose</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> enhancer = composeEnhancers(</span><br><span class="line">  applyMiddleware(thunk)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  reducer,</span><br><span class="line">  enhancer</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
<blockquote>
<p>以上是store的核心代码，支持了Redux DevTools。同时，利用redux的集成中间件（applyMiddleware）功能将redux-thunk集成进来，最终创建了store。</p>
</blockquote>
<p>src/store/reducer.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">'./constants'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始默认的state</span></span><br><span class="line"><span class="keyword">const</span> defaultState = &#123;</span><br><span class="line">    myData: <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = defaultState, action) =&gt; &#123;</span><br><span class="line">    <span class="comment">// 由于state是引用型，不能直接修改，否则是监测不到state发生变化的。因此需要先复制一份进行修改，然后再返回新的state。</span></span><br><span class="line">    <span class="keyword">let</span> newState = <span class="built_in">Object</span>.assign(&#123;&#125;, state)</span><br><span class="line">    <span class="keyword">switch</span>(action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> constants.SET_DATA:</span><br><span class="line">            newState.myData = action.data</span><br><span class="line">            <span class="keyword">return</span> newState</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，我们在store设置了一个myData。如何更好地解决state修改问题</p>
<h3 id="7-6-复杂项目store分解"><a href="#7-6-复杂项目store分解" class="headerlink" title="7.6 复杂项目store分解"></a>7.6 复杂项目store分解</h3><p>应对更多页面的项目，如果数据都集中放在一个store里，其维护成本非常高。接下来分享下如何将store分解到各个组件中。</p>
<p>一般来说，每个组件有自己的store，再由src下的store作为总集，集成每个组件的store。</p>
<p>以header和login两个组件为例，分别创建组件自己的store。</p>
<p>header的store目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">    |  |  ├─ /store</span><br><span class="line">    |  |  |  ├─ /modules</span><br><span class="line">+   |  |  |  |  ├─ /header</span><br><span class="line">+   |  |  |  |  |  ├─ actionCreators.js</span><br><span class="line">+   |  |  |  |  |  ├─ contants.js      </span><br><span class="line">+   |  |  |  |  |  ├─ index.js</span><br><span class="line">+   |  |  |  |  |  └─ reducer.js</span><br></pre></td></tr></table></figure>
<p>module下store下的index.js代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionCreators <span class="keyword">from</span> <span class="string">'./actionCreators'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">'./constants'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; reducer, actionCreators, constants&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是把组件store下的其他文件集中起来作为统一输出口。</p>
<p>modules下store下的contants.js代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ZONE = <span class="string">'components/header/'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SET_DATA = ZONE + <span class="string">'SET_DATA'</span></span><br></pre></td></tr></table></figure>
<p>ZONE是用来避免与其他组件的contants重名。</p>
<p>同样的方式，在login下进行创建store（不再赘述）</p>
<p>然后修改项目src下的总store，目录结构变动如下：</p>
<p>src/store/index.js重写如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> loginReducer &#125; <span class="keyword">from</span> <span class="string">'./modules/login'</span></span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> headerReducer &#125; <span class="keyword">from</span> <span class="string">'./modules/header'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">    login: loginReducer,</span><br><span class="line">    header: headerReducer</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> reducer</span><br></pre></td></tr></table></figure>
<p>以上代码的作用就是把login和header的store引入，然后通过combineReducers合并在一起，并分别加上唯一的对象key值。</p>
<p>这样的好处非常明显：</p>
<ul>
<li>避免各组件的store数据互相污染</li>
<li>组件独立维护自己的store，减少维护成本</li>
</ul>
<p>非常建议使用这种方式维护store。</p>
<h3 id="7-7-对接react-redux与store"><a href="#7-7-对接react-redux与store" class="headerlink" title="7.7 对接react-redux与store"></a>7.7 对接react-redux与store</h3><p>为了方便每个组件都能使用store，而不用一遍一遍的引用store。下面来对接react-redux与store。</p>
<p>修改src/index.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line">    <span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line">    <span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line">+   <span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line">+   <span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line">    <span class="keyword">import</span> <span class="string">'./common/style/frame.styl'</span></span><br><span class="line"></span><br><span class="line">+   <span class="keyword">const</span> Apps = (</span><br><span class="line">+       <span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">+           <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">+       <span class="tag">&lt;/<span class="name">Provider</span>&gt;</span></span></span><br><span class="line">+   )</span><br><span class="line"></span><br><span class="line">M   ReactDOM.render(Apps, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure>
<p>以上代码就是用react-redux提供的Provider，把store传给了整个App。</p>
<p>在需要使用store的组件中，要使用react-redux提供的connect方法对组件进行包装。</p>
<p>以login为例，修改src/pages/login/index.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line">    <span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'../../components/header'</span></span><br><span class="line">+   <span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line">+   <span class="keyword">import</span> * <span class="keyword">as</span> actionCreators <span class="keyword">from</span> <span class="string">'./store/actionCreators'</span></span><br><span class="line">    <span class="keyword">import</span> <span class="string">'./login.styl'</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                &lt;div className=<span class="string">"P-login"</span>&gt;</span><br><span class="line">                    &lt;Header /&gt;</span><br><span class="line">                    &lt;h1&gt;Login page&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">+                   &lt;p&gt;login: myData = &#123;this.props.myData&#125;&lt;/</span>p&gt;</span><br><span class="line">+                   <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span>=&gt;</span> &#123;this.props.getData('123456')&#125;&#125;&gt;更改login的myData<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">                    &lt;button onClick=&#123;<span class="keyword">this</span>.gotoHome.bind(<span class="keyword">this</span>)&#125;&gt;跳转Home页&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">                &lt;/</span>div&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gotoHome() &#123;</span><br><span class="line">            <span class="keyword">this</span>.props.history.push(<span class="string">'/home'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">+   <span class="comment">// 把store中的数据映射到组件的props</span></span><br><span class="line">+   <span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123;</span><br><span class="line">+       myData: state.getIn([<span class="string">'login'</span>, <span class="string">'myData'</span>]),</span><br><span class="line">+   &#125;)</span><br><span class="line"></span><br><span class="line">+   <span class="comment">// 把store的Dispatch映射到组件的props</span></span><br><span class="line">+   <span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch</span>) =&gt;</span> (&#123;</span><br><span class="line">+       getData(data) &#123;</span><br><span class="line">+           <span class="keyword">const</span> action = actionCreators.getData(data)</span><br><span class="line">+           dispatch(action)</span><br><span class="line">+       &#125;</span><br><span class="line">+   &#125;)</span><br><span class="line"></span><br><span class="line">M   <span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps, mapDispatchToProps)(Login)</span><br></pre></td></tr></table></figure>
<p>最大的变化就是代码最后一行，被connect方法包装了。</p>
<p>然后把store里的state和dispatch都映射到了组件的props。这样可以直接通过props进行访问了，store中数据的变化会直接改变props从而触发组件的视图更新。</p>
<h2 id="8-Mock-js安装与使用"><a href="#8-Mock-js安装与使用" class="headerlink" title="8 Mock.js安装与使用"></a>8 Mock.js安装与使用</h2><p>在开发过程中，为了方便前端独自调试接口，经常使用Mock.js拦截Ajax请求，并返回预置好的数据。本小节介绍下如何在react项目中使用Mock.js。</p>
<p>执行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install mockjs -D</span><br><span class="line">or</span><br><span class="line">yarn add mockjs -D</span><br></pre></td></tr></table></figure>

<p>在src下新建mock.js，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">'mockjs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> domain = <span class="string">'/api/'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟getData接口</span></span><br><span class="line">Mock.mock(domain + <span class="string">'getData'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = &#123;</span><br><span class="line">      code: <span class="number">200</span>,</span><br><span class="line">      message: <span class="string">'OK'</span>,</span><br><span class="line">      data: <span class="string">'test'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后在src/index.js中引入mock.js:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line">    <span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line">    <span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line">    <span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line">    <span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line">+   <span class="keyword">import</span> <span class="string">'./mock'</span></span><br><span class="line">    <span class="keyword">import</span> <span class="string">'./common/style/frame.styl'</span></span><br><span class="line"></span><br><span class="line">    ...（略）</span><br></pre></td></tr></table></figure>
<p>如此简单。这样，在项目中请求/api/getData的时候，就会被Mock.js拦截，并返回mock.js中写好的数据</p>
<h2 id="9-解决本地开发跨域问题"><a href="#9-解决本地开发跨域问题" class="headerlink" title="9 解决本地开发跨域问题"></a>9 解决本地开发跨域问题</h2><p>在react开发环境中，默认启动的是3000端口，而后端API服务可能在本机的80端口，这样在ajax请求的时候会出现跨域问题。可以借助http-proxy-middleware工具实现反向代理。<br>执行安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install http-proxy-middleware -D</span><br><span class="line">or</span><br><span class="line">yarn add http-proxy-middleware -D</span><br></pre></td></tr></table></figure>
<p>在src下创建setupProxy.js，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">'http-proxy-middleware'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">    app.use(</span><br><span class="line">        <span class="string">'^/api'</span>,</span><br><span class="line">        proxy(&#123;</span><br><span class="line">            target: <span class="string">'http://localhost:5000'</span>,</span><br><span class="line">            changeOrigin: <span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意： 你无需在任何位置导入此文件。 它在启动开发服务器时会自动注册。</p>
</blockquote>
<blockquote>
<p>注意： 此文件仅支持 Node 的 JavaScript 语法。 请务必仅使用支持的语言特性（即不支持 Flow ，ES Modules 等）</p>
</blockquote>
<h2 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h2><p>CSS Modules 的做法就是通过配置将.css文件进行编译，编译后在每个用到css的组件中的css类名都是独一无二的，从而实现CSS的局部作用域。</p>
<p>create-react-app自从2.0.版本就已经开始支持CSS Modules了</p>
<h3 id="局部样式"><a href="#局部样式" class="headerlink" title="局部样式"></a>局部样式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">命名规则: xxx.module.css     </span><br><span class="line"></span><br><span class="line">引入方式 <span class="keyword">import</span> xxx <span class="keyword">from</span> <span class="string">'xxx.module.css'</span></span><br><span class="line"></span><br><span class="line">用法：&lt;div className=&#123;xxx.styleName&#125;&gt;</span><br></pre></td></tr></table></figure>
<h3 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">命名规则: xxx.css   </span><br><span class="line"></span><br><span class="line">引入方式 <span class="keyword">import</span> ‘xxx.css’</span><br><span class="line"></span><br><span class="line">用法：&lt;div className=<span class="string">'styleName'</span>&gt;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">### 案例：</span></span><br><span class="line"><span class="string">`</span>person.module.css<span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> css</span><br><span class="line"></span><br><span class="line">.person&#123;</span><br><span class="line">    width: <span class="number">60</span>%;</span><br><span class="line">    margin:<span class="number">16</span>px auto;</span><br><span class="line">    border: 1px solid #eee;</span><br><span class="line">    box-shadow: 0 2px 3px #ccc;</span><br><span class="line">    padding:<span class="number">16</span>px;</span><br><span class="line">    text-align: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>person.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//局部样式</span></span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./Person.module.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../App.css'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  render() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;styles.person&#125;&gt;</span><br><span class="line">        &lt;p className=<span class="string">'fz'</span>&gt;person:Hello world&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt; </span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>redux</tag>
        <tag>react-router</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SSH连接到GitHub</title>
    <url>/2020/03/08/%E4%BD%BF%E7%94%A8SSH%E8%BF%9E%E6%8E%A5%E5%88%B0GitHub/</url>
    <content><![CDATA[<h2 id="关于-SSH"><a href="#关于-SSH" class="headerlink" title="关于 SSH"></a>关于 SSH</h2><p>使用 SSH 协议可以连接远程服务器和服务并向它们验证。 利用 SSH 密钥可以连接 GitHub，而无需在每次访问时提供用户名或密码。</p>
<h2 id="检查现有-SSH-密钥"><a href="#检查现有-SSH-密钥" class="headerlink" title="检查现有 SSH 密钥"></a>检查现有 SSH 密钥</h2><p>在生成 SSH 密钥之前，您可以检查是否有任何现有的 SSH 密钥。</p>
<ul>
<li>打开 Git Bash。</li>
<li>输入 <code>ls -al ~/.ssh</code> 以查看是否存在现有 SSH 密钥：<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -al ~/.ssh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出 .ssh 目录中的文件（如果有）</span></span><br></pre></td></tr></table></figure></li>
<li>检查目录列表以查看是否已经有 SSH 公钥。 默认情况下，公钥的文件名是以下之一：<ul>
<li>id_rsa.pub</li>
<li>id_ecdsa.pub</li>
<li>id_ed25519.pub<a id="more"></a>
<h2 id="生成新-SSH-密钥"><a href="#生成新-SSH-密钥" class="headerlink" title="生成新 SSH 密钥"></a>生成新 SSH 密钥</h2>检查现有 SSH 密钥后，您可以生成新 SSH 密钥以用于身份验证<br>如果您还没有 SSH 密钥，则必须生成新 SSH 密钥。 如果您不确定是否已有 SSH 密钥，请检查现有密钥。</li>
</ul>
</li>
</ul>
<p><strong>生成新 SSH 密钥</strong></p>
<ul>
<li>打开 Git Bash或者其它终端命令行工具。</li>
<li>粘贴下面的文本（替换为您的 GitHub 电子邮件地址）。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C "your_email@example.com"</span><br></pre></td></tr></table></figure>
这将创建以所提供的电子邮件地址为标签的新 SSH 密钥。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Generating public/private rsa key pair.</span></span><br></pre></td></tr></table></figure></li>
<li>提示您“Enter a file in which to save the key（输入要保存密钥的文件）”时，按 Enter 键。 这将接受默认文件位置。 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> Enter a file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/you/.ssh/id_rsa):[Press enter]</span></span><br></pre></td></tr></table></figure></li>
<li>在提示时输入安全密码(  可以默认回车 )</li>
</ul>
<h2 id="新增-SSH-密钥到-GitHub-帐户"><a href="#新增-SSH-密钥到-GitHub-帐户" class="headerlink" title="新增 SSH 密钥到 GitHub 帐户"></a>新增 SSH 密钥到 GitHub 帐户</h2><p>要配置 GitHub 帐户使用新的（或现有）SSH 密钥，您还需要将其添加到 GitHub 帐户。</p>
<ul>
<li>将 SSH 密钥复制到剪贴板。<br>在复制密钥时，请勿添加任何新行或空格。<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> clip &lt; ~/.ssh/id_rsa.pub</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Copies the contents of the id_rsa.pub file to your clipboard</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>提示：如果 clip 不可用，可找到隐藏的 .ssh 文件夹，在常用的文本编辑器中打开该文件，并将其复制到剪贴板。</p>
</blockquote>
</li>
<li>在github用户设置侧边栏中，单击 SSH and GPG keys（SSH 和 GPG 密钥）。</li>
<li>单击 New SSH key（新 SSH 密钥）或 Add SSH key（添加 SSH 密钥）</li>
<li>在 “Title”（标题）字段中，为新密钥添加描述性标签。 例如，如果您使用的是个人 Mac，此密钥名称可能是 “Personal MacBook Air”。</li>
<li>将密钥粘贴到 “Key”（密钥）字段。</li>
</ul>
<h2 id="测试-SSH-连接"><a href="#测试-SSH-连接" class="headerlink" title="测试 SSH 连接"></a>测试 SSH 连接</h2><ul>
<li>打开 Git Bash或者其它终端命令行工具。</li>
<li>输入以下内容<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对 GitHub 尝试 ssh</span></span><br></pre></td></tr></table></figure>
您可能会看到类似如下的警告：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; The authenticity of host &#39;github.com (IP ADDRESS)&#39; can&#39;t be established.</span><br><span class="line">&gt; RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.</span><br><span class="line">&gt; Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure>
或类似如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; The authenticity of host &#39;github.com (IP ADDRESS)&#39; can&#39;t be established.</span><br><span class="line">&gt; RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.</span><br><span class="line">&gt; Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure>
验证您看到的消息中的指纹匹配步骤 2 中的消息之一，然后输入 yes：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Hi username! You&#39;ve successfully authenticated, but GitHub does not</span><br><span class="line">&gt; provide shell access.</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="权限被拒绝-验证失败"><a href="#权限被拒绝-验证失败" class="headerlink" title="权限被拒绝/验证失败"></a>权限被拒绝/验证失败</h2><p><a href="https://help.github.com/cn/github/authenticating-to-github/error-permission-denied-publickey" target="_blank" rel="noopener">https://help.github.com/cn/github/authenticating-to-github/error-permission-denied-publickey</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>ssh</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>使用typescript封装axios</title>
    <url>/2020/04/22/%E4%BD%BF%E7%94%A8typescript%E5%B0%81%E8%A3%85axios/</url>
    <content><![CDATA[<p>我们在开发中广泛使用的axios调用接口，为了更好地调用，做一些全局的拦截，我们通常会对其进行一下封装，本小节我们就来看下如何使用TypeScript对它进行封装，使其同时能够有很好的类型支持。</p>
<p>首先我们需要安装axios</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>我们在src文件夹下创建utils文件夹，然后在utils文件夹创建*axios.ts文件，axios这个插件自带声明文件，所以我们不需要另外安装了。先来看下最基础的封装：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入axios和定义在node_modules/axios/index.ts文件里的类型声明</span></span><br><span class="line"><span class="keyword">import</span> axios, &#123; AxiosInstance, AxiosRequestConfig, AxiosPromise,AxiosResponse &#125; <span class="keyword">from</span> <span class="string">'axios'</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个接口请求类，用于创建一个axios请求实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个类接收一个字符串参数，是接口请求的基本路径</span></span><br><span class="line">  <span class="keyword">constructor</span>(public baseUrl: string) &#123; </span><br><span class="line">    <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public request(options: AxiosRequestConfig): AxiosPromise &#123; <span class="comment">// 我们实际调用接口的时候调用实例的这个方法，他返回一个AxiosPromise</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里使用axios.create方法创建一个axios实例，他是一个函数，同时这个函数包含多个属性</span></span><br><span class="line">    <span class="keyword">const</span> instance: AxiosInstance = axios.create() </span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并基础路径和每个接口单独传入的配置，比如url、参数等</span></span><br><span class="line">    options = <span class="keyword">this</span>.mergeConfig(options) </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用interceptors方法使拦截器生效</span></span><br><span class="line">    <span class="keyword">this</span>.interceptors(instance, options.url) </span><br><span class="line"></span><br><span class="line">     <span class="comment">// 最后返回AxiosPromise</span></span><br><span class="line">    <span class="keyword">return</span> instance(options)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义这个函数用于添加全局请求和响应拦截逻辑</span></span><br><span class="line">  private interceptors(instance: AxiosInstance, url?: string) &#123;</span><br><span class="line">    <span class="comment">// 在这里添加请求和响应拦截</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个方法用于合并基础路径配置和接口单独配置</span></span><br><span class="line">  private mergeConfig(options: AxiosRequestConfig): AxiosRequestConfig &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123; <span class="attr">baseURL</span>: <span class="keyword">this</span>.baseUrl &#125;, options);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HttpRequest;</span><br></pre></td></tr></table></figure>

<p>我们封装了这个类之后，里面的baseUrl一般本地开发环境的基础路径和线上生产环境的基础路径是不一样的，所以可以根据当前是开发环境还是生产环境做判断，应用不同的基础路径。这里我们要写在一个配置文件里，我们在src文件夹下创建一个config文件夹，然后在这个文件夹创建一个index.ts文件，在里面配置生产和开发环境接口基础路径：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/config/index.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    api: &#123;</span><br><span class="line">        devApiBaseUrl: <span class="string">'/test/api/xxx'</span>,</span><br><span class="line">        proApiBaseUrl: <span class="string">'/api/xxx'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们在<code>axios.ts</code>文件里直接引入接口配置，然后判断当前环境：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ... 其他代码省略</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'@/config'</span>; </span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">api</span>: &#123; devApiBaseUrl, proApiBaseUrl &#125; &#125; = config;</span><br><span class="line"><span class="keyword">const</span> apiBaseUrl = process.env.NODE_ENV === <span class="string">'production'</span> ? proApiBaseUrl : devApiBaseUrl;</span><br><span class="line"><span class="comment">// ... 其他代码省略</span></span><br></pre></td></tr></table></figure>

<p>接下来我们就可以将这个apiBaseUrl作为默认值传入HttpRequest的参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123; <span class="comment">// 定义一个接口请求类，用于创建一个axios请求实例</span></span><br><span class="line">  <span class="keyword">constructor</span>(public baseUrl: string = apiBaseUrl) &#123; <span class="comment">// 这个类接收一个字符串参数，是接口请求的基本路径</span></span><br><span class="line">    <span class="keyword">this</span>.baseUrl = baseUrl;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>接下来我们来完善拦截器，在类中interceptors方法内添加请求拦截器和响应拦截器，实现对所有接口请求的统一处理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">private interceptors(instance: AxiosInstance, url?: string) &#123; <span class="comment">// 定义这个函数用于添加全局请求和响应拦截逻辑</span></span><br><span class="line">    <span class="comment">// 在这里添加请求和响应拦截</span></span><br><span class="line">    instance.interceptors.request.use(<span class="function">(<span class="params">config: AxiosRequestConfig</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 接口请求的所有配置，都在这个config对象中，他的类型是AxiosRequestConfig，你可以看到他有哪些字段</span></span><br><span class="line">      <span class="comment">// 如果你要修改接口请求配置，需要修改 axios.defaults 上的字段值</span></span><br><span class="line">      <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">    instance.interceptors.response.use(<span class="function">(<span class="params">res: AxiosResponse</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; data &#125; = res <span class="comment">// res的类型是AxiosResponse&lt;any&gt;，包含六个字段，其中data是服务端返回的数据</span></span><br><span class="line">      <span class="keyword">const</span> &#123; code, msg &#125; = data <span class="comment">// 通常服务端会将响应状态码、提示信息、数据等放到返回的数据中</span></span><br><span class="line">      <span class="keyword">if</span> (code !== <span class="number">0</span>) &#123; <span class="comment">// 这里我们在服务端将正确返回的状态码标为0</span></span><br><span class="line">        <span class="built_in">console</span>.error(msg) <span class="comment">// 如果不是0，则打印错误信息，我们后面讲到UI组件的时候，这里可以使用消息窗提示</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res <span class="comment">// 返回数据</span></span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123; <span class="comment">// 这里是遇到报错的回调</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>请求时的拦截通过给<code>instance.interceptors.request.use</code>传入回调函数来处理，这个回调函数有一个参数，就是这次请求的配置对象。如果你需要修改请求的配置，需要修改<code>axios.defaults</code>上的字段，来修改全局配置。比如你要在<code>header</code>中添加字段<code>&quot;Content-Type&quot;</code>，需要这样添加：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">axios.defaults.headers.post[<span class="string">'Content-Type'</span>] = <span class="string">'application/x-www-form-urlencoded'</span></span><br></pre></td></tr></table></figure>


<p>到这里我们这个axios请求类就封装好了，上面我们讲了一般服务端会将状态码、提示信息和数据封装在一起，然后作为数据返回，所以我们调用所有api请求返回的数据格式都是一样的，那么我们就可以定义一个接口来指定返回的数据的结构，我们在src/utils/axios.ts文件中定义class HttpRequest前加一个接口定义，并且导出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> interface ResponseData &#123;</span><br><span class="line">  code: number</span><br><span class="line">  data?: any</span><br><span class="line">  msg: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以根据你服务端实际返回的情况，来定义这个接口ResponseData，我这里data字段设为可选的。</p>
<p>接下来我们来简单使用一下。在src文件夹下创建一个api文件夹，然后再这个文件夹创建一个index.ts文件，在这里创建请求实例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/api/index.ts</span></span><br><span class="line"><span class="keyword">import</span> HttpRequest <span class="keyword">from</span> <span class="string">'@/utils/axios'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'@/utils/axios'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> HttpRequest()</span><br></pre></td></tr></table></figure>

<p>我们把这个请求类引进来，然后默认导出一个这个类的实例。后面我们要进行接口请求的时候，要对接口进行分类，比如和用户相关的，和数据相关的等等。这里我们先添加一个登陆接口的请求，所以在api文件夹下创建一个user.ts文件，在这里创建一个登陆接口请求方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/api/user.ts</span></span><br><span class="line"><span class="keyword">import</span> axios, &#123; ResponseData &#125; <span class="keyword">from</span> <span class="string">'./index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; AxiosPromise &#125; <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">interface LoginReqArguInterface &#123;</span><br><span class="line">  user_name: string;</span><br><span class="line">  password: number|string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> loginReq = (data: LoginReqArguInterface): AxiosPromise&lt;ResponseData&gt; =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> axios.request(&#123;</span><br><span class="line">    url: <span class="string">'/api/user/login'</span>,</span><br><span class="line">    data,</span><br><span class="line">    method: <span class="string">'POST'</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们封装登录请求方法loginReq，指定他需要一个参数，参数类型要符合我们定义的<code>LoginReqArguInterface</code>接口指定的结构，这个方法返回一个类型为<code>AxiosPromise</code>的<code>Promise</code>，<code>AxiosPromise</code>这个接口是axios声明文件内置的类型，他可以传入一个泛型变量参数，用于指定api请求返回的结果中data字段的类型。</p>
<p>为什么我们要这样封装api的请求，而不是直接在需要调用接口的地方使用axios.get或者axios.request这些方法直接请求呢？这是因为我们一个api请求可能多个地方需要用到，这里的登录接口复用性很低，但是一些其他接口比如获取数据的接口，可能多个地方会用到，所以我们封装一下，可以统一管理，以后接口升级，就只需要改一个地方就可以了。</p>
<p>接下来我们调用一个这个请求试一下，我们在src/views/Home.vue文件里先调用一下，只是为了先感受一下调用请求的方式，登录接口我们会在下个小节放到登录页实现。</p>
<p>打开Home.vue文件后，我们首先要引入这个请求方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; loginReq &#125; <span class="keyword">from</span> <span class="string">'@/api/user'</span></span><br></pre></td></tr></table></figure>

<p>然后下面我们在Home这个组件类里添加mounted声明周期钩子函数，在这里调用这个api请求方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  public mounted() &#123;</span><br><span class="line">    loginReq(&#123; <span class="attr">user_name</span>: <span class="string">'Lison'</span>, <span class="attr">password</span>: <span class="number">123</span> &#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(res.data.code)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><p><strong>utils/axios.ts</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// axios.ts</span></span><br><span class="line"><span class="keyword">import</span> axios, &#123; AxiosInstance, AxiosRequestConfig, AxiosPromise, AxiosResponse &#125; <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">'@/config'</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">api</span>: &#123; devApiBaseUrl, proApiBaseUrl &#125; &#125; = config</span><br><span class="line"><span class="keyword">const</span> apiBaseUrl = process.env.NODE_ENV === <span class="string">'production'</span> ? proApiBaseUrl : devApiBaseUrl</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> interface ResponseData &#123;</span><br><span class="line">  code: number</span><br><span class="line">  data?: any</span><br><span class="line">  msg: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpRequest</span> </span>&#123; <span class="comment">// 定义一个接口请求类，用于创建一个axios请求实例</span></span><br><span class="line">  <span class="keyword">constructor</span>(public baseUrl: string = apiBaseUrl) &#123; <span class="comment">// 这个类接收一个字符串参数，是接口请求的基本路径</span></span><br><span class="line">    <span class="keyword">this</span>.baseUrl = baseUrl</span><br><span class="line">  &#125;</span><br><span class="line">  public request(options: AxiosRequestConfig): AxiosPromise &#123; <span class="comment">// 我们实际调用接口的时候调用实例的这个方法，他返回一个AxiosPromise</span></span><br><span class="line">    <span class="keyword">const</span> instance: AxiosInstance = axios.create() <span class="comment">// 这里使用axios.create方法创建一个axios实例，他是一个函数，同时这个函数包含多个属性，就像我们前面讲的计数器的例子</span></span><br><span class="line">    options = <span class="keyword">this</span>.mergeConfig(options) <span class="comment">// 合并基础路径和每个接口单独传入的配置，比如url、参数等</span></span><br><span class="line">    <span class="keyword">this</span>.interceptors(instance, options.url) <span class="comment">// 调用interceptors方法使拦截器生效</span></span><br><span class="line">    <span class="keyword">return</span> instance(options) <span class="comment">// 最后返回AxiosPromise</span></span><br><span class="line">  &#125;</span><br><span class="line">  private interceptors(instance: AxiosInstance, url?: string) &#123; <span class="comment">// 定义这个函数用于添加全局请求和响应拦截逻辑</span></span><br><span class="line">    <span class="comment">// 在这里添加请求和响应拦截</span></span><br><span class="line">    instance.interceptors.request.use(<span class="function">(<span class="params">config: AxiosRequestConfig</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 接口请求的所有配置，都在这个config对象中，他的类型是AxiosRequestConfig，你可以看到他有哪些字段</span></span><br><span class="line">      <span class="comment">// 如果你要修改接口请求配置，需要修改 axios.defaults 上的字段值</span></span><br><span class="line">      <span class="keyword">return</span> config</span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">    instance.interceptors.response.use(<span class="function">(<span class="params">res: AxiosResponse</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; data &#125; = res <span class="comment">// res的类型是AxiosResponse&lt;any&gt;，包含六个字段，其中data是服务端返回的数据</span></span><br><span class="line">      <span class="keyword">const</span> &#123; code, msg &#125; = data <span class="comment">// 通常服务端会将响应状态码、提示信息、数据等放到返回的数据中</span></span><br><span class="line">      <span class="keyword">if</span> (code !== <span class="number">0</span>) &#123; <span class="comment">// 这里我们在服务端将正确返回的状态码标为0</span></span><br><span class="line">        <span class="built_in">console</span>.error(msg) <span class="comment">// 如果不是0，则打印错误信息，我们后面讲到UI组件的时候，这里可以使用消息窗提示</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> res <span class="comment">// 返回数据</span></span><br><span class="line">    &#125;,</span><br><span class="line">    (error) =&gt; &#123; <span class="comment">// 这里是遇到报错的回调</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  private mergeConfig(options: AxiosRequestConfig): AxiosRequestConfig &#123; <span class="comment">// 这个方法用于合并基础路径配置和接口单独配置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123; <span class="attr">baseURL</span>: <span class="keyword">this</span>.baseUrl &#125;, options)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HttpRequest</span><br></pre></td></tr></table></figure>

<p><strong>api/index.ts</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// api/index.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> HttpRequest <span class="keyword">from</span> <span class="string">'@/utils/axios'</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'@/utils/axios'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> HttpRequest()</span><br></pre></td></tr></table></figure>

<p><strong>api/user.ts</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios, &#123; ResponseData &#125; <span class="keyword">from</span> <span class="string">'./index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; AxiosPromise &#125; <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">interface LoginReqArguInterface &#123;</span><br><span class="line">    user_name: string</span><br><span class="line">    password: number|string</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> loginReq = (data: LoginReqArguInterface): AxiosPromise&lt;ResponseData&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.request(&#123;</span><br><span class="line">        url: <span class="string">'/api/user/login'</span>,</span><br><span class="line">        data,</span><br><span class="line">        method: <span class="string">'POST'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getInfoReq = (): AxiosPromise&lt;ResponseData&gt; =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> axios.request(&#123;</span><br><span class="line">        url: <span class="string">'/api/user/get_info'</span>,</span><br><span class="line">        method: <span class="string">'GET'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>axios</tag>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用nodeJS+cheerio实现一个简单的网页爬虫功能</title>
    <url>/2020/04/02/%E4%BD%BF%E7%94%A8nodeJS%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E9%A1%B5%E7%88%AC%E8%99%AB%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>本文将使用nodeJS+cheerio实现一个简单的网页爬虫功能</p>
<h2 id="网页源码"><a href="#网页源码" class="headerlink" title="网页源码"></a>网页源码</h2><p>使用http.get()方法获取网页源码，以hao123网站的头条页面为例<br><code>http://tuijian.hao123.com/hotrank</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.get(<span class="string">'http://tuijian.hao123.com/hotrank'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">    res.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        data += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="筛选数据"><a href="#筛选数据" class="headerlink" title="筛选数据"></a>筛选数据</h2><p>以网页中的综艺热点部分<br><img src="http://static.zybuluo.com/wp0214/bqzguv8jnanuu54eds2ejo81/image_1c4ghuuf5s7a2bk1pn81s5m1e17p.png" alt="image_1c4ghuuf5s7a2bk1pn81s5m1e17p.png-19.9kB"></p>
<p>源网页相关源代码如下<br><img src="http://static.zybuluo.com/wp0214/mlhm6kp2pnpdje3tezukme7t/image_1c4ghvq9d16no1rb81otv17ef1rg716.png" alt="image_1c4ghvq9d16no1rb81otv17ef1rg716.png-106.3kB"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过分析可知，‘综艺’模块与其他模块都位于&lt;div class&#x3D;&quot;top-wrap&quot;&gt;中，其中，综艺模块的内层div的monkey&#x3D;&#39;zy&#39;，综艺模块的10条综艺节目的信息都位于&lt;div class&#x3D;&quot;poinr clearfix&quot;&gt;中，综艺节目的名称位于&lt;span class&#x3D;&quot;point-title&quot;&gt;中</span><br></pre></td></tr></table></figure>

<h2 id="cheerio"><a href="#cheerio" class="headerlink" title="cheerio"></a>cheerio</h2><p>我们怎么从源代码中获取到有用的数据呢？首先，nodeJS不支持document对象。如果要使用笨办法，只能使用正则表达式来处理</p>
<p>cheerio 是nodejs特别为服务端定制的，能够快速灵活的对JQuery核心进行实现。它工作于DOM模型上，且解析、操作、呈送都很高效</p>
<p><strong>【安装】</strong></p>
<p><img src="http://static.zybuluo.com/wp0214/dy77b8ris2x9ln9mbua4kli7/image_1c4gi1vi3g3916rs3rd1o0aino1j.png" alt="image_1c4gi1vi3g3916rs3rd1o0aino1j.png-15.5kB"></p>
<p><strong>【使用】</strong><br>它的使用方法和jQuery相当类似，上手非常容易。以获取综艺热度前10名的节目名称为例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line">http.get(<span class="string">'http://tuijian.hao123.com/hotrank'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">    res.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        data += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        filter(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//保存搜索量前10的综艺节目标题</span></span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="comment">//将页面源代码转换为$对象</span></span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(data);</span><br><span class="line">    <span class="comment">//查找每个综艺节目标题的外层div</span></span><br><span class="line">    <span class="keyword">var</span> temp_arr = $(<span class="string">'[monkey = "zy"]'</span>).find(<span class="string">'.point-bd'</span>).find(<span class="string">'.point-title'</span>);</span><br><span class="line">    <span class="comment">//将综艺节目标题依次保存到结果数组中</span></span><br><span class="line">    temp_arr.each(<span class="function"><span class="keyword">function</span>(<span class="params">index,item</span>)</span>&#123;</span><br><span class="line">        result.push($(item).text());</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//[ '变形计','来吧冠军','拜托了冰箱','昆仑决','天生是优我','姐姐好饿','脑力男人时代','奔跑吧兄弟','我想和你唱','玫瑰之旅' ]</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="爬虫代码"><a href="#爬虫代码" class="headerlink" title="爬虫代码"></a>爬虫代码</h2><p>　下面将hao123网页中的’实时热点’、’今日热点’、’民生热点’、’电影’、’电视剧’、’综艺’这6部分的排名爬下来，分别到对象名为’result’中的数组中，分别命令为’ss’、’jr’、’ms’、’dy’、’dsj’、’zy’<br>　<img src="http://static.zybuluo.com/wp0214/07j777aovt2viwi0xr6pzrd9/image_1c4gi42np12prqb16up1ci9lc20.png" alt="image_1c4gi42np12prqb16up1ci9lc20.png-103.2kB"></p>
<p><strong>【代码如下】</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</span><br><span class="line">http.get(<span class="string">'http://tuijian.hao123.com/hotrank'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">    res.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        data += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        filter(data);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//保存各部分搜索量前10的名称</span></span><br><span class="line">    <span class="comment">//对象名为榜单名，如'实时热点'</span></span><br><span class="line">    <span class="comment">//对象内容为10个标题名称组成的数组</span></span><br><span class="line">    <span class="keyword">var</span> result = &#123;&#125;;</span><br><span class="line">    <span class="comment">//将页面源代码转换为$对象</span></span><br><span class="line">    <span class="keyword">var</span> $ = cheerio.load(data);</span><br><span class="line">    <span class="comment">//查找'实时热点'、'今日热点'、'民生热点'、'电影'、'电视剧'、'综艺'这6个榜单所在的div</span></span><br><span class="line">    <span class="keyword">var</span> temp_div = $(<span class="string">'.top-wrap'</span>);</span><br><span class="line">    <span class="comment">//保存榜单名称</span></span><br><span class="line">    <span class="keyword">var</span> temp_title = [];</span><br><span class="line">    temp_div.each(<span class="function"><span class="keyword">function</span>(<span class="params">index,item</span>)</span>&#123;</span><br><span class="line">        <span class="comment">//查找榜单名，并保存到temp_title文件夹中</span></span><br><span class="line">        temp_title.push($(item).find(<span class="string">'h2'</span>).text());</span><br><span class="line">        <span class="comment">//查找每类下每个标题的外层div</span></span><br><span class="line">        <span class="keyword">var</span> temp_arr = $(item).find(<span class="string">'.point-bd'</span>).find(<span class="string">'.point-title'</span>);</span><br><span class="line">        <span class="comment">//将result下的每个榜单初始化为一个数组</span></span><br><span class="line">        <span class="keyword">var</span> innerResult = result[temp_title[index]] = [];</span><br><span class="line">        <span class="comment">//将节目标题依次保存到相应榜单的数组中</span></span><br><span class="line">        temp_arr.each(<span class="function"><span class="keyword">function</span>(<span class="params">_index,_item</span>)</span>&#123;</span><br><span class="line">            innerResult.push($(_item).text())</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>【结果如下】</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123; <span class="string">'实时热点'</span>: </span><br><span class="line">   [ <span class="string">'美国逮捕女斯诺登'</span>,</span><br><span class="line">     <span class="string">'成都隐秘母乳买卖'</span>,</span><br><span class="line">     <span class="string">'曝周杰伦青涩旧照'</span>,</span><br><span class="line">     <span class="string">'老头公交强吻女孩'</span>,</span><br><span class="line">     <span class="string">'王传君恋情曝光'</span>,</span><br><span class="line">     <span class="string">'杭州现奇葩窗口'</span>,</span><br><span class="line">     <span class="string">'忘带全班准考证'</span>,</span><br><span class="line">     <span class="string">'未成年持械拍网红'</span>,</span><br><span class="line">     <span class="string">'9秒揍儿子8拳'</span>,</span><br><span class="line">     <span class="string">'戴耳机穿轨道被撞'</span> ],</span><br><span class="line">  <span class="string">'今日热点'</span>: </span><br><span class="line">   [ <span class="string">'北京回龙观大火'</span>,</span><br><span class="line">     <span class="string">'选美冠军车祸身亡'</span>,</span><br><span class="line">     <span class="string">'2017高考'</span>,</span><br><span class="line">     <span class="string">'成都老火锅店被查'</span>,</span><br><span class="line">     <span class="string">'陈浩民娇妻秀身材'</span>,</span><br><span class="line">     <span class="string">'海边直播发现浮尸'</span>,</span><br><span class="line">     <span class="string">'曝印小天遭妻骗婚'</span>,</span><br><span class="line">     <span class="string">'苹果开发者大会'</span>,</span><br><span class="line">     <span class="string">'6万斤鱼缺氧死亡'</span>,</span><br><span class="line">     <span class="string">'安以轩夏威夷大婚'</span> ],</span><br><span class="line">  <span class="string">'民生热点'</span>: </span><br><span class="line">   [ <span class="string">'北京回龙观大火'</span>,</span><br><span class="line">     <span class="string">'2017高考'</span>,</span><br><span class="line">     <span class="string">'成都老火锅店被查'</span>,</span><br><span class="line">     <span class="string">'海边直播发现浮尸'</span>,</span><br><span class="line">     <span class="string">'苹果开发者大会'</span>,</span><br><span class="line">     <span class="string">'6万斤鱼缺氧死亡'</span>,</span><br><span class="line">     <span class="string">'北控外援训练猝死'</span>,</span><br><span class="line">     <span class="string">'武汉男子裸体捅人'</span>,</span><br><span class="line">     <span class="string">'多国与卡塔尔断交'</span>,</span><br><span class="line">     <span class="string">'美驻华外交官辞职'</span> ],</span><br><span class="line">  <span class="string">'电影'</span>: </span><br><span class="line">   [ <span class="string">'神奇女侠'</span>,</span><br><span class="line">     <span class="string">'异星觉醒'</span>,</span><br><span class="line">     <span class="string">'新木乃伊'</span>,</span><br><span class="line">     <span class="string">'中国推销员'</span>,</span><br><span class="line">     <span class="string">'荡寇风云'</span>,</span><br><span class="line">     <span class="string">'异兽来袭'</span>,</span><br><span class="line">     <span class="string">'李雷和韩梅梅'</span>,</span><br><span class="line">     <span class="string">'北极星'</span>,</span><br><span class="line">     <span class="string">'美好的意外'</span>,</span><br><span class="line">     <span class="string">'夏天19岁的肖像'</span> ],</span><br><span class="line">  <span class="string">'电视剧'</span>: </span><br><span class="line">   [ <span class="string">'龙珠传奇'</span>,</span><br><span class="line">     <span class="string">'楚乔传'</span>,</span><br><span class="line">     <span class="string">'欢乐颂2'</span>,</span><br><span class="line">     <span class="string">'欢乐颂'</span>,</span><br><span class="line">     <span class="string">'职场是个技术活'</span>,</span><br><span class="line">     <span class="string">'择天记'</span>,</span><br><span class="line">     <span class="string">'美食大冒险'</span>,</span><br><span class="line">     <span class="string">'废柴兄弟'</span>,</span><br><span class="line">     <span class="string">'人民的名义'</span>,</span><br><span class="line">     <span class="string">'三生三世十里桃花'</span> ],</span><br><span class="line">  <span class="string">'综艺'</span>: </span><br><span class="line">   [ <span class="string">'变形计'</span>,</span><br><span class="line">     <span class="string">'来吧冠军'</span>,</span><br><span class="line">     <span class="string">'拜托了冰箱'</span>,</span><br><span class="line">     <span class="string">'昆仑决'</span>,</span><br><span class="line">     <span class="string">'天生是优我'</span>,</span><br><span class="line">     <span class="string">'姐姐好饿'</span>,</span><br><span class="line">     <span class="string">'脑力男人时代'</span>,</span><br><span class="line">     <span class="string">'奔跑吧兄弟'</span>,</span><br><span class="line">     <span class="string">'我想和你唱'</span>,</span><br><span class="line">     <span class="string">'玫瑰之旅'</span> ] &#125;</span><br><span class="line">[Finished <span class="keyword">in</span> <span class="number">0.7</span>s]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>nodejs</category>
        <category>案例</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>案例</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>前端团队代码规范最佳实践</title>
    <url>/2020/04/29/%E5%89%8D%E7%AB%AF%E5%9B%A2%E9%98%9F%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>一千个读者，就有一千个哈姆雷特。</p>
<p>一千个程序员，就有一千种代码风格。</p>
<p>那什么是代码风格呢？从小的来说，有的开发喜欢带分号，有的不喜欢带分号。有的喜欢使用空格，有的喜欢使用 Tab。有的喜欢空两个空格，有的喜欢四个空格。除了这些，还有一些关于代码的优化，如避免声明未使用，避免冗余的代码逻辑等。如果你是新参加工作的人员，又恰好遇到一个代码风格混乱，密密麻麻赋值前后都不带空格的项目，只能有苦难言了。</p>
<p>因此团队合作中需要统一规范。</p>
<a id="more"></a>

<h2 id="ESLint-与约束"><a href="#ESLint-与约束" class="headerlink" title="ESLint 与约束"></a>ESLint 与约束</h2><p>统一编码规范不仅可以大幅提高代码可读性，甚至会提高代码质量。当我们设计了一套关于编码规范的规则集时，需要工具去辅助检测，这就是 <code>ESLint</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">$ npm install eslint --save-dev</span><br></pre></td></tr></table></figure>
<p>规则集需要统一集中配置，<code>ESLint</code> 会默认读取配置文件 <code>.eslintrc</code> 来解析，而规则集在 <code>rules</code> 中进行配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"rules"</span>: &#123;</span><br><span class="line">    <span class="string">"semi"</span>: [<span class="string">"error"</span>, <span class="string">"always"</span>],</span><br><span class="line">    <span class="string">"quotes"</span>: [<span class="string">"error"</span>, <span class="string">"double"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而我们需要做的是设定我们的代码规范，即 <code>rules</code> 项</p>
<h2 id="不要重复造轮子"><a href="#不要重复造轮子" class="headerlink" title="不要重复造轮子"></a>不要重复造轮子</h2><p>我们需要推到重来，设计属于自己团队的一套编码规范吗？</p>
<p>完全没有必要推倒重来，既耗费人力，又难以做到规则的全部覆盖。</p>
<p>很多优秀的团队，都根据最佳实践设定了特别优秀的编码规范，比如 <code>airbnb</code> 设定了一套约束特别强的规范。另外也有一些特别简单但却十分实用的规范，如 <code>eslint:recommended</code>。</p>
<ul>
<li>airbnb javascript style</li>
</ul>
<p>我们仅仅需要使用 <code>extend</code> 配置项去继承一些优秀的开源的代码规范，并使用 <code>rules</code> 做一些自己团队的规则补充。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"extend"</span>: [<span class="string">"airbnb-base"</span>],</span><br><span class="line">  <span class="string">"rules"</span>: &#123;</span><br><span class="line">    <span class="string">"semi"</span>: [<span class="string">"error"</span>, <span class="string">"never"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title>基于electron开发轻量级自动部署工具</title>
    <url>/2020/04/04/%E5%9F%BA%E4%BA%8Eelectron%E5%BC%80%E5%8F%91%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="部署狗"><a href="#部署狗" class="headerlink" title="部署狗"></a>部署狗</h1><ul>
<li>适用与个人与小团队的轻量级自动部署工具</li>
<li>基于electron+vue+element开发</li>
<li><a href="https://github.com/RocWangPeng/deploy-dog" target="_blank" rel="noopener">github</a><h2 id="技术棧"><a href="#技术棧" class="headerlink" title="技术棧"></a>技术棧</h2></li>
<li>electron-vue</li>
</ul>
<p>##开发</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install</span><br><span class="line">$ npm run dev</span><br></pre></td></tr></table></figure>

<h2 id="先来一波图"><a href="#先来一波图" class="headerlink" title="先来一波图"></a>先来一波图</h2><p><strong>项目管理</strong></p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/1703d79184901871%20(1).jpg" alt=""></p>
<a id="more"></a>
<p><strong>添加项目</strong></p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/2.jpg" alt=""></p>
<p><strong>发布进度</strong></p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/3.jpg" alt=""></p>
<h2 id="部署流程"><a href="#部署流程" class="headerlink" title="部署流程"></a>部署流程</h2><p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/4.jpg" alt=""></p>
<h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p><a href="https://github.com/RocWangPeng/deploy-dog/releases/tag/1.0.0" target="_blank" rel="noopener">windows下载</a></p>
<h2 id="具体代码："><a href="#具体代码：" class="headerlink" title="具体代码："></a>具体代码：</h2><ul>
<li><p>部署代码 deploy.js (electron主进程中执行)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> node_ssh = <span class="built_in">require</span>(<span class="string">'node-ssh'</span>);</span><br><span class="line"><span class="keyword">const</span> zipFile = <span class="built_in">require</span>(<span class="string">'compressing'</span>)<span class="comment">// 压缩zip</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> SSH = <span class="keyword">new</span> node_ssh(); <span class="comment">// 生成ssh实例</span></span><br><span class="line"><span class="keyword">let</span> mainWindow = <span class="literal">null</span>; <span class="comment">// 窗口实例,用于向向渲染进程通信</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 部署流程入口</span></span><br><span class="line"><span class="keyword">const</span> deploy = <span class="keyword">async</span> (config, mainWindows) =&gt; &#123;</span><br><span class="line">    mainWindow = mainWindows</span><br><span class="line">    <span class="keyword">await</span> startZip(config);</span><br><span class="line">    <span class="keyword">await</span> connectSSH(config);</span><br><span class="line">    <span class="keyword">await</span> uploadZipBySSH(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压缩代码</span></span><br><span class="line"><span class="keyword">const</span> startZip = <span class="keyword">async</span> (config) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> &#123; distPath &#125; = config;</span><br><span class="line">        <span class="keyword">let</span> distZipPath = path.resolve(distPath, <span class="string">`../dist.zip`</span>);</span><br><span class="line">        mainWindow.send(<span class="string">'deploy'</span>, <span class="string">'本地项目开始压缩'</span>)</span><br><span class="line">        zipFile.zip.compressDir(distPath, distZipPath).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            mainWindow.send(<span class="string">'deploy'</span>, <span class="string">`本地项目压缩完成:<span class="subst">$&#123;distZipPath&#125;</span>`</span>)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            mainWindow.send(<span class="string">'deploy'</span>, <span class="string">`压缩失败<span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">            reject()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//连接服务器</span></span><br><span class="line"><span class="keyword">const</span> connectSSH = <span class="keyword">async</span> (config) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        mainWindow.send(<span class="string">'deploy'</span>, <span class="string">`正在连接服务器:<span class="subst">$&#123;config.host&#125;</span>`</span>)</span><br><span class="line">        SSH.connect(&#123;</span><br><span class="line">            host: config.host,</span><br><span class="line">            username: config.username,</span><br><span class="line">            password: config.password <span class="comment">// 密码登录 方式二</span></span><br><span class="line">        &#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            mainWindow.send(<span class="string">'deploy'</span>, <span class="string">`连接服务器成功:<span class="subst">$&#123;config.host&#125;</span>`</span>)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">            mainWindow.send(<span class="string">'deploy'</span>, <span class="string">`连接服务器失败:<span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">            reject()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空线上目标目录里的旧文件</span></span><br><span class="line"><span class="keyword">const</span> clearOldFile = <span class="keyword">async</span> (config) =&gt; &#123;</span><br><span class="line">    mainWindow.send(<span class="string">'deploy'</span>, <span class="string">`准备清空服务器部署目录<span class="subst">$&#123;config.webDir&#125;</span>内的文件`</span>)</span><br><span class="line">    <span class="keyword">const</span> commands = [<span class="string">'ls'</span>, <span class="string">'rm -rf *'</span>];</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.all(commands.map(<span class="keyword">async</span> (item) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">await</span> SSH.execCommand(item, &#123; <span class="attr">cwd</span>: config.webDir &#125;);</span><br><span class="line">    &#125;));</span><br><span class="line">    mainWindow.send(<span class="string">'deploy'</span>, <span class="string">`清空服务器目录<span class="subst">$&#123;config.webDir&#125;</span>内的文件完成`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上传zip文件到服务器</span></span><br><span class="line"><span class="keyword">const</span> uploadZipBySSH = <span class="keyword">async</span> (config) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> distZipPath = path.resolve(config.distPath, <span class="string">`../dist.zip`</span>);</span><br><span class="line">    <span class="comment">//线上目标文件清空</span></span><br><span class="line">    <span class="keyword">await</span> clearOldFile(config);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> SSH.putFiles([&#123; <span class="attr">local</span>: distZipPath, <span class="attr">remote</span>: config.webDir + <span class="string">'/dist.zip'</span> &#125;]); <span class="comment">//local 本地 ; remote 服务器 ;</span></span><br><span class="line">        mainWindow.send(<span class="string">'deploy'</span>, <span class="string">`上传文件到服务器成功:<span class="subst">$&#123;config.webDir&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">await</span> SSH.execCommand(<span class="string">'unzip -o dist.zip &amp;&amp; rm -f dist.zip'</span>, &#123; <span class="attr">cwd</span>: config.webDir &#125;); <span class="comment">//解压</span></span><br><span class="line">        mainWindow.send(<span class="string">'deploy'</span>, <span class="string">`解压上传到服务器的文件成功`</span>)</span><br><span class="line">        <span class="keyword">await</span> SSH.execCommand(<span class="string">`rm -rf <span class="subst">$&#123;config.webDir&#125;</span>/dist.zip`</span>, &#123; <span class="attr">cwd</span>: config.webDir &#125;); <span class="comment">//解压完删除线上压缩包</span></span><br><span class="line">        mainWindow.send(<span class="string">'deploy'</span>, <span class="string">`删除上传到服务器的文件成功`</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将解压后的文件夹内的所有文件移动到目标目录</span></span><br><span class="line">        <span class="keyword">var</span> dir = path.basename(path.join(config.distPath))</span><br><span class="line">        mainWindow.send(<span class="string">'deploy'</span>, <span class="string">`将<span class="subst">$&#123;config.webDir&#125;</span>/<span class="subst">$&#123;dir&#125;</span>/内解压的文件移动到目录<span class="subst">$&#123;config.webDir&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">await</span> SSH.execCommand(<span class="string">`mv - f <span class="subst">$&#123;config.webDir&#125;</span>/<span class="subst">$&#123;dir&#125;</span>/*  <span class="subst">$&#123;config.webDir&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">await</span> SSH.execCommand(<span class="string">`rm -rf <span class="subst">$&#123;config.webDir&#125;</span>/<span class="subst">$&#123;dir&#125;</span>`</span>); <span class="comment">//移出后删除 dist 文件夹</span></span><br><span class="line">        mainWindow.send(<span class="string">'deploy'</span>, <span class="string">`全部完成`</span>)</span><br><span class="line">        SSH.dispose(); <span class="comment">//断开连接</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">        mainWindow.send(<span class="string">'deploy'</span>, <span class="string">`文件上传到服务器失败:<span class="subst">$&#123;error&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">// process.exit(); //退出流程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> deploy</span><br></pre></td></tr></table></figure>
</li>
<li><p>主进程进行监听与渲染进行发送的命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听前台传来的deploy命令</span></span><br><span class="line">ipcMain.on(<span class="string">'deploy'</span>, (e, data) =&gt; &#123;</span><br><span class="line">  deploy(data, mainWindow)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>前台部分代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"wrapper"</span>&gt;</span><br><span class="line">    &lt;el-row :gutter=<span class="string">"20"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"pro-list"</span>&gt;</span><br><span class="line">      &lt;el-col :span=<span class="string">"12"</span> v-<span class="keyword">for</span>=<span class="string">"(item, index) in dataList"</span> :key=<span class="string">"index"</span>&gt;</span><br><span class="line">        &lt;el-card <span class="class"><span class="keyword">class</span></span>=<span class="string">"box-card"</span>&gt;</span><br><span class="line">          &lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"prolist"</span>&gt;</span><br><span class="line">            &lt;li&gt;</span><br><span class="line">              &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"label"</span>&gt;项目名称:&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">              &lt;span class="info"&gt;&#123;&#123; item.projectName &#125;&#125;&lt;/</span>span&gt;</span><br><span class="line">            &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">            &lt;li&gt;</span></span><br><span class="line"><span class="regexp">              &lt;span class="label"&gt;服务器地址:&lt;/</span>span&gt;</span><br><span class="line">              &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"info"</span>&gt;&#123;&#123; item.host &#125;&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>li&gt;</span><br><span class="line">        <span class="comment">//    ...other</span></span><br><span class="line">          &lt;<span class="regexp">/ul&gt;</span></span><br><span class="line"><span class="regexp">          &lt;div class="btns"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;el-button icon="el-icon-s-promotion" @click="deploy(item)" type="primary"&gt;发布&lt;/</span>el-button&gt;</span><br><span class="line">          &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>el-card&gt;</span><br><span class="line">      &lt;<span class="regexp">/el-col&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>el-row&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> &#123; ipcRenderer &#125; <span class="keyword">from</span> <span class="string">"electron"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">"prolist"</span>,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">this</span>.getDb();</span><br><span class="line">    <span class="comment">// 接收主进程部署过程 中的 过程信息</span></span><br><span class="line">    ipcRenderer.on(<span class="string">"deploy"</span>, (event, arg) =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.activities.unshift(&#123;</span><br><span class="line">        content:arg,</span><br><span class="line">        timestamp: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      dataList: [],</span><br><span class="line">      activities: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部署</span></span><br><span class="line">    deploy(config) &#123;</span><br><span class="line">    <span class="comment">//   发送打包命令 给 主进程</span></span><br><span class="line">      ipcRenderer.send(<span class="string">"deploy"</span>, config);</span><br><span class="line">    &#125;,</span><br><span class="line">    remove(config) &#123;</span><br><span class="line">    <span class="comment">//   删除项目</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<blockquote>
<p>仅供大家学习参考</p>
</blockquote>
<blockquote>
<p>所有数据存在本地lowdb中，所以不用担心安全问题</p>
</blockquote>
]]></content>
      <categories>
        <category>案例</category>
        <category>桌面端开发</category>
      </categories>
      <tags>
        <tag>案例</tag>
        <tag>electron</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常考知识点笔记</title>
    <url>/2020/04/24/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%80%83%E7%9F%A5%E8%AF%86%E7%82%B9%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="开篇：为什么要记录"><a href="#开篇：为什么要记录" class="headerlink" title="开篇：为什么要记录"></a>开篇：为什么要记录</h2><p>多年的经历，使我得出一个结论：面试表现和工作能力，并没有大多数人以为的那么相关。一个技术能力优秀的程序员，很可能因为忘记 Event Loop 的内容而被认为基础知识不扎实；一个原来在团队中没有存在感每天划水的人，却有可能因为碰巧面试前一天晚上刷到了浏览器缓存机制的面试题，而被认为是基础扎实的大牛。实际上，如果面试总是能准确地反映出一个人真正的技术能力，大公司里就不会有这么多划水的人了。</p>
<p>工作能力强，并不代表面试表现就一定好；工作有工作的技巧，面试有面试的技巧，它们有一些联系，但是它们是两个不同的学科。</p>
<a id="more"></a>

<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><p><strong>this指向取决与当前执行上下文</strong></p>
<ul>
<li>当函数被当作独立函数调用时<ul>
<li>严格模式下this指向undefined；</li>
<li>非严格模式下this指向window。</li>
</ul>
</li>
<li>当函数被当做对象的方法调用时，this指向调用者，也就是this指向此对象。</li>
<li>当函数被当作构造函数调用时，this关键字指向使用构造函数创建的实例</li>
<li>当函数为箭头函数调用时，this关键字指向上一级作用域</li>
</ul>
<!-- more -->

<h3 id="如何判断一个数据的类型？"><a href="#如何判断一个数据的类型？" class="headerlink" title="如何判断一个数据的类型？"></a>如何判断一个数据的类型？</h3><ul>
<li>使用 <code>typeof</code>，这个方法可以检测出 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>undefined</code> 和 <code>function</code> 的类型，但是当被检测的值为数组、对象或者 <code>null</code> 类型时，结果均为 <code>object</code>，无法准确判断它们的类型</li>
<li>使用<code>Object.prototype.toString.call</code>，目前这是最为可靠的检测类型的方法</li>
<li>如果检测是否是数组，可以用这个方法：<code>Array.isArray</code></li>
</ul>
<h3 id="变量的存放"><a href="#变量的存放" class="headerlink" title="变量的存放"></a>变量的存放</h3><p>首先我们应该知道内存中有栈和堆，那么变量应该存放在哪里呢，堆？栈？</p>
<ul>
<li>1、基本类型 –&gt; 保存在栈内存中，因为这些类型在内存中分别占有固定大小的空间，通过按值来访问。基本类型一共有6种：Undefined、Null、Boolean、Number 、String和Symbol</li>
<li>2、引用类型 –&gt; 保存在堆内存中，因为这种值的大小不固定，因此不能把它们保存到栈内存中，但内存地址大小的固定的，因此保存在堆内存中，在栈内存中存放的只是该对象的访问地址。当查询引用类型的变量时， 先从栈中读取内存地址， 然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200428150700.png" alt=""><br>在计算机的数据结构中，栈比堆的运算速度快，Object是一个复杂的结构且可以扩展：数组可扩充，对象可添加属性，都可以增删改查。将他们放在堆中是为了不影响栈的效率。而是通过引用的方式查找到堆中的实际对象再进行操作。所以查找引用类型值的时候先去栈查找再去堆查找</p>
<p><strong>几个问题</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时a的值是多少？</span></span><br></pre></td></tr></table></figure>
<p><strong>20</strong><br>a、b都是基本类型，它们的值是存储在栈中的，a、b分别有各自独立的栈空间，所以修改了b的值以后，a的值并不会发生变化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">'前端开发'</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b.name = <span class="string">'进阶'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时a.name的值是多少</span></span><br></pre></td></tr></table></figure>
<p><strong>进阶</strong><br>a、b都是引用类型，栈内存中存放地址指向堆内存中的对象，引用类型的复制会为新的变量自动分配一个新的值保存在变量对象中，但只是引用类型的一个地址指针而已，实际指向的是同一个对象，所以修改b.name的值后，相应的a.name也就发生了改变。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">name</span>: <span class="string">'前端开发'</span> &#125;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时b的值是多少</span></span><br></pre></td></tr></table></figure>
<p><strong>{ name: ‘前端开发’ }</strong><br>首先要说明的是null是基本类型，a = null之后只是把a存储在栈内存中地址改变成了基本类型null，并不会影响堆内存中的对象，所以b的值不受影响。</p>
<h3 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h3><p>执行上下文是一个抽象的概念，它形容了一段代码在运行时所处的环境。每个函数在执行时都有自己的执行上下文</p>
<p>JavaScript 中有三种执行上下文类型:</p>
<ul>
<li>全局执行上下文 （global execution context）。一个程序中只有一个全局上下文，在浏览器中其为 window 对象。</li>
<li>函数执行上下文 （function execution context）。每当函数被执行时，一个新的执行上下文就被创建了。</li>
<li>Eval 函数执行上下文 （eval execution context）。执行在 eval 中的代码时也会有其独立的执行上下文。</li>
</ul>
<h3 id="什么是词法作用域？"><a href="#什么是词法作用域？" class="headerlink" title="什么是词法作用域？"></a>什么是词法作用域？</h3><p>词法作用域是作用域的其中一个工作模型，词法作用域主要在代码的编译阶段<br>词法作用域也就是在代码的编译阶段定义的作用域，也就是说词法作用域在代码书写时就已经确定了。</p>
<p><strong>词法作用域的内涵是，作用域在词法分析阶段就被确定了，也就是说，变量在代码中所处的位置 (而不是运行时所处的位置)，决定了作用域。</strong></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>JavaScript 的作用域是基于词法作用域的，词法作用域的内涵是：作用域在词法分析阶段就被确定了，也就是说，<strong>变量在代码中所处的位置 (而不是运行时所处的位置)，决定了作用域。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = foo()</span><br><span class="line">func() <span class="comment">// 打印出 2</span></span><br></pre></td></tr></table></figure>
<p>当函数<code>bar</code>执行时，很明显其早已脱离了原来的作用域，但是其依然打印出变量<code>a</code>的值，这就说明它一直记住了它在被定义时的作用域。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当访问一个变量时，解释器会首先在当前作用域查找标示符，如果没有找到，就去父作用域找，直到找到该变量的标示符或者不在父作用域中，这就是作用域链。</p>
<p>每个对象拥有一个原型对象，通过<code>__proto__</code> 指针指向上一个原型 ，并从中继承方法和属性，同时原型对象也可能拥有原型，这样一层一层，最终指向 null。这种关系被称为原型链 (prototype chain)，通过原型链一个对象会拥有定义在其他对象中的属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Parent(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">p;	<span class="comment">// Parent &#123;age: 50&#125;</span></span><br><span class="line">p.__proto__ === Parent.prototype; <span class="comment">// true</span></span><br><span class="line">p.__proto__.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line">p.__proto__.__proto__.__proto__ === <span class="literal">null</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>下图展示了原型链的运作机制。<br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200428155014.png" alt=""></p>
<h3 id="闭包-closure-是什么？"><a href="#闭包-closure-是什么？" class="headerlink" title="闭包 (closure) 是什么？"></a>闭包 (closure) 是什么？</h3><p>通俗回答一般为：<br>函数嵌套函数，内部函数访问外部函数的的变量，这就是闭包环境</p>
<p><strong>答案：</strong><br>JavaScript 的作用域是基于词法作用域的，词法作用域的内涵是：作用域在词法分析阶段就被确定了，也就是说，变量的作用域在代码中所处的位置 (而不是运行时所处的位置)</p>
<p><strong>闭包就是函数能够记住并访问它的词法作用域</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = foo()</span><br><span class="line">func() <span class="comment">// 打印出 2</span></span><br></pre></td></tr></table></figure>
<p>当函数bar执行时，很明显其早已脱离了原来的作用域，但是其依然打印出变量a的值，这就说明它一直记住了它在被定义时的作用域。</p>
<p>综上所述，闭包是词法作用域和函数是JavaScript的第一公民相互所用自然而然产生的现象。</p>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><ul>
<li>读取函数内部的变量</li>
<li>让这些变量的值始终保持在内存中</li>
</ul>
<p>在实际开发中，闭包主要是用来封装变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包隐藏数据，只提供 API</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCache</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 闭包中的数据，被隐藏，不被外界访问</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;&#125; </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">set</span>: function (key, val) &#123;</span><br><span class="line">            data[key] = val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">get</span>: function (key) &#123;</span><br><span class="line">            <span class="keyword">return</span> data[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = createCache()</span><br><span class="line">c.set(<span class="string">'a'</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log( c.get(<span class="string">'a'</span>) )</span><br></pre></td></tr></table></figure>

<h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><p>JavaScript有自动垃圾收集机制，垃圾收集器会每隔一段时间就执行一次释放操作，找出那些不再继续使用的值，然后释放其占用的内存。</p>
<ul>
<li><strong>局部变量</strong>：局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。</li>
<li><strong>全局变量</strong>：全局变量什么时候需要自动释放内存空间则很难判断，所以在开发中尽量避免使用全局变量。</li>
</ul>
<h4 id="标记清除（常用）"><a href="#标记清除（常用）" class="headerlink" title="标记清除（常用）"></a>标记清除（常用）</h4><p>标记清除算法将“不再使用的对象”定义为“无法到达的对象”。即从根部（在JS中就是全局对象）出发定时扫描内存中的对象，凡是能从根部到达的对象，保留。那些从根部出发无法触及到的对象被标记为不再使用，稍后进行回收。</p>
<h3 id="原型面试题"><a href="#原型面试题" class="headerlink" title="原型面试题"></a>原型面试题</h3><p>1、一个页面的脚本如下，请问会打印出什么内容？为什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'puppy'</span></span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.bark = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'woof!woof!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.prototype.bark()</span><br></pre></td></tr></table></figure>
<p>会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cannot read property <span class="string">'bark'</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>因为普通对象实例是没有<code>prototype</code>这个属性的，也就是说普通对象的<code>prototype</code>属性的值是<code>undefined</code>。</p>
<p><strong>解读：</strong><br>所有的函数都有<code>prototype</code>属性，因为所有的函数都可以被当作构造函数。函数的<code>prototype</code>内的<code>construtor</code>指向当前的构造函数，当构造函数构造实例时，首先创建一个空对象，然后按照函数中对<code>this</code>的操作把空对象操作一遍，最后再把构造函数中的<code>prototype</code>的值赋给这个对象。</p>
<p>实例也是有属性指向其构造函数的原型的：<code>__proto__</code>。<br>也就是说实例的<code>__proto__</code>指向构造函数的<code>prototype</code>属性</p>
<p>2、一个页面的脚本如下，请问会打印出什么内容？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ === <span class="built_in">Object</span>.prototype)</span><br></pre></td></tr></table></figure>

<p>答案：<br>打印出<code>true</code>，因为实例的<code>__proto__</code>属性指向其构造函数的<code>prototype</code>，而<code>Object</code>对象是普通对象的构造函数。</p>
<p><strong>解读：</strong><br>前面说了只有<code>构造函数</code>有<code>prototype</code>属性，很明显<code>Object</code>是一个构造函数，所以<code>Object.prototype</code>指向所有<code>new Object()</code>构造的实例的原型；</p>
<p>而实例的<code>__proto__</code>这个私有属性，指向其构造函数的<code>prototype</code>；</p>
<p>当我们声明<code>const a = {}</code>时，其实是隐式调用了<code>const a = new Object()</code></p>
<p>综上，<code>a.__proto__</code>指向a的构造函数的<code>prototype</code>属性，也就是<code>Object</code>的<code>prototype</code>属性。</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="浅拷贝与深拷贝的区别"><a href="#浅拷贝与深拷贝的区别" class="headerlink" title="浅拷贝与深拷贝的区别"></a>浅拷贝与深拷贝的区别</h4><p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200427132854.png" alt=""></p>
<h4 id="深拷贝的方法"><a href="#深拷贝的方法" class="headerlink" title="深拷贝的方法"></a>深拷贝的方法</h4><p>1.JSON转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> targetObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(copyObj))</span><br><span class="line"><span class="keyword">let</span> arr4 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr))</span><br></pre></td></tr></table></figure>

<p>2.普通递归函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>obj 要拷贝的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// obj 是 null ，或者不是对象和数组，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化返回结果</span></span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) &#123;</span><br><span class="line">        result = []</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">// 保证 key 不是原型的属性</span></span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">// 递归调用！！！</span></span><br><span class="line">            result[key] = deepClone(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="headerlink" title="call, apply, bind 区别"></a>call, apply, bind 区别</h3><p>首先说下前两者的区别。<br><code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</p>
<p>bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。</p>
<p>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(a, <span class="string">'yck'</span>, <span class="string">'24'</span>)</span><br><span class="line">getValue.apply(a, [<span class="string">'yck'</span>, <span class="string">'24'</span>])</span><br></pre></td></tr></table></figure>
<h3 id="手写一个bind函数"><a href="#手写一个bind函数" class="headerlink" title="手写一个bind函数"></a>手写一个bind函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟 bind</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数拆解为数组</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 this（数组第一项）</span></span><br><span class="line">    <span class="keyword">const</span> t = args.shift()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fn1.bind(...) 中的 fn1</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(t, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'this is fn1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn2 = fn1.bind1(&#123;<span class="attr">x</span>: <span class="number">100</span>&#125;, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> res = fn2()</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>


<h3 id="手写一个ajax"><a href="#手写一个ajax" class="headerlink" title="手写一个ajax"></a>手写一个ajax</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>)</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">                    resolve(</span><br><span class="line">                        <span class="built_in">JSON</span>.parse(xhr.responseText)</span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.status === <span class="number">404</span> || xhr.status === <span class="number">500</span>) &#123;</span><br><span class="line">                    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'404 not found'</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(<span class="literal">null</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'/data/test.json'</span></span><br><span class="line">ajax(url)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure>

<h3 id="函数节流"><a href="#函数节流" class="headerlink" title="函数节流"></a>函数节流</h3><p><strong>函数节流指的是某个函数在一定时间间隔内（例如 3 秒）只执行一次</strong>，在这 3 秒内 无视后来产生的函数调用请求，也不会延长时间间隔。3 秒间隔结束后第一次遇到新的函数调用会触发执行，然后在这新的 3 秒内依旧无视后来产生的函数调用请求，以此类推。</p>
<p><strong>原理及实现</strong><br>函数节流非常适用于函数被频繁调用的场景，例如：<code>window.onresize()</code>事件、<code>mousemove</code>事件、<code>上传进度</code>等情况。</p>
<p>实现方案有以下两种</p>
<ul>
<li><p>第一种是用时间戳来判断是否已到执行时间，记录上次执行的时间戳，然后每次触发事件执行回调，回调中判断当前时间戳距离上次执行时间戳的间隔是否已经达到时间差（Xms） ，如果是则执行，并更新上次执行的时间戳，如此循环。</p>
</li>
<li><p>第二种方法是使用定时器，比如当 scroll 事件刚触发时，打印一个 hello world，然后设置个 1000ms 的定时器，此后每次触发 scroll 事件触发回调，如果已经存在定时器，则回调不执行方法，直到定时器触发，handler 被清除，然后重新设置定时器。</p>
</li>
</ul>
<p>这里我们采用第一种方案来实现，通过闭包保存一个 <code>previous</code> 变量，每次触发 <code>throttle</code> 函数时判断当前时间和 <code>previous</code> 的时间差，如果这段时间差小于等待时间，那就忽略本次事件触发。如果大于等待时间就把 <code>previous</code> 设置为当前时间并执行函数 <code>fn</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn 是需要执行的函数</span></span><br><span class="line"><span class="comment">// wait 是时间间隔</span></span><br><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">fn, wait = <span class="number">50</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 上一次执行 fn 的时间</span></span><br><span class="line">  <span class="keyword">let</span> previous = <span class="number">0</span></span><br><span class="line">  <span class="comment">// 将 throttle 处理结果当作函数返回</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前时间，转换成时间戳，单位毫秒</span></span><br><span class="line">    <span class="keyword">let</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    <span class="comment">// 将当前时间和上一次执行函数的时间进行对比</span></span><br><span class="line">    <span class="comment">// 大于等待时间就把 previous 设置为当前时间并执行函数 fn</span></span><br><span class="line">    <span class="keyword">if</span> (now - previous &gt; wait) &#123;</span><br><span class="line">      previous = now</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO</span></span><br><span class="line"><span class="comment">// 执行 throttle 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = throttle(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fn 函数执行了'</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 每 10 毫秒执行一次 betterFn 函数，但是只有时间差大于 1000 时才会执行 fn</span></span><br><span class="line">setInterval(betterFn, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>


<h3 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h3><p>防抖函数 debounce 指的是某个函数在某段时间内，无论触发了多少次回调，都只执行最后一次。假如我们设置了一个等待时间 3 秒的函数，在这 3 秒内如果遇到函数调用请求就重新计时 3 秒，直至新的 3 秒内没有函数调用请求，此时执行函数，不然就以此类推重新计时。</p>
<p><strong>原理及实现</strong><br>实现原理就是利用定时器，函数第一次执行时设定一个定时器，之后调用时发现已经设定过定时器就清空之前的定时器，并重新设定一个新的定时器，如果存在没有被清空的定时器，当定时器计时结束后触发函数执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fn 是需要防抖处理的函数</span></span><br><span class="line"><span class="comment">// wait 是时间间隔</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait = <span class="number">50</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 通过闭包缓存一个定时器 id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 将 debounce 处理结果当作函数返回</span></span><br><span class="line">    <span class="comment">// 触发事件回调时执行这个返回函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">      	<span class="comment">// 如果已经设定过定时器就清空上一次的定时器</span></span><br><span class="line">        <span class="keyword">if</span> (timer) clearTimeout(timer)</span><br><span class="line">      </span><br><span class="line">      	<span class="comment">// 开始设定一个新的定时器，定时器结束后执行传入的函数 fn</span></span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">        &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEMO</span></span><br><span class="line"><span class="comment">// 执行 debounce 函数返回新函数</span></span><br><span class="line"><span class="keyword">const</span> betterFn = debounce(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'fn 防抖执行了'</span>), <span class="number">1000</span>)</span><br><span class="line"><span class="comment">// 停止滑动 1 秒后执行函数 () =&gt; console.log('fn 防抖执行了')</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, betterFn)</span><br></pre></td></tr></table></figure>


<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>DOM事件流三个阶段</p>
<ul>
<li>捕获阶段:事件从window对象自上而下向目标节点传播的阶段</li>
<li>目标阶段:真正的目标节点正在处理事件的阶段</li>
<li>冒泡阶段:事件从目标节点自下而上向window对象传播的阶段<br>img(<a href="https://pic1.zhimg.com/v2-4de189d2a42b1e8c74b379e067b67578_r.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/v2-4de189d2a42b1e8c74b379e067b67578_r.jpg</a>)</li>
</ul>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>Events 可以使用 Event 构造函数创建如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'build'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for the event.</span></span><br><span class="line">elem.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; ... &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatch the event.</span></span><br><span class="line">elem.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<p>要向事件对象添加更多数据，可以使用 <code>CustomEvent</code>，<code>detail</code> 属性可用于传递自定义数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'build'</span>, &#123; <span class="string">'detail'</span>: elem.dataset.time &#125;);</span><br><span class="line"></span><br><span class="line">elem.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; </span><br><span class="line">     log(<span class="string">'The time is: '</span> + e.detail);</span><br><span class="line"> &#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>

<h3 id="new操作中发生了什么？"><a href="#new操作中发生了什么？" class="headerlink" title="new操作中发生了什么？"></a>new操作中发生了什么？</h3><p>在《JavaScript模式》这本书中，new的过程说的比较直白，当我们new一个构造器，主要有三步：</p>
<ul>
<li>创建一个空对象，将它的引用赋给 this，继承函数的原型。</li>
<li>通过 this 将属性和方法添加至这个对象</li>
<li>最后返回 this 指向的新对象，也就是实例（如果没有手动返回其他的对象）<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5构造函数</span></span><br><span class="line"><span class="keyword">let</span> Parent = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建一个新对象，赋予this，这一步是隐性的，</span></span><br><span class="line">    <span class="comment">// let this = &#123;&#125;;</span></span><br><span class="line">    <span class="comment">//2.给this指向的对象赋予构造属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="comment">//3.如果没有手动返回对象，则默认返回this指向的这个对象，也是隐性的</span></span><br><span class="line">    <span class="comment">// return this;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Parent();</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="JS数组去重"><a href="#JS数组去重" class="headerlink" title="JS数组去重"></a>JS数组去重</h3><p>一、简单的去重方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最简单数组去重法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 新建一新数组，遍历传入数组，值不在新数组就push进该新数组中</span></span><br><span class="line"><span class="comment">* IE8以下不支持数组的indexOf方法</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> temp = []; <span class="comment">//一个新的临时数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp.indexOf(array[i]) == <span class="number">-1</span>)&#123;</span><br><span class="line">            temp.push(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aa = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">console</span>.log(uniq(aa));</span><br></pre></td></tr></table></figure>

<p>二、es6+set<br>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(unique(array)); <span class="comment">// [1, 2, "1"]</span></span><br></pre></td></tr></table></figure>

<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="使用CSS变量"><a href="#使用CSS变量" class="headerlink" title="使用CSS变量"></a>使用CSS变量</h3><p><strong>变量的声明</strong><br>声明变量的时候，变量名前面要加两根连词线<code>（--）</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">  <span class="attribute">--main-color</span>: <span class="number">#4d4e53</span>;</span><br><span class="line">  <span class="attribute">--main-bg</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="attribute">--logo-border-color</span>: rebeccapurple;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">--header-height</span>: <span class="number">68px</span>;</span><br><span class="line">  <span class="attribute">--content-padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">--base-line-height</span>: <span class="number">1.428571429</span>;</span><br><span class="line">  <span class="attribute">--transition-duration</span>: .<span class="number">35s</span>;</span><br><span class="line">  <span class="attribute">--external-link</span>: <span class="string">"external link"</span>;</span><br><span class="line">  <span class="attribute">--margin-top</span>: <span class="built_in">calc</span>(<span class="number">2vh</span> + <span class="number">20px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">--foo</span>: <span class="number">#7F583F</span>;</span><br><span class="line">  <span class="attribute">--bar</span>: <span class="number">#F7EFD2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读取变量</strong><br><code>var()</code>函数用于读取变量。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--main-color);</span><br><span class="line">  <span class="attribute">text-decoration-color</span>: <span class="built_in">var</span>(--bar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JavaScript 操作 CSS 变量</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置变量</span></span><br><span class="line"><span class="built_in">document</span>.body.style.setProperty(<span class="string">'--primary'</span>, <span class="string">'#7F583F'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取变量</span></span><br><span class="line"><span class="built_in">document</span>.body.style.getPropertyValue(<span class="string">'--primary'</span>).trim();</span><br><span class="line"><span class="comment">// '#7F583F'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除变量</span></span><br><span class="line"><span class="built_in">document</span>.body.style.removeProperty(<span class="string">'--primary'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="http协议的主要特点"><a href="#http协议的主要特点" class="headerlink" title="http协议的主要特点"></a>http协议的主要特点</h3><ul>
<li>简单快速</li>
<li>灵活</li>
<li>无连接<ul>
<li>连接一次就会断开</li>
</ul>
</li>
<li>无状态<ul>
<li>不会记录上一次的连接状态</li>
</ul>
</li>
</ul>
<h3 id="http报文的组成部分"><a href="#http报文的组成部分" class="headerlink" title="http报文的组成部分"></a>http报文的组成部分</h3><p><strong>请求报文</strong></p>
<ul>
<li>请求行（http方法，http协议，http版本）</li>
<li>请求头（key，value值）</li>
<li>空行</li>
<li>请求体</li>
</ul>
<p><strong>响应报文</strong></p>
<ul>
<li>状态行</li>
<li>响应头</li>
<li>空行</li>
<li>响应体</li>
</ul>
<h4 id="get与post的区别"><a href="#get与post的区别" class="headerlink" title="get与post的区别"></a>get与post的区别</h4><ul>
<li>get通过url传递参数，post通过请求体传递</li>
<li>get请求在url传输的参数有限制，post没有限制</li>
<li>get请求会被浏览器主动缓存，post不可以，除非手动设置</li>
<li>get只能进行url编码，post支持多种编码方式</li>
</ul>
<h4 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h4><ul>
<li>1xx 指示信息-表示请求已被接收，继续处理</li>
<li>2xx 成功，表示请求已被成功接收</li>
<li>3xx 重定向 - </li>
<li>4xx 客户端错误 - 请求有语法错误或者请求无法实现</li>
<li>5xx 服务端错误</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="前端常用优化"><a href="#前端常用优化" class="headerlink" title="前端常用优化"></a>前端常用优化</h3><ul>
<li>资源压缩</li>
<li>资源请求合并</li>
<li>async异步加载script脚本</li>
<li>配置浏览器缓存，主要指强缓存和协商缓存</li>
<li>按需加载</li>
<li>骨架屏</li>
<li>cdn加速</li>
</ul>
<h3 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</span><br></pre></td></tr></table></figure>

<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。</p>
<p>通常浏览器缓存策略分为两种：强缓存和协商缓存。</p>
<h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>实现强缓存可以通过两种响应头实现：<code>Expires</code> 和 <code>Cache-Control</code> 。强缓存表示在缓存期间不需要请求，<code>state code</code> 为 200</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Oct <span class="number">2018</span> <span class="number">08</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure>
<p><code>Expires</code> 是 <code>HTTP / 1.0</code> 的产物，表示资源会在 <code>Wed, 22 Oct 2018 08:41:00 GMT</code> 后过期，需要再次请求。并且 <code>Expires</code> 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cache-control: max-age=<span class="number">30</span></span><br></pre></td></tr></table></figure>
<p><code>Cache-Control</code> 出现于 <code>HTTP / 1.1</code>，优先级高于 <code>Expires</code> 。该属性表示资源会在 30 秒后过期，需要再次请求。</p>
<h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304。</p>
<p>协商缓存需要客户端和服务端共同实现，和强缓存一样，也有两种实现方式。</p>
<p><strong>Last-Modified 和 If-Modified-Since</strong></p>
<p>Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p>
<p>但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP / 1.1 出现了 ETag 。</p>
<p><strong>ETag 和 If-None-Match</strong><br>ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。</p>
<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><h3 id="谈谈vue的生命周期"><a href="#谈谈vue的生命周期" class="headerlink" title="谈谈vue的生命周期"></a>谈谈vue的生命周期</h3><p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200429151919.png" alt=""></p>
<h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p><strong>数据驱动视图</strong></p>
<p>MVVM 是Model-View-ViewModel 的缩写，它是一种基于前端开发的架构模式，其核心是提供对View 和 ViewModel 的双向数据绑定，这使得ViewModel 的状态改变可以自动传递给 View，即所谓的数据双向绑定。ViewModel负责连接 View 和 Model，保证视图和数据的一致性</p>
<h3 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h3><p><strong>1、Object.defineProperty</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">'zhangsan'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(data,<span class="string">'name'</span>,&#123;</span><br><span class="line">  <span class="keyword">get</span>:function()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get'</span>)</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>:function(newVal)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'set'</span>)</span><br><span class="line">    name = newVal</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">consle.log(data.name) <span class="comment">//get</span></span><br><span class="line">data.name = <span class="string">'xianxian'</span> <span class="comment">//set</span></span><br></pre></td></tr></table></figure>

<p>当你把一个普通的 JavaScript 对象传入 Vue 实例作为 data 选项，Vue 将遍历此对象所有的 property，并使用 <code>Object.defineProperty</code> 把这些 property 全部转为 <code>getter/setter</code>。</p>
<p>这些 getter/setter ，它们让 Vue 能够追踪依赖，在 property 被访问和修改时通知变更。</p>
<h3 id="自定义组件的-v-model"><a href="#自定义组件的-v-model" class="headerlink" title="自定义组件的 v-model"></a>自定义组件的 v-model</h3><p>index.vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义 v-model</span></span><br><span class="line">&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;CustomVModel v-model="name"/</span>&gt;</span><br></pre></td></tr></table></figure>

<p>CustomVModel.vue</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;!-- 例如：vue 颜色选择 --&gt;</span><br><span class="line">    &lt;input type=<span class="string">"text"</span></span><br><span class="line">        :value=<span class="string">"text"</span></span><br><span class="line">        @input=<span class="string">"$emit('change', $event.target.value)"</span></span><br><span class="line">    &gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">        <span class="number">1.</span> 上面的 input 使用了 :value 而不是 v-model</span><br><span class="line">        <span class="number">2.</span> 上面的 change 和 model.event 要对应起来</span><br><span class="line">        <span class="number">3.</span> text1 属性对应起来</span><br><span class="line">    --&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">    model: &#123;</span></span><br><span class="line"><span class="regexp">        prop: 'text', /</span><span class="regexp">/ 对应 props text1</span></span><br><span class="line"><span class="regexp">        event: 'change'</span></span><br><span class="line"><span class="regexp">    &#125;,</span></span><br><span class="line"><span class="regexp">    props: &#123;</span></span><br><span class="line"><span class="regexp">        text1: String,</span></span><br><span class="line"><span class="regexp">        default() &#123;</span></span><br><span class="line"><span class="regexp">            return ''</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="v-model的原理"><a href="#v-model的原理" class="headerlink" title="v-model的原理"></a>v-model的原理</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">"something"</span>&gt;</span><br><span class="line"></span><br><span class="line">相当于</span><br><span class="line"></span><br><span class="line">&lt;input  v-bind:value=<span class="string">"something"</span> v-on:input=<span class="string">"something = $event.target.value"</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="$nextTick"></a>$nextTick</h3><p>vue是异步进行渲染,当data改变之后，DOM不会立即渲染<br><code>$nextTick</code>会在DOM渲染完成之后被触发，以获取最新的DOM节点</p>
<h3 id="为何v-for要使用key"><a href="#为何v-for要使用key" class="headerlink" title="为何v-for要使用key"></a>为何v-for要使用key</h3><ul>
<li>diff算法中通过tag和key来进行判断比对，两个节点是否相同来更新组件，相同就复用，不相同就删除旧的创建新的。</li>
<li>为了在数据变化时强制更新组件，以避免“原地复用”带来的副作用</li>
<li>减少渲染次数，提升渲染性能</li>
</ul>
<h3 id="为何组件中的data必须是一个函数"><a href="#为何组件中的data必须是一个函数" class="headerlink" title="为何组件中的data必须是一个函数"></a>为何组件中的data必须是一个函数</h3><p>Object是引用数据类型,如果不用function 返回,每个组件的data 都是内存的同一个地址,一个数据改变了其他也改变了;</p>
<p>javascipt只有函数构成作用域(注意理解作用域,只有函数的{}构成作用域,对象的{}以及 if(){}都不构成作用域)，data是一个函数时，每个组件实例都有自己的作用域，每个实例相互独立,不会相互影响</p>
<h3 id="computed有何特点"><a href="#computed有何特点" class="headerlink" title="computed有何特点"></a>computed有何特点</h3><ul>
<li>缓存，data不变不会重新计算</li>
<li>提高性能</li>
</ul>
<h3 id="如何将所有props传递给子组件"><a href="#如何将所有props传递给子组件" class="headerlink" title="如何将所有props传递给子组件"></a>如何将所有props传递给子组件</h3><p>使用<code>$props</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;User v-bind=<span class="string">"$props"</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Vuex中action与mutation有何区别"><a href="#Vuex中action与mutation有何区别" class="headerlink" title="Vuex中action与mutation有何区别"></a>Vuex中action与mutation有何区别</h3><ul>
<li>action中可以处理异步，mutation不可以处理异步</li>
<li>mutation做原子操作（一般只单一的操作）</li>
<li>action可以整合多个mutation</li>
</ul>
<h3 id="请用vnode描述一个dom结构"><a href="#请用vnode描述一个dom结构" class="headerlink" title="请用vnode描述一个dom结构"></a>请用vnode描述一个dom结构</h3><p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200429103705.png" alt=""></p>
<h3 id="vue性能优化"><a href="#vue性能优化" class="headerlink" title="vue性能优化"></a>vue性能优化</h3><h4 id="view层面"><a href="#view层面" class="headerlink" title="view层面"></a>view层面</h4><ul>
<li>合理使用v-if和v-show</li>
<li>合理使用 computed</li>
<li>避免v-for和v-if同时使用<ul>
<li>v-for优化级更高，每将v-for会重新计算</li>
</ul>
</li>
<li>自定义事件，dom事件及时销毁</li>
<li>合理使用keep-alive</li>
</ul>
<h2 id="react和vue的区别"><a href="#react和vue的区别" class="headerlink" title="react和vue的区别"></a>react和vue的区别</h2><ul>
<li>都支持组件化</li>
<li>都是数据驱动视图</li>
<li>都使用vdom操作dom</li>
<li>react使用jsx拥抱js，vue使用模板拥抱html</li>
<li>react是函数式编程，vue是声明式编程</li>
</ul>
<h2 id="完整的项目流程"><a href="#完整的项目流程" class="headerlink" title="完整的项目流程"></a>完整的项目流程</h2><p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200429144558.png" alt=""></p>
]]></content>
      <tags>
        <tag>知识点</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>对与我得力的一些生产力工具</title>
    <url>/2020/04/29/%E5%AF%B9%E4%B8%8E%E6%88%91%E5%BE%97%E5%8A%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E7%94%9F%E4%BA%A7%E5%8A%9B%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h2><p>代码编辑器很多，有些是免费的，有些是付费的。其中最喜欢的代码编辑器是 Visual Studio Code。它是免费的，并具有强大的功能，我陆续抛弃了Atom、Sublime Text以及也很强大的WebStorm。</p>
<h2 id="HBuilderX"><a href="#HBuilderX" class="headerlink" title="HBuilderX"></a>HBuilderX</h2><p>HBuilderX代码编辑器是DCloud开发的，周边很多生态相关产品，平时主要用他来做uniapp开发以及和vscode配合使用</p>
<h2 id="uTools快速启动软件"><a href="#uTools快速启动软件" class="headerlink" title="uTools快速启动软件"></a>uTools快速启动软件</h2><p>uTools 是一款极简、插件化、跨平台、现代化的桌面增强效率软件，它为用户提供了一个可以随时呼出的“看似简单”的输入框 (搜索框)，但这个输入框却蕴含了近乎“无限”的能力。</p>
<h2 id="cmder"><a href="#cmder" class="headerlink" title="cmder"></a>cmder</h2><p>Cmder是Windows下非常好用的终端模拟器， 常用于替换windows自带的终端。它可以在不同的标签页中同时连接不同的底层Shell</p>
<h2 id="GifCam"><a href="#GifCam" class="headerlink" title="GifCam"></a>GifCam</h2><p>GifCam 是款集录制与剪辑为一体的屏幕GIF 动画制作工具，录制后的动画可以逐帧编辑</p>
<h2 id="CamtasiaStudio（录屏工具）"><a href="#CamtasiaStudio（录屏工具）" class="headerlink" title="CamtasiaStudio（录屏工具）"></a>CamtasiaStudio（录屏工具）</h2><p>是一款功能强大的屏幕动作录制工具,能在任何颜色模式下轻松地记录屏幕动作(屏幕/摄像头),包括影像、音效、鼠标移动轨迹、解说声音等</p>
<h2 id="Photoshop"><a href="#Photoshop" class="headerlink" title="Photoshop"></a>Photoshop</h2><p>图像处理软件</p>
<h2 id="XMind"><a href="#XMind" class="headerlink" title="XMind"></a>XMind</h2><p>思维导图软件，为激发灵感和创意而生</p>
<h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><p>一款接口测试工具</p>
<h2 id="Xshell"><a href="#Xshell" class="headerlink" title="Xshell"></a>Xshell</h2><p>一款高效专业的实用型免费SSH客户端</p>
<h2 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h2><p>一款比较优秀的图床工具</p>
<h2 id="网易有道词典"><a href="#网易有道词典" class="headerlink" title="网易有道词典"></a>网易有道词典</h2><p>全能免费语言翻译软件</p>
]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>小白要掌握的常用Git命令清单</title>
    <url>/2020/03/20/%E5%B0%8F%E7%99%BD%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</url>
    <content><![CDATA[<p>记录一下工作中常用到的git命令，只是简单的笔记</p>
<p>几个专用名词的译名如下。</p>
<ul>
<li>Workspace：工作区</li>
<li>Index / Stage：暂存区</li>
<li>Repository：仓库区（或本地仓库）</li>
<li>Remote：远程仓库</li>
</ul>
<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在当前目录新建一个Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init [project-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载一个项目和它的整个代码历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> [url]</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示当前的Git配置</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --list</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑Git配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config -e [--global]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置提交代码时的用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.name <span class="string">"[name]"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config [--global] user.email <span class="string">"[email address]"</span></span></span><br></pre></td></tr></table></figure>

<h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add [dir]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加当前目录的所有文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -p</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm [file1] [file2] ...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv [file-original] [file-renamed]</span></span><br></pre></td></tr></table></figure>

<h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit [file1] [file2] ... -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交时显示所有diff信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -v</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m [message]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend [file1] [file2] ...</span></span><br></pre></td></tr></table></figure>

<h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，但依然停留在当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch [branch] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --track [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定分支，并更新工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到上一个分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge [branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择一个commit，合并进当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d [branch-name]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete [branch-name]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -dr [remote/branch]</span></span><br></pre></td></tr></table></figure>

<h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在当前commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个tag在指定commit</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag [tag] [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除本地tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/[tagName]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看tag信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交指定tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] [tag]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交所有tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push [remote] --tags</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，指向某个tag</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b [branch] [tag]</span></span><br></pre></td></tr></table></figure>

<h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示有变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的版本历史</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜索提交历史，根据关键词</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -S [keyword]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个commit之后的所有变动，其<span class="string">"提交说明"</span>必须符合搜索条件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> [tag] HEAD --grep feature</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --follow [file]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git whatchanged [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件相关的每一次diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示过去5次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -5 --pretty --oneline</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git shortlog -sn</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git blame [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和工作区的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示暂存区和上一个commit的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示两次提交之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [first-branch]...[second-branch]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示今天你写了多少行代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --shortstat <span class="string">"@&#123;0 day ago&#125;"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交的元数据和内容变化</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交发生变化的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show --name-only [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某次提交时，某个文件的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show [commit]:[filename]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示当前分支的最近几次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure>

<h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 下载远程仓库的所有变动</span><br><span class="line">$ git fetch [remote]</span><br><span class="line"></span><br><span class="line"># 显示所有远程仓库</span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br><span class="line"># 显示某个远程仓库的信息</span><br><span class="line">$ git remote show [remote]</span><br><span class="line"></span><br><span class="line"># 增加一个新的远程仓库，并命名</span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"></span><br><span class="line"># 取回远程仓库的变化，并与本地分支合并</span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 上传本地指定分支到远程仓库</span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line"># 强行推送当前分支到远程仓库，即使有冲突</span><br><span class="line">$ git push [remote] --force</span><br><span class="line"></span><br><span class="line"># 推送所有分支到远程仓库</span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的指定文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout [commit] [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存区的所有文件到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [file]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --keep [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git revert [commit]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>帮5淘Chrome购物助手</title>
    <url>/2016/03/23/%E5%B8%AE5%E6%B7%98Chrome%E8%B4%AD%E7%89%A9%E5%8A%A9%E6%89%8B/</url>
    <content><![CDATA[<p>现在人们越来越喜欢在网上购买商品了，而为了满足大量的购物需求，网上的商品也变得非常多，用户很难区分哪些是性价比高的商品，哪些是滥竽充数的商品，如果用户把每一家电商网站都逛一个遍的话，虽然可以货比三家，但是习惯与现代快节奏生活的小伙伴时间上也不会允许。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200423140648.png" alt=""></p>
<a id="more"></a>

<p>今天给大家推荐一款可以对比各种电商网站商品的chrome插件：帮5淘购物助手。这款购物助手插件是和惠惠购物助手功能类似的chrome插件，其是帮5买网旗下的一款Chrome购物助手插件，不仅可以准确地对比出各大电商中相应商品的价格，还可以绘制出一些价格曲线来帮助用户在适当的时机购物该商品。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200423140735.png" alt=""></p>
<p>用户在chrome浏览器中安装了帮5淘购物助手插件以后，可以在任何一家电商网站选购自己喜爱的商品时，启动帮5淘插件来查看其他电商网站中同种商品的价格，进而帮助用户选择性价比最高的商品。用户只需要在购物页面中，选择帮5淘购物助手的“全网比价”功能，就可以立即知道其他电商网站中该商品的实时价格。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200423140759.png" alt=""></p>
<p>用户如果在购物的时候来回于多个电商网站中查看相同商品的价格是非常费力且废时的，在启动帮5淘插件以后，用户需要购买的商品就会以标签的形式显示出多个电商网站的实时价格，用户甚至不用去搜索任何的商品信息，就可以立即使用帮5淘插件来显示出所有该类商品的价格。用户也可以点击帮5淘插件页面上方的电商网站的标签来快速地查看其他网站中该商品的价格，最终确定一款性价比最高的商品。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200423140843.png" alt=""></p>
<p>用户也可以直接启动帮5淘插件来搜索自己喜欢的商品，搜索结果同样会呈现出多个电商网站的价格。帮5淘购物助手支持帮5买、淘宝、京东、亚马逊、当当、苏宁等网站的产品，用户再也不用来回“奔波”与多个电商网站了。</p>
<p>在帮5淘购物助手插件中的购物功能里，其还支持选购物品的价格曲线图，用户可以随时查看到该商品的价格走势，对于像双11等节假日商品价格大降价的情况下，如果用户不了解价格曲线就很容易被商家愚弄（快到节日的时候先提高价钱，到节日的时候再大幅度降价），有了帮5淘购物助手的价格曲线，用户不仅不用担心买到虚假降价的商品，还可以选择在最恰当的时间买到性价比最高的商品。</p>
]]></content>
      <categories>
        <category>案例</category>
      </categories>
      <tags>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>日常提高工作效率的Node.js自动化脚本</title>
    <url>/2020/04/03/%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E7%9A%84Node-js%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>真正的大牛都是习惯于使用脚本来实现自动化操作。随着 Node.js 的出现，前端开发工程师也可以通过 Node.js 来编写一些日常的工作脚本，从而减少手工操作，提高工作效率，从而节省出更多的时间花在核心的技术学习上。也使得我们的工作时刻保持新鲜。在这我会和大家分享我日常工作中的 Node.js 脚本。</p>
<ul>
<li>自动备份</li>
<li>自动执行命令</li>
<li>自动修改文件内容</li>
<li>文件的压缩与解压</li>
<li>服务器文件上传下载</li>
<li>邮件发送</li>
<li>处理 Excel</li>
</ul>
<a id="more"></a>

<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>使用 Node.js 搭建环境超级简单。只需要下载 Node.js 即可。自己电脑再下载一个好用的编辑器即可。这里推荐使用 VS Cod` 编辑器。无需 Java 那样配置环境、安装 JDK，还有各种工作区等，因为我只是想写个脚本而已。</p>
<p>安装好 Node.js 之后，新建一个文件夹 node-script 来存放所有的脚本，在命令提示符下进入该目录，执行以下命令快速生成 package.json：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>下面开始编写 Node.js 脚本。</p>
<h2 id="代码备份脚本"><a href="#代码备份脚本" class="headerlink" title="代码备份脚本"></a>代码备份脚本</h2><p>在 node-script 文件夹下新建文件 bak.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">### node-script项目结构：</span><br><span class="line">─node-script</span><br><span class="line">  └─node_modules</span><br><span class="line">  └─bak.js</span><br><span class="line">  └─package.json</span><br></pre></td></tr></table></figure>
<p>代码备份无非就是将文件夹自动存放于电脑某个文件夹下，代码备份一般来说可以有两种：</p>
<ul>
<li>需要备份时手动执行一次，一般用于代码需要大改前保留一份原有数据</li>
<li>每天定时备份一次，例如一些重要的数据</li>
</ul>
<p>代码备份需要使用 Node.js 的 fs 模块来实现。但是我们使用 fs 模块来写代码量会很大，而且一点都不简洁。很多的开源库和 CLI 工具都使用了第三方模块 <a href="https://www.npmjs.com/package/shelljs" target="_blank" rel="noopener">ShellJS</a>。</p>
<p>ShellJS 简单来说就是，可以执行它提供的方法来实现文件增删改查、复制、执行系统命令等操作。官网示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shell = <span class="built_in">require</span>(<span class="string">'shelljs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!shell.which(<span class="string">'git'</span>)) &#123;</span><br><span class="line">  shell.echo(<span class="string">'Sorry, this script requires git'</span>);</span><br><span class="line">  shell.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Copy files to release dir</span></span><br><span class="line">shell.rm(<span class="string">'-rf'</span>, <span class="string">'out/Release'</span>);</span><br><span class="line">shell.cp(<span class="string">'-R'</span>, <span class="string">'stuff/'</span>, <span class="string">'out/Release'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Replace macros in each .js file</span></span><br><span class="line">shell.cd(<span class="string">'lib'</span>);</span><br><span class="line">shell.ls(<span class="string">'*.js'</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">  shell.sed(<span class="string">'-i'</span>, <span class="string">'BUILD_VERSION'</span>, <span class="string">'v0.1.2'</span>, file);</span><br><span class="line">  shell.sed(<span class="string">'-i'</span>, /^.*REMOVE_THIS_LINE.*$/, <span class="string">''</span>, file);</span><br><span class="line">  shell.sed(<span class="string">'-i'</span>, /.*REPLACE_LINE_WITH_MACRO.*\n/, shell.cat(<span class="string">'macro.js'</span>), file);</span><br><span class="line">&#125;);</span><br><span class="line">shell.cd(<span class="string">'..'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run external tool synchronously</span></span><br><span class="line"><span class="keyword">if</span> (shell.exec(<span class="string">'git commit -am "Auto-commit"'</span>).code !== <span class="number">0</span>) &#123;</span><br><span class="line">  shell.echo(<span class="string">'Error: Git commit failed'</span>);</span><br><span class="line">  shell.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 ShellJS 前需要安装它：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i shelljs -D</span><br></pre></td></tr></table></figure>

<p><strong>文件夹备份代码如下。</strong><br>bak.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shell = <span class="built_in">require</span>(<span class="string">"shelljs"</span>)</span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">"moment"</span>)</span><br><span class="line"><span class="keyword">const</span> current = moment().format(<span class="string">"YYYYMMDDhhmmss"</span>) <span class="comment">// 20191101101426格式</span></span><br><span class="line"><span class="keyword">const</span> folder = <span class="string">`src_<span class="subst">$&#123;current&#125;</span>`</span></span><br><span class="line"><span class="comment">// 先创建一个时间信息的文件夹，防止覆盖同一个文件夹</span></span><br><span class="line">shell.mkdir(<span class="string">'-p'</span>,<span class="string">"./bak/"</span>+folder)</span><br><span class="line"><span class="comment">// shelljs 复制文件或者文件夹方法。-rf表示强制和递归方式复制。</span></span><br><span class="line">shell.cp(<span class="string">"-rf"</span>,<span class="string">'./test'</span>,<span class="string">'./bak/'</span>+folder)</span><br></pre></td></tr></table></figure>
<p>上述代码主要使用了 ShellJS 提供的新建文件夹方法 mkdir 和复制方法 cp 来实现。还用到了 JavaScript 中一个著名的处理时间模块 moment 来实现。</p>
<p>每次执行上述代码都需要使用命令 node bak.js 来执行这个脚本。当然我们也可以使用 npm script 方式来执行。只需要在 package.json 中加入自定义的 script 字段：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">"script"</span>:&#123;</span><br><span class="line">    <span class="string">"bak"</span>:<span class="string">"node ./bak.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行脚本时只需要：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm run bak</span><br></pre></td></tr></table></figure>
<p>下面我将这个脚本升级一下，可以让其每天 0 时自动执行一次，即定时任务，这里我使用了 Node 定时任务的一个第三方模块 node-schedule。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i node-schedule --save</span><br></pre></td></tr></table></figure>
<p>每天 0 时执行一次：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> schedule = <span class="built_in">require</span>(<span class="string">"node-schedule"</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> current = moment().format(<span class="string">"YYYYMMDDhhmmss"</span>) <span class="comment">// 20191101101426格式</span></span><br><span class="line">  <span class="keyword">const</span> folder = <span class="string">`src_<span class="subst">$&#123;current&#125;</span>`</span></span><br><span class="line">  shell.mkdir(<span class="string">'-p'</span>,<span class="string">"./bak/"</span>+folder)</span><br><span class="line">  shell.cp(<span class="string">"-rf"</span>,<span class="string">'./test'</span>,<span class="string">'./bak/'</span>+folder)</span><br><span class="line">  shell.echo(<span class="string">"备份完成！"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 每天的0时执行回调函数</span></span><br><span class="line">schedule.scheduleJob(<span class="string">'00 00 00 * * *'</span>,()=&gt;&#123;</span><br><span class="line">  copy()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>schedule.scheduleJob() 函数第一个参数为通配符表示时间，一般有六个 * 号。从左到右边依次为秒、分、时、日期、月份、星期。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">*  *  *  *  *  *</span><br><span class="line">┬ ┬ ┬ ┬ ┬ ┬</span><br><span class="line">│ │ │ │ │ |</span><br><span class="line">│ │ │ │ │ └ day <span class="keyword">of</span> week (<span class="number">0</span> - <span class="number">7</span>) (<span class="number">0</span> or <span class="number">7</span> is Sun)</span><br><span class="line">│ │ │ │ └───── month (<span class="number">1</span> - <span class="number">12</span>)</span><br><span class="line">│ │ │ └────────── day <span class="keyword">of</span> month (<span class="number">1</span> - <span class="number">31</span>)</span><br><span class="line">│ │ └─────────────── hour (<span class="number">0</span> - <span class="number">23</span>)</span><br><span class="line">│ └──────────────────── minute (<span class="number">0</span> - <span class="number">59</span>)</span><br><span class="line">└───────────────────────── second (<span class="number">0</span> - <span class="number">59</span>, OPTIONAL)</span><br><span class="line">每分钟的第 <span class="number">01</span> 秒触发： <span class="string">'01 * * * * *'</span></span><br><span class="line">每小时的 <span class="number">1</span> 分 <span class="number">01</span> 秒触发 ：<span class="string">'01 1 * * * *'</span></span><br><span class="line">每天的凌晨 <span class="number">1</span>点<span class="number">1</span>分<span class="number">30</span>秒触发 ：<span class="string">'30 1 1 * * *'</span></span><br><span class="line">每月的 <span class="number">1</span> 日<span class="number">1</span>点<span class="number">1</span>分<span class="number">30</span>秒触发 ：<span class="string">'30 1 1 1 * *'</span></span><br><span class="line"><span class="number">2019</span> 年的 <span class="number">1</span> 月 <span class="number">1</span> 日<span class="number">1</span> 点 <span class="number">1</span> 分<span class="number">30</span>秒触发 ：<span class="string">'30 1 1 1 2019 *'</span></span><br><span class="line">每周<span class="number">1</span>的<span class="number">1</span>点<span class="number">1</span>分<span class="number">30</span>秒触发 ：<span class="string">'30 1 1 * * 1'</span></span><br></pre></td></tr></table></figure>

<h2 id="自动执行命令"><a href="#自动执行命令" class="headerlink" title="自动执行命令"></a>自动执行命令</h2><p>使用 ShellJS 的 exec 方法可以执行程序命令，例如:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shell = <span class="built_in">require</span>(<span class="string">"shelljs"</span>)</span><br><span class="line">shell.exec(<span class="string">"cls"</span>) <span class="comment">// 执行windows下的清空显示命令</span></span><br><span class="line">shell.exec(<span class="string">"npm run dev"</span>) <span class="comment">// 执行npm script命令</span></span><br></pre></td></tr></table></figure>
<p>一般来说在执行命令时可能一个命令执行完毕后可能会退出 Node 程序，例如下面情形：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shell = <span class="built_in">require</span>(<span class="string">"shelljs"</span>)</span><br><span class="line">shell.exec(<span class="string">""</span>npm run build)</span><br><span class="line">shell.cp(<span class="string">"-rf"</span>,<span class="string">"./dist"</span>,<span class="string">"../resource"</span>)</span><br></pre></td></tr></table></figure>
<p>上面的 npm run build 被执行完毕后可能会退出程序，使得 cp 命令不被执行。其实 ShellJS 提供的 exec() 方法还可以接收参数和回调函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shell = <span class="built_in">require</span>(<span class="string">"shelljs"</span>)</span><br><span class="line"></span><br><span class="line">shell.exec(<span class="string">'node --version'</span>, &#123;</span><br><span class="line">  silent:<span class="literal">true</span>, <span class="comment">// 执行过程中命令提示符不会显示过程信息</span></span><br><span class="line">  <span class="keyword">async</span>:<span class="literal">false</span>  <span class="comment">// 是否异步执行</span></span><br><span class="line">&#125;,(code, stdout, stderr)=&gt;&#123;</span><br><span class="line"> <span class="comment">// 执行完毕后继续执行这个回调函数 code表示状态码，0成功，1失败 。stdout表示上一步输入</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>将下一步操作放在回调函数内就可以使得程序继续执行下去了。</p>
<h2 id="自动修改文件内容"><a href="#自动修改文件内容" class="headerlink" title="自动修改文件内容"></a>自动修改文件内容</h2><p>在进行复制代码包的过程中，总少不了各种文件参数的修改。例如程序包在复制到服务器上去之后需要修改里面的一个版本文件 version.js。每替换一次版本号需要自动加 1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">version = <span class="string">"v1.1.0"</span></span><br></pre></td></tr></table></figure>
<p>利用 ShellJS 的 sed 方法可以很方便地实现文件内容替换。</p>
<p><strong>sed([options,] search_regex, replacement, file [, file …])</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 替换文件内容，-i表示不创建备份，第二个参数为需要替换的内容，第三个参数为替换成的新内容，最后一个参数为文件路径</span></span><br><span class="line">shell.sed(<span class="string">"-i"</span>,<span class="string">"version"</span>,<span class="string">"aa"</span>,<span class="string">"./version.txt"</span>) <span class="comment">// 将version 替换成 aa</span></span><br><span class="line"><span class="comment">// 正则表达式方式,将version-替换成v-</span></span><br><span class="line">shell.sed(<span class="string">"-i"</span>,/version\s=<span class="regexp">/,"v =","./</span>version.txt<span class="string">")</span></span><br></pre></td></tr></table></figure>
<p>版本最后一位每次打包时自动加 1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> shell = <span class="built_in">require</span>(<span class="string">"shelljs"</span>)</span><br><span class="line"><span class="keyword">const</span> content = shell.cat(<span class="string">'./version.txt'</span>)</span><br><span class="line"><span class="keyword">const</span> rep = content.stdout.split(<span class="string">'.'</span>)</span><br><span class="line">rep[rep.length<span class="number">-1</span>] = <span class="built_in">Number</span>(rep[rep.length<span class="number">-1</span>])+<span class="number">1</span></span><br><span class="line">shell.sed(<span class="string">"-i"</span>,content,rep.join(<span class="string">'.'</span>),<span class="string">"./version.txt"</span>)</span><br></pre></td></tr></table></figure>
<p>如果需要实现复杂的字符串替换，可以使用正则表达式的方式。</p>
<h2 id="接收控制台输入"><a href="#接收控制台输入" class="headerlink" title="接收控制台输入"></a>接收控制台输入</h2><p>有时候执行脚本时需要和使用者进行交互和对话，用户输入 YES 或者 NO 来执行不同代码分支，例如上述的自动变更版本号的脚本，有时候并不想每次打包都更新版本（例如一个小小的改动而已），实现接收控制台输入可以使用 node 的 process 模块。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.stdout.write(<span class="string">"需要变更版本号吗(y/n)？"</span>);</span><br><span class="line">process.stdin.on(<span class="string">'data'</span>,(input)=&gt;&#123;</span><br><span class="line">  input = input.toString().trim();</span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">'Y'</span>, <span class="string">'y'</span>, <span class="string">'YES'</span>, <span class="string">'yes'</span>].indexOf(input) &gt; <span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="comment">// 选择了yes Y时执行这里</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> ([<span class="string">'N'</span>, <span class="string">'n'</span>, <span class="string">'NO'</span>, <span class="string">'no'</span>].indexOf(input) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">    process.exit(<span class="number">0</span>); <span class="comment">// 退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="文件的压缩与解压"><a href="#文件的压缩与解压" class="headerlink" title="文件的压缩与解压"></a>文件的压缩与解压</h2><p>很多时候程序包上传到服务器上去很少是文件夹的方式，而是先将其压缩成特定的格式，再上传到服务器，上传之后再执行解压操作。一般来说压缩格式主要有 ZIP 和 GZIP 两种格式。这里我目前使用的 Node 文件压缩与解压的库是<a href="https://github.com/node-modules/compressing" target="_blank" rel="noopener">compressing</a></p>
<p>使用 compressing 可以支持文件压缩、文件夹压缩，并且可以压缩成 ZIP、GZ 等多种格式。按照惯例，使用它需要手动安装一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i compressing --save</span><br></pre></td></tr></table></figure>

<p>压缩 dist 文件夹成 ZIP 格式例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">onst compressing = <span class="built_in">require</span>(<span class="string">"compressing"</span>)</span><br><span class="line">compressing.zip.compressDir(resolve(<span class="string">"dist/"</span>), resolve(zipName)).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"压缩成功！"</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"压缩失败"</span>);</span><br><span class="line">  <span class="built_in">console</span>.error(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>压缩文件官方例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> compressing = <span class="built_in">require</span>(<span class="string">'compressing'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// compress a file 压缩一个文件</span></span><br><span class="line">compressing.gzip.compressFile(<span class="string">'file/path/to/compress'</span>, <span class="string">'path/to/destination.gz'</span>)</span><br><span class="line">.then(compressDone)</span><br><span class="line">.catch(handleError);</span><br><span class="line"></span><br><span class="line"><span class="comment">// compress a file buffer 二进制方式</span></span><br><span class="line">compressing.gzip.compressFile(buffer, <span class="string">'path/to/destination.gz'</span>)</span><br><span class="line">.then(compressDone)</span><br><span class="line">.catch(handleError);</span><br><span class="line"></span><br><span class="line"><span class="comment">// compress a stream 使用流的方式</span></span><br><span class="line">compressing.gzip.compressFile(stream, <span class="string">'path/to/destination.gz'</span>)</span><br><span class="line">.then(compressDone)</span><br><span class="line">.catch(handleError);</span><br></pre></td></tr></table></figure>

<h2 id="服务器文件上传下载"><a href="#服务器文件上传下载" class="headerlink" title="服务器文件上传下载"></a>服务器文件上传下载</h2><p>处理好文件后，在很多时候往往还需要上传到服务器上实现自动部署，而不需要再使用一些 SFTP 工具来手动操作。我目前在实际工作中使用的是第三方模块 node-ssh，先进行安装：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i node-ssh --save</span><br></pre></td></tr></table></figure>
<p>连接服务器执行服务器命令例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> node_ssh = <span class="built_in">require</span>(<span class="string">"node-ssh"</span>)</span><br><span class="line"><span class="keyword">const</span> ssh = <span class="keyword">new</span> node_ssh()</span><br><span class="line"></span><br><span class="line">ssh.connect(&#123;</span><br><span class="line">    host:<span class="string">'182.11.18.14'</span>,</span><br><span class="line">    username:<span class="string">'admin'</span>,</span><br><span class="line">    password:<span class="string">'admin'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"连接成功！"</span>)</span><br><span class="line">    <span class="comment">// 可以执行linux上的命令</span></span><br><span class="line">    ssh.execCommand(<span class="string">"node -v"</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.stdout)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 将本地文件上传到服务器文件中。如果没有bak.js则会新建。</span></span><br><span class="line">    ssh.putFile(<span class="string">'./bak.js'</span>,<span class="string">'/home/demo/bak.js'</span>).then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"上传成功！"</span>)</span><br><span class="line">    &#125;,(err)=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 多个文件上传方式 需要local和remote属性</span></span><br><span class="line">    ssh.putFiles([</span><br><span class="line">       &#123; <span class="attr">local</span>:<span class="string">'./bak.js'</span>,<span class="attr">remote</span>:<span class="string">'/home/dist/bak.js'</span>&#125;,</span><br><span class="line">       &#123; <span class="attr">local</span>:<span class="string">'./index.js'</span>,<span class="attr">remote</span>:<span class="string">'/home/dist/index.js'</span>&#125;</span><br><span class="line">    ]).then(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"上传完成啦！"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 文件夹上传</span></span><br><span class="line">    ssh.putDirectory(<span class="string">"./test"</span>,<span class="string">'/home/demo/test'</span>,&#123;</span><br><span class="line">      recursive: <span class="literal">true</span>, <span class="comment">// 递归方式</span></span><br><span class="line">      concurrency: <span class="number">10</span>,</span><br><span class="line">    &#125;).then(<span class="function">(<span class="params">status</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"文件夹上传成功！"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;).catch(<span class="function">(<span class="params">err</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"连接失败！"</span>,err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="邮件发送"><a href="#邮件发送" class="headerlink" title="邮件发送"></a>邮件发送</h2><p>使用脚本来自动发送一些简单而重复的邮件信息显得很方便。例如一些监控系统，出现异常时自动触发发送邮件的 API，邮件还可以给用户推送一些实用的信息等。我们先安装第三方模块</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install nodemailer --save</span><br></pre></td></tr></table></figure>

<p>发送邮件程序：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nodemailer =<span class="built_in">require</span>(<span class="string">'nodemailer'</span>)</span><br><span class="line"><span class="keyword">var</span> transporter = nodemailer.createTransport(&#123;</span><br><span class="line">    service:<span class="string">'163'</span>, <span class="comment">// 以163邮箱为例</span></span><br><span class="line">    auth: &#123;</span><br><span class="line">      user:<span class="string">'123456@163.com'</span>,</span><br><span class="line">      pass: <span class="string">'admin'</span> <span class="comment">// 163邮箱授权密码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> mailOptions = &#123;</span><br><span class="line">    <span class="keyword">from</span>:<span class="string">'123456@163.com'</span>, <span class="comment">// 发送邮件的邮箱</span></span><br><span class="line">    to: <span class="string">'123456@qq.com'</span>,   <span class="comment">// 给谁发送</span></span><br><span class="line">    subject: <span class="string">'每日程序员新闻'</span>, <span class="comment">// 右键主题</span></span><br><span class="line">    text:<span class="string">'测试数据'</span>  <span class="comment">// 右键内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMail</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    transporter.sendMail(mailOptions, <span class="function"><span class="keyword">function</span>(<span class="params">error, info</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'邮件发送成功！'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">sendMail()</span><br></pre></td></tr></table></figure>
<p>上面就是一个基本简单的邮件发送功能，我们还可以将其封装成一个模块。在需要时调用发送邮件接口即可。如果要发送带 HTML 格式的内容只需要在 mailOptions 对象中加入一个属性 html 即可。</p>
<p>当然也可以发送附件，只需要加入字段 attachments 即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mailOptions = &#123;</span><br><span class="line">    <span class="keyword">from</span>:<span class="string">'123456@163.com'</span>,</span><br><span class="line">    to: <span class="string">'123456@qq.com'</span>,</span><br><span class="line">    subject: <span class="string">'每日新闻'</span>,</span><br><span class="line">    text:<span class="string">'1.this words was sent by mch'</span>,</span><br><span class="line">    attachments:[</span><br><span class="line">      &#123;<span class="attr">filename</span>:<span class="string">'data.xlsx'</span>,<span class="attr">path</span>:<span class="string">'./data.xlsx'</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有两点要注意：</p>
<ul>
<li>attachemts 附件在 path 字段在条件允许下尽量使用英文名，不然可能会有难以意料错误；</li>
<li>进行邮件发送测试时最好不要随便和简单地填写一些无意义的文字，不然很多邮箱会检测出是垃圾邮件，导致发送失败！</li>
</ul>
<h2 id="处理-Excel"><a href="#处理-Excel" class="headerlink" title="处理 Excel"></a>处理 Excel</h2><p>在 JavaScript 领域也有许多好用且流行的处理 Excel 的包，例如在 GitHub 上有着上万 Star 的 <a href="https://sheetjs.com/" target="_blank" rel="noopener">sheetjs</a>，虽然还有许多类似于 node-excel 这样的库，但是很多还是依赖了 SheetJS。下面我来介绍 SheetJS 的用法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm i xlsx --save</span><br></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> XLSX = <span class="built_in">require</span>(<span class="string">"xlsx"</span>) <span class="comment">// 纯前端也可以使用，使用import语法也可以</span></span><br><span class="line"><span class="keyword">const</span> wb = XLSX.readFile(<span class="string">"./json.xlsx"</span>)</span><br><span class="line"><span class="keyword">const</span> sheets = wb.SheetNames <span class="comment">// sheet数组</span></span><br><span class="line"><span class="keyword">const</span> worksheet = wb.Sheets[sheets[<span class="number">0</span>]] <span class="comment">// 第一张工作表对象</span></span><br><span class="line"><span class="built_in">console</span>.log(worksheet)</span><br></pre></td></tr></table></figure>
<p>worksheet 返回一个 JSON 对象：<br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200403122034.png" alt=""></p>
<p>单元格对象含义：</p>
<table>
<thead>
<tr>
<th>-</th>
<th align="left">-</th>
</tr>
</thead>
<tbody><tr>
<td>属性</td>
<td align="left">描述</td>
</tr>
<tr>
<td>w</td>
<td align="left">内容</td>
</tr>
<tr>
<td>t</td>
<td align="left">类型: b Boolean, n Number, e error, s String, d Date</td>
</tr>
<tr>
<td>f</td>
<td align="left">单元格样式</td>
</tr>
<tr>
<td>F</td>
<td align="left">排序样式</td>
</tr>
<tr>
<td>r</td>
<td align="left">富媒体编码</td>
</tr>
<tr>
<td>h</td>
<td align="left">HTML 绘制富媒体</td>
</tr>
<tr>
<td>c</td>
<td align="left">单元格描述</td>
</tr>
<tr>
<td>z</td>
<td align="left">样式个数</td>
</tr>
<tr>
<td>l</td>
<td align="left">单元格链接</td>
</tr>
<tr>
<td>s</td>
<td align="left">单元格主题</td>
</tr>
</tbody></table>
<p>例如现在要修改 demo.xlsx A1 单元格的内容为“hello,world”：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> XLSX = <span class="built_in">require</span>(<span class="string">"xlsx"</span>)</span><br><span class="line"><span class="keyword">const</span> wb = XLSX.readFile(<span class="string">"./json.xlsx"</span>)</span><br><span class="line"><span class="keyword">const</span> sheets = wb.SheetNames <span class="comment">// sheet数组</span></span><br><span class="line"><span class="keyword">const</span> worksheet = wb.Sheets[sheets[<span class="number">0</span>]] <span class="comment">// 第一张工作表对象</span></span><br><span class="line"><span class="built_in">console</span>.log(worksheet)</span><br><span class="line">worksheet[<span class="string">'A1'</span>][<span class="string">'v'</span>] =<span class="string">"hello,world"</span></span><br><span class="line">XLSX.writeFile(wb,<span class="string">'./demo.xlsx'</span>)</span><br></pre></td></tr></table></figure>
<p>可以准备好一份 Excel 模版，每次操作就覆盖指定单元格的内容。这种方式很适合写工作周报。</p>
<p>也可以根据数据生成一份新的 Excel 文件（导出）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> XLSX = <span class="built_in">require</span>(<span class="string">"xlsx"</span>)</span><br><span class="line"><span class="keyword">const</span> arr=[</span><br><span class="line">    [<span class="string">"姓名"</span>,<span class="string">"年龄"</span>,<span class="string">'性别'</span>],</span><br><span class="line">    [<span class="string">"jack"</span>,<span class="string">"12"</span>,<span class="string">'男'</span>]</span><br><span class="line">    [<span class="string">"rose"</span>,<span class="string">"23"</span>,<span class="string">'女'</span>]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> wb = &#123;</span><br><span class="line">    SheetNames:[<span class="string">'hello'</span>],</span><br><span class="line">    Sheets:&#123;</span><br><span class="line">        <span class="string">'hello'</span>:XLSX.utils.aoa_to_sheet(arr)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">XLSX.writeFile(wb,<span class="string">'test4.xlsx'</span>)</span><br></pre></td></tr></table></figure>






]]></content>
      <categories>
        <category>nodejs</category>
        <category>案例</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>案例</tag>
        <tag>自动化</tag>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>小白要看的js事件委托指南</title>
    <url>/2017/03/10/%E5%B0%8F%E7%99%BD%E8%A6%81%E7%9C%8B%E7%9A%84js%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><p>那什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象，我仔细揣摩了一下，这个例子还真是恰当，我就不去想别的例子来解释了，借花献佛，我摘过来，大家认真领会一下事件委托到底是一个什么原理：</p>
<p>有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。</p>
<a id="more"></a>
<p>这里其实还有2层意思的：</p>
<p>第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的；</p>
<p>第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。</p>
<h2 id="为什么要用事件委托："><a href="#为什么要用事件委托：" class="headerlink" title="为什么要用事件委托："></a>为什么要用事件委托：</h2><p>一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？</p>
<p>在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；</p>
<p>每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。</p>
<h2 id="事件委托的原理："><a href="#事件委托的原理：" class="headerlink" title="事件委托的原理："></a>事件委托的原理：</h2><p>事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。</p>
<h2 id="事件委托怎么实现："><a href="#事件委托怎么实现：" class="headerlink" title="事件委托怎么实现："></a>事件委托怎么实现：</h2><p>终于到了本文的核心部分了，哈哈，在介绍事件委托的方法之前，我们先来看一段一般方法的例子：<br>子节点实现相同的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;ul1&quot;&gt;</span><br><span class="line">    &lt;li&gt;111&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<p>实现功能是点击li，弹出123：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload &#x3D; function()&#123;</span><br><span class="line">    var oUl &#x3D; document.getElementById(&quot;ul1&quot;);</span><br><span class="line">    var aLi &#x3D; oUl.getElementsByTagName(&#39;li&#39;);</span><br><span class="line">    for(var i&#x3D;0;i&lt;aLi.length;i++)&#123;</span><br><span class="line">        aLi[i].onclick &#x3D; function()&#123;</span><br><span class="line">            alert(123);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作，首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li；</p>
<p>那么我们用事件委托的方式做又会怎么样呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload &#x3D; function()&#123;</span><br><span class="line">    var oUl &#x3D; document.getElementById(&quot;ul1&quot;);</span><br><span class="line">   oUl.onclick &#x3D; function()&#123;</span><br><span class="line">        alert(123);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招：</p>
<p>Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload &#x3D; function()&#123;</span><br><span class="line">    　　var oUl &#x3D; document.getElementById(&quot;ul1&quot;);</span><br><span class="line">    　　oUl.onclick &#x3D; function(ev)&#123;</span><br><span class="line">    	　　　　var ev &#x3D; ev || window.event;</span><br><span class="line">   		　　　　var target &#x3D; ev.target || ev.srcElement;</span><br><span class="line">        　　　　if(target.nodeName.toLowerCase() &#x3D;&#x3D; &#39;li&#39;)&#123;</span><br><span class="line">        　 　　　　　　	alert(123);</span><br><span class="line">　　　　　　　  alert(target.innerHTML);</span><br><span class="line">		　　&#125;</span><br><span class="line">    　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！</p>
<p>上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;box&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;add&quot; value&#x3D;&quot;添加&quot; &#x2F;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;remove&quot; value&#x3D;&quot;删除&quot; &#x2F;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;move&quot; value&#x3D;&quot;移动&quot; &#x2F;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;select&quot; value&#x3D;&quot;选择&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload &#x3D; function()&#123;</span><br><span class="line">    var Add &#x3D; document.getElementById(&quot;add&quot;);</span><br><span class="line">    var Remove &#x3D; document.getElementById(&quot;remove&quot;);</span><br><span class="line">    var Move &#x3D; document.getElementById(&quot;move&quot;);</span><br><span class="line">    var Select &#x3D; document.getElementById(&quot;select&quot;);</span><br><span class="line">    </span><br><span class="line">    Add.onclick &#x3D; function()&#123;</span><br><span class="line">        alert(&#39;添加&#39;);</span><br><span class="line">    &#125;;</span><br><span class="line">    Remove.onclick &#x3D; function()&#123;</span><br><span class="line">        alert(&#39;删除&#39;);</span><br><span class="line">    &#125;;</span><br><span class="line">    Move.onclick &#x3D; function()&#123;</span><br><span class="line">        alert(&#39;移动&#39;);</span><br><span class="line">    &#125;;</span><br><span class="line">    Select.onclick &#x3D; function()&#123;</span><br><span class="line">        alert(&#39;选择&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面实现的效果我就不多说了，很简单，4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload &#x3D; function()&#123;</span><br><span class="line">    var oBox &#x3D; document.getElementById(&quot;box&quot;);</span><br><span class="line">    oBox.onclick &#x3D; function (ev) &#123;</span><br><span class="line">        var ev &#x3D; ev || window.event;</span><br><span class="line">        var target &#x3D; ev.target || ev.srcElement;</span><br><span class="line">        if(target.nodeName.toLocaleLowerCase() &#x3D;&#x3D; &#39;input&#39;)&#123;</span><br><span class="line">            switch(target.id)&#123;</span><br><span class="line">                case &#39;add&#39; :</span><br><span class="line">                    alert(&#39;添加&#39;);</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;remove&#39; :</span><br><span class="line">                    alert(&#39;删除&#39;);</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;move&#39; :</span><br><span class="line">                    alert(&#39;移动&#39;);</span><br><span class="line">                    break;</span><br><span class="line">                case &#39;select&#39; :</span><br><span class="line">                    alert(&#39;选择&#39;);</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的 </p>
<p>现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？</p>
<p>看一下正常的添加节点的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;button&quot; name&#x3D;&quot;&quot; id&#x3D;&quot;btn&quot; value&#x3D;&quot;添加&quot; &#x2F;&gt;</span><br><span class="line">&lt;ul id&#x3D;&quot;ul1&quot;&gt;</span><br><span class="line">    &lt;li&gt;111&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;222&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;333&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;444&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<p>现在是移入li，li变红，移出li，li变白，这么一个效果，然后点击按钮，可以向ul中添加一个li子节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload &#x3D; function()&#123;</span><br><span class="line">    var oBtn &#x3D; document.getElementById(&quot;btn&quot;);</span><br><span class="line">    var oUl &#x3D; document.getElementById(&quot;ul1&quot;);</span><br><span class="line">    var aLi &#x3D; oUl.getElementsByTagName(&#39;li&#39;);</span><br><span class="line">    var num &#x3D; 4;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;鼠标移入变红，移出变白</span><br><span class="line">    for(var i&#x3D;0; i&lt;aLi.length;i++)&#123;</span><br><span class="line">        aLi[i].onmouseover &#x3D; function()&#123;</span><br><span class="line">            this.style.background &#x3D; &#39;red&#39;;</span><br><span class="line">        &#125;;</span><br><span class="line">        aLi[i].onmouseout &#x3D; function()&#123;</span><br><span class="line">            this.style.background &#x3D; &#39;#fff&#39;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;添加新节点</span><br><span class="line">    oBtn.onclick &#x3D; function()&#123;</span><br><span class="line">        num++;</span><br><span class="line">        var oLi &#x3D; document.createElement(&#39;li&#39;);</span><br><span class="line">        oLi.innerHTML &#x3D; 111*num;</span><br><span class="line">        oUl.appendChild(oLi);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一般的做法，但是你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去，这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环用一个函数包起来，命名为mHover，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload &#x3D; function()&#123;</span><br><span class="line">    var oBtn &#x3D; document.getElementById(&quot;btn&quot;);</span><br><span class="line">    var oUl &#x3D; document.getElementById(&quot;ul1&quot;);</span><br><span class="line">    var aLi &#x3D; oUl.getElementsByTagName(&#39;li&#39;);</span><br><span class="line">    var num &#x3D; 4;</span><br><span class="line">    </span><br><span class="line">    function mHover () &#123;</span><br><span class="line">        &#x2F;&#x2F;鼠标移入变红，移出变白</span><br><span class="line">        for(var i&#x3D;0; i&lt;aLi.length;i++)&#123;</span><br><span class="line">            aLi[i].onmouseover &#x3D; function()&#123;</span><br><span class="line">                this.style.background &#x3D; &#39;red&#39;;</span><br><span class="line">            &#125;;</span><br><span class="line">            aLi[i].onmouseout &#x3D; function()&#123;</span><br><span class="line">                this.style.background &#x3D; &#39;#fff&#39;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mHover ();</span><br><span class="line">    &#x2F;&#x2F;添加新节点</span><br><span class="line">    oBtn.onclick &#x3D; function()&#123;</span><br><span class="line">        num++;</span><br><span class="line">        var oLi &#x3D; document.createElement(&#39;li&#39;);</span><br><span class="line">        oLi.innerHTML &#x3D; 111*num;</span><br><span class="line">        oUl.appendChild(oLi);</span><br><span class="line">        mHover ();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然功能实现了，看着还挺好，但实际上无疑是又增加了一个dom操作，在优化性能方面是不可取的，那么有事件委托的方式，能做到优化吗？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.onload &#x3D; function()&#123;</span><br><span class="line">    var oBtn &#x3D; document.getElementById(&quot;btn&quot;);</span><br><span class="line">    var oUl &#x3D; document.getElementById(&quot;ul1&quot;);</span><br><span class="line">    var aLi &#x3D; oUl.getElementsByTagName(&#39;li&#39;);</span><br><span class="line">    var num &#x3D; 4;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;事件委托，添加的子元素也有事件</span><br><span class="line">    oUl.onmouseover &#x3D; function(ev)&#123;</span><br><span class="line">        var ev &#x3D; ev || window.event;</span><br><span class="line">        var target &#x3D; ev.target || ev.srcElement;</span><br><span class="line">        if(target.nodeName.toLowerCase() &#x3D;&#x3D; &#39;li&#39;)&#123;</span><br><span class="line">            target.style.background &#x3D; &quot;red&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    oUl.onmouseout &#x3D; function(ev)&#123;</span><br><span class="line">        var ev &#x3D; ev || window.event;</span><br><span class="line">        var target &#x3D; ev.target || ev.srcElement;</span><br><span class="line">        if(target.nodeName.toLowerCase() &#x3D;&#x3D; &#39;li&#39;)&#123;</span><br><span class="line">            target.style.background &#x3D; &quot;#fff&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;添加新节点</span><br><span class="line">    oBtn.onclick &#x3D; function()&#123;</span><br><span class="line">        num++;</span><br><span class="line">        var oLi &#x3D; document.createElement(&#39;li&#39;);</span><br><span class="line">        oLi.innerHTML &#x3D; 111*num;</span><br><span class="line">        oUl.appendChild(oLi);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看，上面是用事件委托的方式，新添加的子元素是带有事件效果的，我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了，其他的都是在js里面的执行，这样可以大大的减少dom操作，这才是事件委托的精髓所在。</p>
<p>现在给一个场景 ul &gt; li &gt; div &gt; p，div占满li，p占满div，还是给ul绑定时间，需要判断点击的是不是li（假设li里面的结构是不固定的），那么e.target就可能是p，也有可能是div，这种情况你会怎么处理呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;ul id&#x3D;&quot;test&quot;&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;p&gt;11111111111&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">        &lt;span&gt;3333333333&lt;&#x2F;span&gt;</span><br><span class="line">    &lt;&#x2F;li&gt;</span><br><span class="line">    &lt;li&gt;4444444&lt;&#x2F;li&gt;</span><br><span class="line">&lt;&#x2F;ul&gt;</span><br></pre></td></tr></table></figure>
<p>如上列表，有4个li，里面的内容各不相同，点击li，event对象肯定是当前点击的对象，怎么指定到li上，<br>解决方案：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var oUl &#x3D; document.getElementById(&#39;test&#39;);</span><br><span class="line">oUl.addEventListener(&#39;click&#39;,function(ev)&#123;</span><br><span class="line">    var target &#x3D; ev.target;</span><br><span class="line">    while(target !&#x3D;&#x3D; oUl )&#123;</span><br><span class="line">        if(target.tagName.toLowerCase() &#x3D;&#x3D; &#39;li&#39;)&#123;</span><br><span class="line">            console.log(&#39;li click~&#39;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        target &#x3D; target.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>那什么样的事件可以用事件委托，什么样的事件不可以用呢？</p>
<p>适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。</p>
<p>值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。</p>
<p>不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>日常零散知识记录</title>
    <url>/2020/02/27/%E6%97%A5%E5%B8%B8%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h2><h3 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h3><p><strong>this指向取决与当前执行上下文</strong></p>
<ul>
<li>当函数被当作独立函数调用时<ul>
<li>严格模式下this指向undefined；</li>
<li>非严格模式下this指向window。</li>
</ul>
</li>
<li>当函数被当做对象的方法调用时，this指向调用者，也就是this指向此对象。</li>
<li>当函数被当作构造函数调用时，this关键字指向使用构造函数创建的实例</li>
<li>当函数为箭头函数调用时，this关键字指向上一级作用域</li>
</ul>
<a id="more"></a>

<h3 id="如何判断一个数据的类型？"><a href="#如何判断一个数据的类型？" class="headerlink" title="如何判断一个数据的类型？"></a>如何判断一个数据的类型？</h3><ul>
<li>使用 <code>typeof</code>，这个方法可以检测出 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>undefined</code> 和 <code>function</code> 的类型，但是当被检测的值为数组、对象或者 <code>null</code> 类型时，结果均为 <code>object</code>，无法准确判断它们的类型</li>
<li>使用<code>Object.prototype.toString.call</code>，目前这是最为可靠的检测类型的方法</li>
<li>如果检测是否是数组，可以用这个方法：<code>Array.isArray</code></li>
</ul>
<h3 id="什么是执行上下文？"><a href="#什么是执行上下文？" class="headerlink" title="什么是执行上下文？"></a>什么是执行上下文？</h3><p>执行上下文是一个抽象的概念，它形容了一段代码在运行时所处的环境。每个函数在执行时都有自己的执行上下文</p>
<p>JavaScript 中有三种执行上下文类型:</p>
<ul>
<li>全局执行上下文 （global execution context）。一个程序中只有一个全局上下文，在浏览器中其为 window 对象。</li>
<li>函数执行上下文 （function execution context）。每当函数被执行时，一个新的执行上下文就被创建了。</li>
<li>Eval 函数执行上下文 （eval execution context）。执行在 eval 中的代码时也会有其独立的执行上下文。</li>
</ul>
<h3 id="什么是词法作用域？"><a href="#什么是词法作用域？" class="headerlink" title="什么是词法作用域？"></a>什么是词法作用域？</h3><p>词法作用域是作用域的其中一个工作模型，词法作用域主要在代码的编译阶段<br>词法作用域也就是在代码的编译阶段定义的作用域，也就是说词法作用域在代码书写时就已经确定了。</p>
<p><strong>词法作用域的内涵是，作用域在词法分析阶段就被确定了，也就是说，变量在代码中所处的位置 (而不是运行时所处的位置)，决定了作用域。</strong></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>JavaScript 的作用域是基于词法作用域的，词法作用域的内涵是：作用域在词法分析阶段就被确定了，也就是说，<strong>变量在代码中所处的位置 (而不是运行时所处的位置)，决定了作用域。</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = foo()</span><br><span class="line">func() <span class="comment">// 打印出 2</span></span><br></pre></td></tr></table></figure>
<p>当函数<code>bar</code>执行时，很明显其早已脱离了原来的作用域，但是其依然打印出变量<code>a</code>的值，这就说明它一直记住了它在被定义时的作用域。</p>
<h3 id="闭包-closure-是什么？"><a href="#闭包-closure-是什么？" class="headerlink" title="闭包 (closure) 是什么？"></a>闭包 (closure) 是什么？</h3><p>通俗回答一般为：<br>函数嵌套函数，内部函数访问外部函数的的变量，这就是闭包环境</p>
<p><strong>答案：</strong><br>JavaScript 的作用域是基于词法作用域的，词法作用域的内涵是：作用域在词法分析阶段就被确定了，也就是说，变量的作用域在代码中所处的位置 (而不是运行时所处的位置)</p>
<p><strong>闭包就是函数能够记住并访问它的词法作用域</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = foo()</span><br><span class="line">func() <span class="comment">// 打印出 2</span></span><br></pre></td></tr></table></figure>
<p>当函数bar执行时，很明显其早已脱离了原来的作用域，但是其依然打印出变量a的值，这就说明它一直记住了它在被定义时的作用域。</p>
<p>综上所述，闭包是词法作用域和函数是JavaScript的第一公民相互所用自然而然产生的现象。</p>
<h3 id="闭包的应用"><a href="#闭包的应用" class="headerlink" title="闭包的应用"></a>闭包的应用</h3><ul>
<li>读取函数内部的变量</li>
<li>让这些变量的值始终保持在内存中</li>
</ul>
<p>在实际开发中，闭包主要是用来封装变量</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 闭包隐藏数据，只提供 API</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCache</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 闭包中的数据，被隐藏，不被外界访问</span></span><br><span class="line">    <span class="keyword">const</span> data = &#123;&#125; </span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="keyword">set</span>: function (key, val) &#123;</span><br><span class="line">            data[key] = val</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">get</span>: function (key) &#123;</span><br><span class="line">            <span class="keyword">return</span> data[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = createCache()</span><br><span class="line">c.set(<span class="string">'a'</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log( c.get(<span class="string">'a'</span>) )</span><br></pre></td></tr></table></figure>


<h3 id="原型面试题"><a href="#原型面试题" class="headerlink" title="原型面试题"></a>原型面试题</h3><p>1、一个页面的脚本如下，请问会打印出什么内容？为什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'puppy'</span></span><br><span class="line">&#125;</span><br><span class="line">Dog.prototype.bark = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'woof!woof!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.prototype.bark()</span><br></pre></td></tr></table></figure>
<p>会报错</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Cannot read property <span class="string">'bark'</span> <span class="keyword">of</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>因为普通对象实例是没有<code>prototype</code>这个属性的，也就是说普通对象的<code>prototype</code>属性的值是<code>undefined</code>。</p>
<p><strong>解读：</strong><br>所有的函数都有<code>prototype</code>属性，因为所有的函数都可以被当作构造函数。函数的<code>prototype</code>内的<code>construtor</code>指向当前的构造函数，当构造函数构造实例时，首先创建一个空对象，然后按照函数中对<code>this</code>的操作把空对象操作一遍，最后再把构造函数中的<code>prototype</code>的值赋给这个对象。</p>
<p>实例也是有属性指向其构造函数的原型的：<code>__proto__</code>。<br>也就是说实例的<code>__proto__</code>指向构造函数的<code>prototype</code>属性</p>
<p>2、一个页面的脚本如下，请问会打印出什么内容？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__ === <span class="built_in">Object</span>.prototype)</span><br></pre></td></tr></table></figure>

<p>答案：<br>打印出<code>true</code>，因为实例的<code>__proto__</code>属性指向其构造函数的<code>prototype</code>，而<code>Object</code>对象是普通对象的构造函数。</p>
<p><strong>解读：</strong><br>前面说了只有<code>构造函数</code>有<code>prototype</code>属性，很明显<code>Object</code>是一个构造函数，所以<code>Object.prototype</code>指向所有<code>new Object()</code>构造的实例的原型；</p>
<p>而实例的<code>__proto__</code>这个私有属性，指向其构造函数的<code>prototype</code>；</p>
<p>当我们声明<code>const a = {}</code>时，其实是隐式调用了<code>const a = new Object()</code></p>
<p>综上，<code>a.__proto__</code>指向a的构造函数的<code>prototype</code>属性，也就是<code>Object</code>的<code>prototype</code>属性。</p>
<h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="浅拷贝与深拷贝的区别"><a href="#浅拷贝与深拷贝的区别" class="headerlink" title="浅拷贝与深拷贝的区别"></a>浅拷贝与深拷贝的区别</h4><p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200427132854.png" alt=""></p>
<h4 id="深拷贝的方法"><a href="#深拷贝的方法" class="headerlink" title="深拷贝的方法"></a>深拷贝的方法</h4><p>1.JSON转换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> targetObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(copyObj))</span><br><span class="line"><span class="keyword">let</span> arr4 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr))</span><br></pre></td></tr></table></figure>

<p>2.普通递归函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 深拷贝</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>obj 要拷贝的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// obj 是 null ，或者不是对象和数组，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> obj</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化返回结果</span></span><br><span class="line">    <span class="keyword">let</span> result</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(obj)) &#123;</span><br><span class="line">        result = []</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="comment">// 保证 key 不是原型的属性</span></span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            <span class="comment">// 递归调用！！！</span></span><br><span class="line">            result[key] = deepClone(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回结果</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="headerlink" title="call, apply, bind 区别"></a>call, apply, bind 区别</h3><p>首先说下前两者的区别。<br><code>call</code> 和 <code>apply</code> 都是为了解决改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</p>
<p>bind 和其他两个方法作用也是一致的，只是该方法会返回一个函数。</p>
<p>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name)</span><br><span class="line">    <span class="built_in">console</span>.log(age)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value)</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(a, <span class="string">'yck'</span>, <span class="string">'24'</span>)</span><br><span class="line">getValue.apply(a, [<span class="string">'yck'</span>, <span class="string">'24'</span>])</span><br></pre></td></tr></table></figure>
<h3 id="手写一个bind函数"><a href="#手写一个bind函数" class="headerlink" title="手写一个bind函数"></a>手写一个bind函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟 bind</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.bind1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数拆解为数组</span></span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 this（数组第一项）</span></span><br><span class="line">    <span class="keyword">const</span> t = args.shift()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fn1.bind(...) 中的 fn1</span></span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> self.apply(t, args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this'</span>, <span class="keyword">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'this is fn1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fn2 = fn1.bind1(&#123;<span class="attr">x</span>: <span class="number">100</span>&#125;, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="keyword">const</span> res = fn2()</span><br><span class="line"><span class="built_in">console</span>.log(res)</span><br></pre></td></tr></table></figure>


<h3 id="手写一个ajax"><a href="#手写一个ajax" class="headerlink" title="手写一个ajax"></a>手写一个ajax</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>)</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (xhr.status === <span class="number">200</span>) &#123;</span><br><span class="line">                    resolve(</span><br><span class="line">                        <span class="built_in">JSON</span>.parse(xhr.responseText)</span><br><span class="line">                    )</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xhr.status === <span class="number">404</span> || xhr.status === <span class="number">500</span>) &#123;</span><br><span class="line">                    reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'404 not found'</span>))</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(<span class="literal">null</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">'/data/test.json'</span></span><br><span class="line">ajax(url)</span><br><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span> <span class="built_in">console</span>.log(res))</span><br><span class="line">.catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure>

<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>DOM事件流三个阶段</p>
<ul>
<li>捕获阶段:事件从window对象自上而下向目标节点传播的阶段</li>
<li>目标阶段:真正的目标节点正在处理事件的阶段</li>
<li>冒泡阶段:事件从目标节点自下而上向window对象传播的阶段<br>img(<a href="https://pic1.zhimg.com/v2-4de189d2a42b1e8c74b379e067b67578_r.jpg" target="_blank" rel="noopener">https://pic1.zhimg.com/v2-4de189d2a42b1e8c74b379e067b67578_r.jpg</a>)</li>
</ul>
<h3 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h3><p>Events 可以使用 Event 构造函数创建如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">'build'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Listen for the event.</span></span><br><span class="line">elem.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; ... &#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispatch the event.</span></span><br><span class="line">elem.dispatchEvent(event);</span><br></pre></td></tr></table></figure>
<p>要向事件对象添加更多数据，可以使用 <code>CustomEvent</code>，<code>detail</code> 属性可用于传递自定义数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'build'</span>, &#123; <span class="string">'detail'</span>: elem.dataset.time &#125;);</span><br><span class="line"></span><br><span class="line">elem.addEventListener(<span class="string">'build'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; </span><br><span class="line">     log(<span class="string">'The time is: '</span> + e.detail);</span><br><span class="line"> &#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>




<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="使用CSS变量"><a href="#使用CSS变量" class="headerlink" title="使用CSS变量"></a>使用CSS变量</h3><p><strong>变量的声明</strong><br>声明变量的时候，变量名前面要加两根连词线<code>（--）</code>。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-pseudo">:root</span>&#123;</span><br><span class="line">  <span class="attribute">--main-color</span>: <span class="number">#4d4e53</span>;</span><br><span class="line">  <span class="attribute">--main-bg</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>);</span><br><span class="line">  <span class="attribute">--logo-border-color</span>: rebeccapurple;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">--header-height</span>: <span class="number">68px</span>;</span><br><span class="line">  <span class="attribute">--content-padding</span>: <span class="number">10px</span> <span class="number">20px</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">--base-line-height</span>: <span class="number">1.428571429</span>;</span><br><span class="line">  <span class="attribute">--transition-duration</span>: .<span class="number">35s</span>;</span><br><span class="line">  <span class="attribute">--external-link</span>: <span class="string">"external link"</span>;</span><br><span class="line">  <span class="attribute">--margin-top</span>: <span class="built_in">calc</span>(<span class="number">2vh</span> + <span class="number">20px</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">--foo</span>: <span class="number">#7F583F</span>;</span><br><span class="line">  <span class="attribute">--bar</span>: <span class="number">#F7EFD2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读取变量</strong><br><code>var()</code>函数用于读取变量。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--main-color);</span><br><span class="line">  <span class="attribute">text-decoration-color</span>: <span class="built_in">var</span>(--bar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>JavaScript 操作 CSS 变量</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置变量</span></span><br><span class="line"><span class="built_in">document</span>.body.style.setProperty(<span class="string">'--primary'</span>, <span class="string">'#7F583F'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取变量</span></span><br><span class="line"><span class="built_in">document</span>.body.style.getPropertyValue(<span class="string">'--primary'</span>).trim();</span><br><span class="line"><span class="comment">// '#7F583F'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除变量</span></span><br><span class="line"><span class="built_in">document</span>.body.style.removeProperty(<span class="string">'--primary'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="http"><a href="#http" class="headerlink" title="http"></a>http</h2><h3 id="http协议的主要特点"><a href="#http协议的主要特点" class="headerlink" title="http协议的主要特点"></a>http协议的主要特点</h3><ul>
<li>简单快速</li>
<li>灵活</li>
<li>无连接<ul>
<li>连接一次就会断开</li>
</ul>
</li>
<li>无状态</li>
</ul>
<h3 id="http报文的组成部分"><a href="#http报文的组成部分" class="headerlink" title="http报文的组成部分"></a>http报文的组成部分</h3><p><strong>请求报文</strong></p>
<ul>
<li>请求行（http方法，http协议，http版本）</li>
<li>请求头（key，value值）</li>
<li>空行</li>
<li>请求体</li>
</ul>
<p><strong>响应报文</strong></p>
<ul>
<li>状态行</li>
<li>响应头</li>
<li>空行</li>
<li>响应体</li>
</ul>
<h4 id="get与post的区别"><a href="#get与post的区别" class="headerlink" title="get与post的区别"></a>get与post的区别</h4><ul>
<li>get通过url传递参数，post通过请求体传递</li>
<li>get请求在url传输的参数有限制，post没有限制</li>
<li>get请求会被浏览器主动缓存，post不可以，除非手动设置</li>
<li>get只能进行url编码，post支持多种编码方式</li>
</ul>
<h4 id="http状态码"><a href="#http状态码" class="headerlink" title="http状态码"></a>http状态码</h4><ul>
<li>1xx 指示信息-表示请求已被接收，继续处理</li>
<li>2xx 成功，表示请求已被成功接收</li>
<li>3xx 重定向 - </li>
<li>4xx 客户端错误 - 请求有语法错误或者请求无法实现</li>
<li>5xx 服务端错误</li>
</ul>
]]></content>
      <tags>
        <tag>知识点</tag>
      </tags>
  </entry>
  <entry>
    <title>泰啤趣味H5动画</title>
    <url>/2016/04/22/%E6%B3%B0%E5%95%A4%E8%B6%A3%E5%91%B3H5%E5%8A%A8%E7%94%BB/</url>
    <content><![CDATA[<h2 id="泰啤趣味H5动画"><a href="#泰啤趣味H5动画" class="headerlink" title="泰啤趣味H5动画"></a>泰啤趣味H5动画</h2><p>移动端春节传播H5趣味动画</p>
<p>主要使用html5+css3过渡、关键帧动画另外配合JS定时器进行开发</p>
<a id="more"></a>

<h2 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h2><p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200422174119.png" alt=""><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200422174139.png" alt=""><br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200422174242.png" alt=""></p>
]]></content>
      <categories>
        <category>案例</category>
      </categories>
      <tags>
        <tag>案例</tag>
      </tags>
  </entry>
  <entry>
    <title>极速入门Node.js的stream</title>
    <url>/2020/04/21/%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8Node-js%E7%9A%84stream/</url>
    <content><![CDATA[<h2 id="01-stream-的基本概念和常用-API-概述"><a href="#01-stream-的基本概念和常用-API-概述" class="headerlink" title="01 stream 的基本概念和常用 API 概述"></a>01 stream 的基本概念和常用 API 概述</h2><ul>
<li>什么是 stream</li>
<li>为何要使用 stream</li>
<li>stream 流转的过程</li>
<li>stream 的常见使用场景</li>
</ul>
<h3 id="什么是-stream"><a href="#什么是-stream" class="headerlink" title="什么是 stream"></a>什么是 stream</h3><blockquote>
<p>在编写代码时，我们应该有一些方法将程序像连接水管一样连接起来 – 当我们需要获取一些数据时，可以去通过”拧”其他的部分来达到目的。这也应该是IO应有的方式。 – Doug McIlroy. October 11, 1964</p>
</blockquote>
<p>英文叫 stream 中文叫“流”，都能很形象的表述出它的本质 —— 就是让数据流动起来。</p>
<p>我们用桶和水来做比喻还算比较恰当（其实计算机中的概念，都是数学概念，都是抽象的，都无法完全用现实事务做比喻），如下图。数据从原来的 source 流向 dest ，要像水一样，慢慢的一点一点的通过一个管道流过去。给鱼缸换水、偷汽油，都能用得上。</p>
<a id="more"></a>

<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421111143.png" alt=""></p>
<p>stream 并不是 node.js 独有的概念，而是一个操作系统最基本的操作方式，只不过 node.js 有 API 支持这种操作方式。linux 命令的 | 就是 stream ，因此所有 server 端语言都应该实现 stream 的 API 。</p>
<h3 id="为何要使用-stream"><a href="#为何要使用-stream" class="headerlink" title="为何要使用 stream"></a>为何要使用 stream</h3><p>暂不管编程的原因，先分析一下上图中换水的例子。如果没有中间的管道，而是直接抱起 source 水桶往 dest 水桶中倒，那肯定得需要一个力量特别大的人（或者多个人）才能完成。而有了这个管道，小孩子都可以很轻松的完成换水，而且管道粗细都可以最终完成，只不过是时间长短的问题。即，有管道换水需要的力量消耗非常少，不用管道换水消耗力量很大，这个应该很好理解。</p>
<p>其实这里所说的“力量”，对应到计算机编程中就是硬件的性能，这包括 CPU 的运算能力，内存的存储能力，硬盘和网络的读写速度（硬盘存储能力暂不考虑）。将上面倒水的例子对应到一个计算机的场景中，例如在线看电影，source 就是服务器端的视频，dest 就是你自己的播放器（或者浏览器中的 flash 和 h5 video）。到这里大家应该一下子能明白，目前看电影的方式就是如同用管道换水一样，一点一点的从服务端将视频流动到本地播放器，一边流动一边播放，最后流动完了也播放完了。</p>
<p>那播放视频为何要使用这种方式？解决这个问题不妨考虑反证法，即不用管道和流动的方式，先从服务端加载完视频文件，然后再播放。这样导致最直观的问题就是，需要加载很长一段时间才能播放视频。其实这仅仅的表面现象，还有可能是视频加载过程中，因内存占用太多而导致系统卡顿或者崩溃。因为我们的网速、内存、CPU 运算速度都是有限的（而且还要多个程序共享使用），这个视频文件可能有几个 G 那么大。</p>
<p>再说一个更加直观的例子，先看下面的这段代码。语法上并没有什么问题，但是如果 data.txt 文件非常大，在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。而且，如果并发请求过大，服务器内存开销也很大。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>);</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        res.end(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<p>要解决这个问题很简单 —— 用 stream ，代码改造如下。即并不是把文件全部读取了再返回，而是一边读取一边返回，一点一点的把数据流动到客户端。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>);</span><br><span class="line">    <span class="keyword">var</span> stream = fs.createReadStream(fileName);  <span class="comment">// 这一行有改动</span></span><br><span class="line">    stream.pipe(res); <span class="comment">// 这一行有改动</span></span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>
<p>最后总结一下，之所以用 stream ，是因为一次性读取、操作大文件，内存和网络是“吃不消”的，因此要让数据流动起来，一点一点的进行操作。这其实也符合算法中一个很重要的思想 —— 分而治之。</p>
<h3 id="stream-流转的过程"><a href="#stream-流转的过程" class="headerlink" title="stream 流转的过程"></a>stream 流转的过程</h3><p>从管道换水的例子可以看出，stream 包括 source，dest，还有中间的管道，下面将通过这三个方面来介绍 stream 的过程。其中比较关键的 API 有：</p>
<ul>
<li><code>data</code> 事件，用来监听 stream 数据的输入</li>
<li><code>end</code> 事件，用来监听 stream 数据输入完成</li>
<li><code>fs.createReadStream</code> 方法，返回一个文件读取的 stream 对象</li>
<li><code>fs.createWriteStream</code> 方法，返回一个文件写入的 stream 对象</li>
<li><code>pipe</code> 方法，用来做数据流转</li>
</ul>
<p>这些 API 下文都会有介绍和代码演示，能通过代码看懂语义即可，暂时不用深究 API 细节，后续章节会有详细介绍。</p>
<h4 id="source-——-从哪里来"><a href="#source-——-从哪里来" class="headerlink" title="source —— 从哪里来"></a><strong>source —— 从哪里来</strong></h4><p>stream 常见的来源方式主要有三种：</p>
<ul>
<li>从控制台输入</li>
<li>http 请求中的 request</li>
<li>读取文件</li>
</ul>
<p><strong>从控制台输入</strong><br>运行如下代码，然后从控制台输入任何内容，都会被 data 事件监听到，process.stdin 就是一个 stream 对象。注意，data 就是 stream 用来监听数据传入的一个自定义函数，后续会大量用到这个方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.stdin.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'stream by stdin'</span>, chunk.toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>http 请求中的 request</strong><br>http 请求中的 request 输入可以参考如下代码片段（不能直接运行，后面章节会详解）。即客户端发起了 http 请求，服务端可以通过这种方式（注意也用到了 data 事件监听）来监听到数据的传入。这种 http 请求一般是一个 post 请求，上传数据。注意，end 用来监听 stream 数据传输完毕，一般和 data 共用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// “一点一点”接收内容</span></span><br><span class="line">    data += chunk.toString()</span><br><span class="line">&#125;)</span><br><span class="line">req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// end 表示接收数据完成</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>读取文件</strong><br>读取文件是用 stream 如以下代码。fs.createReadStream(…) 可以返回一个读取文件的 stream 对象，该对象可以监听 data 和 end 事件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file1.txt'</span>)  <span class="comment">// 读取文件的 Stream 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    length += chunk.toString().length</span><br><span class="line">&#125;)</span><br><span class="line">readStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(length)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="dest-——-到哪里去"><a href="#dest-——-到哪里去" class="headerlink" title="dest —— 到哪里去"></a><strong>dest —— 到哪里去</strong></h4><p>stream 常见输出方式主要有三种：</p>
<ul>
<li>输出到控制台</li>
<li>http 请求中的 response</li>
<li>写入文件</li>
</ul>
<p><strong>输出到控制台</strong><br>上文讲解 source 时提到，process.stdin.on(‘data’, …) 可以监听控制台输入，而那仅仅是手动监听。如果让控制台输入这个 source 直接通过管道连接到控制台输入，即让数据从输入直接流向输出，使用如下代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">process.stdin.pipe(process.stdout) <span class="comment">// source.pipe(dest) 形式</span></span><br></pre></td></tr></table></figure>

<p><strong>http 请求中的 response</strong><br>nodejs 处理 http 请求时会用到 req 和 res ，其实这两者都是 stream 对象。其中 req 是 source ，可以 req.on(‘data’, …) 使用（上文已经演示过），res 是 dest ，用法如下。下面这段代码在本节文章一开始就介绍了，到这里大家应该明白，这是用 stream 的方式读取文件然后直接返回 http 请求。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stream = fs.createReadStream(fileName);</span><br><span class="line">stream.pipe(res); <span class="comment">// source.pipe(dest) 形式</span></span><br></pre></td></tr></table></figure>

<p><strong>写入文件</strong><br>读取文件可以用 stream ，写入文件当然也可以用 stream ，如下代码。其中，fs.createWriteStream(…) 会返回一个写入文件的 stream 对象，即 dest 。这段代码，就是将一个文件中的内容，一点一点的流动到另外的文件中，完成复制功能。跟文章一开始管道换水的例子非常像。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file1.txt'</span>)  <span class="comment">// source</span></span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(<span class="string">'./file2.txt'</span>)  <span class="comment">// dest</span></span><br><span class="line">readStream.pipe(writeStream) <span class="comment">// source.pipe(dest) 形式</span></span><br></pre></td></tr></table></figure>

<h3 id="stream-的常见使用场景"><a href="#stream-的常见使用场景" class="headerlink" title="stream 的常见使用场景"></a>stream 的常见使用场景</h3><p>stream 常见的应用场景是 http 请求和文件操作</p>
<p>总结来看，http 请求和文件操作都属于 IO ，即 stream 主要的应用场景就是处理 IO ，这就又回到了 stream 的本质 —— 由于一次性 IO 操作过大，硬件开销太多，影响软件运行效率，因此将 IO 分批分段操作，让数据一点一点的流动起来，直到操作完成。</p>
<h2 id="02-在-http-get-请求中使用-stream"><a href="#02-在-http-get-请求中使用-stream" class="headerlink" title="02 在 http get 请求中使用 stream"></a>02 在 http get 请求中使用 stream</h2><p>stream 的应用场景都是 IO 操作，包括网络 IO 和文件 IO 。本节主要介绍 http 请求中的 get 请求如何应用 stream ，以及应用 stream 之后对性能的提升。</p>
<ul>
<li>node.js 实现 http 请求</li>
<li>get 请求和 response</li>
<li>response 和 stream</li>
<li>使用 stream 对性能的提升</li>
<li>应用场景</li>
</ul>
<h3 id="node-js-实现-http-请求"><a href="#node-js-实现-http-请求" class="headerlink" title="node.js 实现 http 请求"></a>node.js 实现 http 请求</h3><p>这段代码就创建了一个服务，监听 8000 端口。有请求进来，就去读取 data.txt 这个文件，然后返回给客户端。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>);</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">        res.end(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<p>下面将这段代码真正运行起来。找一个目录，然后新建 test1.js 文件，然后把这段代码写入其中。然后再新建 data.txt 文件，随便写点什么文本内容，例如123456。然后打开命令行，定位到这个文件夹，运行 node test1.js ，打开浏览器访问 <a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a> 即可看到效果。</p>
<h3 id="get-请求和-response"><a href="#get-请求和-response" class="headerlink" title="get 请求和 response"></a>get 请求和 response</h3><p>get 请求，通过 req.method 可获取请求方法，因此将代码做如下改造。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> method = req.method; <span class="comment">// 获取请求方法</span></span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">'GET'</span>) &#123; <span class="comment">// 暂只关注 get 请求</span></span><br><span class="line">        <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>);</span><br><span class="line">        fs.readFile(fileName, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">            res.end(data);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他 method 暂时忽略</span></span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>
<p>将代码修改在 test1.js 中，重新运行 node 并刷新浏览器，依然可以看到效果。</p>
<p>http 常见的有 get 和 post 请求，get 请求本意是获取数据，即 response ，post 请求本意的上传数据，即 request 。本节只关注 get 请求，也就代表本节只关注 http 请求的 response 。</p>
<h3 id="response-和-stream"><a href="#response-和-stream" class="headerlink" title="response 和 stream"></a>response 和 stream</h3><p>response 常用的 API 有 send end 等，如上面代码中的 res.end(data) ，但是 response 也是一个 stream 对象。大家再次回顾一开始的管道换水的图，以及 source.pipe(dest) 模型，response 就是一个 dest 。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421111143.png" alt=""></p>
<p>因此，之前的代码可以做出如下改动。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> method = req.method; <span class="comment">// 获取请求方法</span></span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">'GET'</span>) &#123; <span class="comment">// 暂只关注 get 请求</span></span><br><span class="line">        <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>);</span><br><span class="line">        <span class="keyword">var</span> stream = fs.createReadStream(fileName);</span><br><span class="line">        stream.pipe(res); <span class="comment">// 将 res 作为 stream 的 dest</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他 method 暂时忽略</span></span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<p>从之前的章节学习中我们知道 fs.createReadStream() 可以创建一个读取文件的 stream 对象，通过 pipe 可以将数据传递下去，这里就传递给了 response 。修改 test1.js 并创新运行 node ，刷新浏览器即可看到效果。</p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>在 nodejs 中如果要返回的数据是经过 IO 操作得来的，例如上面例子中读取文件内容，可以直接使用 stream.pipe(res); 这种方式，而不要再用 res.end(data); 了。</p>
<p>这种应用的实例应该比较多，主要有两种场景：</p>
<ul>
<li>使用 node.js 作为服务代理，即客户端通过 node.js 服务作为跳板去请求其他服务，返回请求的内容</li>
<li>使用 node.js 做静态文件服务器，直接返回静态文件</li>
</ul>
<h2 id="03-在-http-post-请求中使用stream"><a href="#03-在-http-post-请求中使用stream" class="headerlink" title="03 在 http post 请求中使用stream"></a>03 在 http post 请求中使用stream</h2><p>本节继续讲解常用的 post 请求，以及 stream 在其中的应用。get 请求关注 response ，而 post 请求更多关注 request 。</p>
<ul>
<li>node.js 处理 post 请求</li>
<li>request 和 stream</li>
<li>使用 stream 对性能的提升</li>
<li>应用场景</li>
</ul>
<h3 id="node-js-处理-post-请求"><a href="#node-js-处理-post-请求" class="headerlink" title="node.js 处理 post 请求"></a>node.js 处理 post 请求</h3><p>上一节讲解了 node.js 处理 http 请求，以及使用 req.method 可以获取请求的方法。根据这个基础，先用 node.js 实现一个最简单的 post 请求，代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> method = req.method; <span class="comment">// 获取请求方法</span></span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">'POST'</span>) &#123; <span class="comment">// 暂只关注 post 请求</span></span><br><span class="line">        res.end(<span class="string">'OK'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他请求方法暂不关心</span></span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<p>在 test1.js 的文件夹中，新建 test2.js 并将代码写入，然后运行 node test2.js ，即可监听 <a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a> 的 post 请求。</p>
<p>不过 post 请求就不容易用浏览器直接验证，最简单的方式是借助于 postman 这个工具来发送 post 请求。大家可以直接搜索并安装 postman ，也可以去 chrome 商店搜索 postman 并安装，然后在 Chrome 中输入 chrome://apps/ 即可看到 postman 的入口。无论哪种安装手段，打开 postman ，如下图操作，即可看到请求返回了 OK 。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421115841.png" alt=""></p>
<p>但是，post 请求一般是要发送数据的，而且发送的数据量可能会很大，我们同样可以借助 postman 来模拟发送数据的操作。为了方便后面的演示效果，可以找一个（或者自己造一个）比较大的 json 文本，然后粘贴到 body 的文本框中，并且选择 JSON 格式。操作如下图。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421115914.png" alt=""></p>
<p>接下来看看 post 请求发送的数据将如何被 nodejs 接收。</p>
<h3 id="request-和-stream"><a href="#request-和-stream" class="headerlink" title="request 和 stream"></a>request 和 stream</h3><p>web server 接收 http 请求肯定是通过 request ，而 request 接收数据的本质其实就是 stream 。再次联想一下课程一开始介绍的管道换水的图，以及 source.pipe(dest) 这个模型，其实 request 就是 source 。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421111143.png" alt=""></p>
<p>虽然看似是 request 接收数据，但是在 nodejs 服务本身而言，request 是产生数据的（即 source），它产生的数据就是它接收到客户端发送来的数据。</p>
<p>之前的章节介绍过，source 类型的 stream 对象都可以对其监听 data end 事件，分别触发数据接收和数据接收完成的通知。因此，代码可以被改造为以下样子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> method = req.method; <span class="comment">// 获取请求方法</span></span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">'POST'</span>) &#123; <span class="comment">// 暂只关注 post 请求</span></span><br><span class="line">        req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 接收到部分数据</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'chunk'</span>, chunk.toString().length);</span><br><span class="line">        &#125;);</span><br><span class="line">        req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 接收数据完成</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line">            res.end(<span class="string">'OK'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他请求方法暂不关心</span></span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<p>以上代码中，通过 req.on(‘data’, …) 接收流转的数据，因为数据是一点一点“流”进来的，因此每次“流”进来的那一点，都可以通过 chunk 读取。最后，通过 req.on(‘end’, …) 来监听数据传输完成，此时请求可以结束了。</p>
<p>将代码重新修改到 test2.js ，然后重启 node ，重新运行 postman 中最后发送 json 的请求。如果你的 json 文件够大，你应该会看到控制台中打印了如下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chunk 63560</span><br><span class="line">chunk 64556</span><br><span class="line">chunk 64574</span><br><span class="line">chunk 64596</span><br><span class="line">chunk 64572</span><br><span class="line">chunk 64612</span><br><span class="line">chunk 64574</span><br><span class="line">chunk 23086</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>从这个结果我们能很清楚的看到，post 请求发送的数据量很大，req.on(‘data’, …) 要分 8 次才能把数据接收完毕，每次接收到的数据比较小。这就很明显的看出 stream 的“一点一点”、“流” 的这个特点。</p>
<p>当然，如果 post 请求传递的数据本身就很小，那就没必要分多次接收，可能一次 req.on(‘data’, …) 就能把数据全部接收完成。</p>
<p>再举一个简单的例子，如果要把 request 请求的数据直接 response ，那么最快的方式就是 req.pipe(res) ，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> method = req.method; <span class="comment">// 获取请求方法</span></span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">'POST'</span>) &#123; <span class="comment">// 暂只关注 post 请求</span></span><br><span class="line">        req.pipe(res)  <span class="comment">// 将 request 数据直接 response</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他请求方法暂不关心</span></span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="接收到-post-请求的数据，然后将其写入文件。"><a href="#接收到-post-请求的数据，然后将其写入文件。" class="headerlink" title="接收到 post 请求的数据，然后将其写入文件。"></a>接收到 post 请求的数据，然后将其写入文件。</h3><p>下面做一个简单的示例来验证在 post 请求中使用 stream 的性能提升。为了完成测试，要做一个简单的 demo ，即 nodejs 接收到 post 请求的数据，然后将其写入文件。</p>
<p>不适用 stream 的 demo 代码如下。即通过 req.on(‘data’, …) 获取数据，然后暂存下来，最后在 req.on(‘end’, …) 中将数据完成的写入到 post.txt 文件中。当然，你需要先创建 post.txt 文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> method = req.method; <span class="comment">// 获取请求方法</span></span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">'POST'</span>) &#123; <span class="comment">// 暂只关注 post 请求</span></span><br><span class="line">        <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'post.txt'</span>);</span><br><span class="line">        <span class="keyword">var</span> writeStream = fs.createWriteStream(fileName)</span><br><span class="line">        req.pipe(writeStream)</span><br><span class="line">        req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 接收数据完成</span></span><br><span class="line">            res.end(<span class="string">'OK'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他请求方法暂不关心</span></span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="实际应用-1"><a href="#实际应用-1" class="headerlink" title="实际应用"></a>实际应用</h3><p>和 get 请求使用 stream 的场景类似，post 请求使用 stream 的场景，主要是用于将接收的数据直接进行 IO 操作，例如：</p>
<ul>
<li>将接收的数据直接存储为文件</li>
<li>将接收的数据直接 post 给其他的 web server</li>
</ul>
<h2 id="04-node-js-文件操作中使用-stream"><a href="#04-node-js-文件操作中使用-stream" class="headerlink" title="04 node.js 文件操作中使用 stream"></a>04 node.js 文件操作中使用 stream</h2><p>stream 主要解决 IO 操作的性能问题，之前讲解了 http 即网络 IO ，本节开始讲解文件 IO 即 node.js 的文件操作。</p>
<ul>
<li>node.js 如何读写文件</li>
<li>如何用 stream 读写文件</li>
<li>使用 stream 带来的性能提升</li>
<li>应用场景</li>
</ul>
<h3 id="node-js-读写文件"><a href="#node-js-读写文件" class="headerlink" title="node.js 读写文件"></a>node.js 读写文件</h3><p>node.js 提供了非常清晰易懂的读写文件的 API ，读取一个文件代码如下。通过 fs.readFile 读取文件，然后再回调函数中返回文件内容。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件名</span></span><br><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件内容</span></span><br><span class="line">fs.readFile(fileName, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 出错</span></span><br><span class="line">        <span class="built_in">console</span>.log(err.message)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印文件内容</span></span><br><span class="line">    <span class="built_in">console</span>.log(data.toString())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>写入文件操作代码如下。使用 fs.writeFile 写入文件内容，然后在回调函数中返回操作状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件名</span></span><br><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">fs.writeFile(fileName, <span class="string">'xxxxxx'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 出错</span></span><br><span class="line">        <span class="built_in">console</span>.log(err.message)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有报错，表示写入成功</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'写入成功'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>根据以上读写操作，可以简单做一个文件拷贝的程序，将 data.txt 中的内容拷贝到 data-bak.txt 中。代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">var</span> fileName1 = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line">fs.readFile(fileName1, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 出错</span></span><br><span class="line">        <span class="built_in">console</span>.log(err.message)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到文件内容</span></span><br><span class="line">    <span class="keyword">var</span> dataStr = data.toString()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入文件</span></span><br><span class="line">    <span class="keyword">var</span> fileName2 = path.resolve(__dirname, <span class="string">'data-bak.txt'</span>)</span><br><span class="line">    fs.writeFile(fileName2, dataStr, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="comment">// 出错</span></span><br><span class="line">            <span class="built_in">console</span>.log(err.message)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'拷贝成功'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用-stream-读写文件"><a href="#使用-stream-读写文件" class="headerlink" title="使用 stream 读写文件"></a>使用 stream 读写文件</h3><p>用 stream 读写文件其实前面章节都有多处用到，这里再统一整理一下。</p>
<ul>
<li>可以使用 <code>fs.createReadStream(fileName)</code> 来创建读取文件的 stream 对象</li>
<li>使用 <code>fs.createWriteStream(fileName)</code> 来创建写入文件的 stream 对象</li>
</ul>
<p>回顾第一节讲的管道换水的图，还有 source.pipe(dest) 的模型图。读取文件的 stream 对象，对应的就是 source ，即数据的来源。写入文件的 steram 对象对应的就是 dest ，即数据的目的地。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421111143.png" alt=""></p>
<p>可以再分别回顾一下之前章节讲解 get 和 post 请求时的示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>);</span><br><span class="line"><span class="keyword">var</span> stream = fs.createReadStream(fileName);</span><br><span class="line">stream.pipe(res); <span class="comment">// 将 res 作为 stream 的 dest</span></span><br></pre></td></tr></table></figure>

<p>以上代码是 node.js 处理 get 请求时，读取了文件直接返回。这里 stream 就是 source ，res 就是 dest ，两者用 pipe 相连，表示数据流动的方向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'post.txt'</span>);</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(fileName)</span><br><span class="line">req.pipe(writeStream)</span><br></pre></td></tr></table></figure>

<p>以上代码是 node.js 处理 post 请求时，将传入的数据直接写入文件。这里 req 就是 source ，writeStream 就是 dest ，两者用 pipe 相连，表示数据流动的方向。</p>
<p>接下来用 stream 实现一个文件拷贝的功能，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个文件名</span></span><br><span class="line"><span class="keyword">var</span> fileName1 = path.resolve(__dirname, <span class="string">'data.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> fileName2 = path.resolve(__dirname, <span class="string">'data-bak.txt'</span>)</span><br><span class="line"><span class="comment">// 读取文件的 stream 对象</span></span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(fileName1)</span><br><span class="line"><span class="comment">// 写入文件的 stream 对象</span></span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(fileName2)</span><br><span class="line"><span class="comment">// 执行拷贝，通过 pipe</span></span><br><span class="line">readStream.pipe(writeStream)</span><br><span class="line"><span class="comment">// 数据读取完成，即拷贝完成</span></span><br><span class="line">readStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'拷贝完成'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="使用-stream-来带的性能提升"><a href="#使用-stream-来带的性能提升" class="headerlink" title="使用 stream 来带的性能提升"></a>使用 stream 来带的性能提升</h3><p>上文分别用基本的文件操作 API 和 stream API 写了两个拷贝文件的程序，两者都能实现功能，但是性能上却有巨大的差异。这个程序并不是 web server ，因此我们不再用 ab 工具进行性能测试，而是看下两者对内存的占用情况，文件操作中内存往往是一个瓶颈。</p>
<p>先介绍一个监控 node.js 内存的轻量级小工具 —— <code>memeye</code> ，它能很方便很直观的监控 node.js 内存占用的情况。安装和使用也都非常简单。</p>
<p>找到之前 test2.js 的文件夹，命令行定位到这个文件夹，然后运行 <code>npm install memeye --save-dev</code> 等待安装完成。然后新建 test3.js ，在代码中写入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> memeye = <span class="built_in">require</span>(<span class="string">'memeye'</span>)</span><br><span class="line">memeye()</span><br></pre></td></tr></table></figure>

<p>命令行运行 node test3.js ，然后用浏览器打开 <a href="http://localhost:23333/" target="_blank" rel="noopener">http://localhost:23333/</a> 即可看到这个 node.js 进程的内存占用情况，如下图。其中我们最需要关心的就是页面中 Process Memory Usage 这部分的 heapUsed 内存大小，即 nodejs 的堆内存（可以简单理解为 JS 对象所占用的内存空间）。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421121240.png" alt=""></p>
<p>再继续完善一下 test3.js ，为了方便测试我们还需要做两个工作。第一，让拷贝操作延迟执行，程序运行之后还得切换到浏览器刷新统计界面。第二，连续执行 100 次拷贝操作，以便明显的看出差异。这样 test3.js 需要改进为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始监控内存</span></span><br><span class="line"><span class="keyword">var</span> memeye = <span class="built_in">require</span>(<span class="string">'memeye'</span>)</span><br><span class="line">memeye()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将拷贝操作封装到一个函数中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里自行补充上文的拷贝代码</span></span><br><span class="line">    <span class="comment">// 测试一，使用 readFile 和 writeFile 编写的拷贝代码</span></span><br><span class="line">    <span class="comment">// 测试二，使用 stream 编写的拷贝代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 延迟 5s 执行拷贝</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 连续执行 100 次拷贝</span></span><br><span class="line">    <span class="keyword">var</span> i</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">        copy()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">5000</span>)</span><br></pre></td></tr></table></figure>

<p>以上代码中，把上文使用 readFile 和 writeFile 编写的拷贝代码粘贴到 copy 函数中，然后运行 node test3.js ，立刻切换到浏览器刷新页面，结果如下图。图中 heapUsed 从 5M 左右一下子飙升到了 60M 左右。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421121343.png" alt=""></p>
<p>再把上文用 stream 编写的拷贝代码粘贴到 copy 函数中，然后重新运行 node test3.js 并立刻切换到浏览器刷新页面，结果如下图。图中 heapUsed 从 5M 左右仅仅增长到了 6M 左右。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421121354.png" alt=""></p>
<p>对比两种情况，5M -&gt; 60M VS 5M -&gt; 6M 非常巨大的差异，而且文件体积越大、操作数量越多，这种差异就越明显。由此可见，使用 stream 操作文件对性能带来了非常大的提升，因此大家以后一旦遇到文件操作，应该第一时间想到 stream 并评估是否需要使用。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>所有执行文件操作的场景，都应该尝试使用 stream ，例如文件的读写、拷贝、压缩、解压、格式转换等。除非是体积很小的文件，而且读写次数很少，性能上被忽略。</p>
<p>近几年前端的打包构建工具都是用 node.js 编写的，而打包和构建其实就是频繁的文件操作，这其中会用到大量的 stream 。其中靠 stream 上位的最著名就是 gulp ，一个非常轻量级的前端构建工具。</p>
<h2 id="05-逐行读取的最佳方案-readline"><a href="#05-逐行读取的最佳方案-readline" class="headerlink" title="05 逐行读取的最佳方案 readline"></a>05 逐行读取的最佳方案 readline</h2><p>上一节讲解了用 stream 操作文件，会来带很大的性能提升。但是原生的 stream 却对“行”无能为力，它只是把文件当做一个数据流、简单粗暴的流动。很多文件格式都是分行的，例如 csv 文件、日志文件，以及其他一些自定义的文件格式。</p>
<p>node.js 提供了非常简单的按行读取的 API —— readline ，它本质上也是 stream ，只不过是以“行”作为数据流动的单位。本节将结合一个分析日志文件的案例，讲解 readline 的使用。</p>
<ul>
<li>回顾 data end 自定义事件和 pipe 方法</li>
<li>readline 的使用</li>
<li>应用场景：日志文件的分析</li>
</ul>
<h3 id="回顾-data-end-和-pipe"><a href="#回顾-data-end-和-pipe" class="headerlink" title="回顾 data end 和 pipe"></a>回顾 data end 和 pipe</h3><p>通过学习以上的章节，我们知道 stream 对象有 data end 自定义事件和 pipe 方法。回顾一开始讲解的管道换水的图，即 source.pipe(dest) 这个模型。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421111143.png" alt=""></p>
<p>所有 source 类型的 stream 对象都可以监听它的 data end 自定义事件，例如 http 请求中的 request ，代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'chunk'</span>, chunk.toString().length);</span><br><span class="line">&#125;);</span><br><span class="line">req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line">    res.end(<span class="string">'OK'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>再例如读取文件的 stream 对象，代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file1.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> length = <span class="number">0</span></span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    length += chunk.toString().length</span><br><span class="line">&#125;)</span><br><span class="line">readStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(length)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>所有 source 类型的 stream 对象都有 pipe 方法，可以传入一个 dest 类型的 stream 对象，例如文件拷贝，代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(fileName1)</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(fileName2)</span><br><span class="line">readStream.pipe(writeStream)</span><br></pre></td></tr></table></figure>

<p>再例如 http 输入的内容直接输出，代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> method = req.method</span><br><span class="line"><span class="keyword">if</span> (method === <span class="string">'POST'</span>) &#123;</span><br><span class="line">    req.pipe(res)  <span class="comment">// 将 request 数据直接 response</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上都是 stream 的常用操作，而 readline 和 stream 类似，但是更加简单、易懂。</p>
<h3 id="readline-的使用"><a href="#readline-的使用" class="headerlink" title="readline 的使用"></a>readline 的使用</h3><p>相比于 stream 的 data 和 end 自定义事件， readline 需要监听 line 和 close 两个自定义事件。readline 的基本使用示例如下：</p>
<p>以上代码，需要先根据文件名，创建读取文件的 stream 对象，然后传入并生成一个 readline 对象，然后通过 line 事件监听逐行读取，通过 close 事件监听读取完成。</p>
<p>如果 readline-data.txt 中的文件内容是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">访问时间：[2018-10-23 13:56:48.407]，访问地址：&quot;http:&#x2F;&#x2F;www.example.com&#x2F;oc&#x2F;v&#x2F;account&#x2F;login.html&quot;</span><br><span class="line">访问时间：[2018-10-23 14:00:10.618]，访问地址：&quot;http:&#x2F;&#x2F;www.example.com&#x2F;oc&#x2F;v&#x2F;account&#x2F;user.html&quot;</span><br><span class="line">访问时间：[2018-10-23 14:00:34.200]，访问地址：&quot;http:&#x2F;&#x2F;www.example.com&#x2F;oc&#x2F;v&#x2F;account&#x2F;user.html&quot;</span><br></pre></td></tr></table></figure>

<p>那打印的内容将会是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">访问时间：[<span class="number">2018</span><span class="number">-10</span><span class="number">-23</span> <span class="number">13</span>:<span class="number">56</span>:<span class="number">48.407</span>]，访问地址：<span class="string">"http://www.example.com/oc/v/account/login.html"</span></span><br><span class="line">----- <span class="keyword">this</span> line read -----</span><br><span class="line">访问时间：[<span class="number">2018</span><span class="number">-10</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">10.618</span>]，访问地址：<span class="string">"http://www.example.com/oc/v/account/user.html"</span></span><br><span class="line">----- <span class="keyword">this</span> line read -----</span><br><span class="line">访问时间：[<span class="number">2018</span><span class="number">-10</span><span class="number">-23</span> <span class="number">14</span>:<span class="number">00</span>:<span class="number">34.200</span>]，访问地址：<span class="string">"http://www.example.com/oc/v/account/user.html"</span></span><br><span class="line">----- <span class="keyword">this</span> line read -----</span><br><span class="line">readline end</span><br></pre></td></tr></table></figure>

<h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p>对于处理按行为单位的文件，如日志文件，使用 readline 是最佳选择。接下来会使用 readline 演示一个日志文件的分析，最终得出在 2018-10-23 14:00 这一分钟内，访问 user.html 的日志数量。日志格式和上文的示例一样，但是日志的内容我制造了 10w 行（文件体积 11.4M ），为了能更加真实的演示效果。</p>
<p>根据以上示例的代码改造一下即可完成这个需求，需要改造的就是 line 和 close 两个自定义事件，以及在上面再加一行 var num = 0 来记录最终的数量。需要改造的代码如下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听逐行读取的内容</span></span><br><span class="line">rl.on(<span class="string">'line'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">lineData</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lineData.indexOf(<span class="string">'2018-10-30 14:00'</span>) &gt;= <span class="number">0</span> &amp;&amp; lineData.indexOf(<span class="string">'user.html'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        num++</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 监听读取完成</span></span><br><span class="line">rl.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'num'</span>, num)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>修改 test4.js 然后重新运行 node test4.js ，得到如下结果。即统计得到一共有 23040 条日志满足要求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">num 23040</span><br></pre></td></tr></table></figure>

<p>使用上一节的方法看一下内存占用，发现统计这个 11.4M 的日志文件，堆内存占用从 5M 仅仅上升到了 8.78M ，内存占用非常少，如下图。如果是全部把文件读取再做分析，那内存就不会这么少了，具体可参考上一节的例子。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421122740.png" alt=""></p>
<p>借用这个简单的例子来演示 readline 的使用以及使用场景，其实日常工作中情况会更加复杂，不过再复杂的场景选择 readline 做逐行分析一定是不会错的。方向选对了很重要，选择大于努力。</p>
<p>最后，将这个示例所用的代码贴到下面，供大家参考。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="keyword">var</span> readline = <span class="built_in">require</span>(<span class="string">'readline'</span>) <span class="comment">// 引用 readline</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> memeye = <span class="built_in">require</span>(<span class="string">'memeye'</span>)</span><br><span class="line">memeye()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doReadLine</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 文件名</span></span><br><span class="line">    <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'readline-data.txt'</span>)</span><br><span class="line">    <span class="comment">// 创建读取文件的 stream 对象</span></span><br><span class="line">    <span class="keyword">var</span> readStream = fs.createReadStream(fileName)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 readline 对象</span></span><br><span class="line">    <span class="keyword">var</span> rl = readline.createInterface(&#123;</span><br><span class="line">        <span class="comment">// 输入，依赖于 stream 对象</span></span><br><span class="line">        input: readStream</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听逐行读取的内容</span></span><br><span class="line">    rl.on(<span class="string">'line'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">lineData</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lineData.indexOf(<span class="string">'2018-10-30 14:00'</span>) &gt;= <span class="number">0</span> &amp;&amp; lineData.indexOf(<span class="string">'user.html'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            num++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 监听读取完成</span></span><br><span class="line">    rl.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'num'</span>, num)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(doReadLine, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本节主要讲解了 readline 的使用和一个日志分析的示例，学完本节希望你能掌握：</p>
<ul>
<li>readline 本质也是 stream ，也是解决一次性 IO 操作的性能问题</li>
<li>readline 是 node.js 按行读取文件的最佳选择</li>
<li>readline 的使用，以及本节的分析日志的案例</li>
</ul>
<p>到这里已经讲完了 stream 在网络 IO 和文件 IO 的基本使用，就像一开始介绍的管道换水的例子，一点一点的将数据流出来。那么，每次流动的这一点数据到底是什么（即之前代码示例中的 chunk 变量）？下一节讲解。</p>
<h2 id="06-stream-和-buffer"><a href="#06-stream-和-buffer" class="headerlink" title="06 stream 和 buffer"></a>06 stream 和 buffer</h2><p>以上章节已经介绍过了 stream 在网络 IO 和文件 IO 中的使用以及价值，但还有一个很重要的问题没有解决。本教程一开始就提到，stream 就是将数据一点一点的流动起来，那么每次流动的数据到底是什么？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file1.txt'</span>)</span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>具体一点，就是以上代码中的 chunk 到底是什么？本节来讲解。</p>
<ul>
<li>二进制介绍</li>
<li>node.js 如何表示二进制</li>
<li>stream 中“流动”的二进制数据</li>
<li>使用 Buffer 对性能的提升</li>
</ul>
<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>首先得要普及一下二进制的知识，特别是对于前端的同学，相对于后端开发的同学，这些计算机基础知识都相对薄弱，更有必要了解一下。</p>
<p>半个世纪之前，现代计算机之父 冯.诺依曼 提出了“冯.诺依曼结构”，其中最核心的内容之一就是：计算式使用二进制形式进行存储了计算。这种设计一直沿用至今，而且在未来也会一直用下去，除非真的出现了传说中的量子计算以颠覆现代计算机结构。</p>
<p>计算机内存由若干个存储单元组成，每个存储单元只能存储 0 或者 1 （因为内存是硬件，计算机硬件本质上就是一个一个的电子元件，只能识别充电和放电的状态，充电代表 1 ，放电代表 0 ，可以先这么简单理解），即二进制单元（英文叫 bit）。但是这一个单元所能存储的信息太少，因此约定将 8 个二进制单元为一个基本存储单元，叫做字节（英文是 byte）。一个字节所能存储的最大整数就是 2^8 = 256 ，也正好是 16^2 ，因此也尝尝使用两位的 16 进制数代表一个字节。例如 CSS 中常见的颜色值 #CCCCCC 就是 6 位 16 进制数字，它占用 3 个字节的空间。</p>
<p>二进制是计算机最底层的数据格式，也是一种通用格式。计算机中的任何数据格式，字符串、数字、视频、音频、程序、网络包等，在最底层都是用二进制来进行存储。这些高级格式和二进制之间，都可通过固定的编码格式进行相互转换。例如，C 语言中 int32 类型的十进制整数（无符号的），就占用 32 bit 即 4 byte ，十进制的 3 对应的二进制就是 00000000 00000000 00000000 00000011 。字符串也同理，可以根据 ASCII 编码规则或者 unicode 编码规则（如 utf-8）等和二进制进行相互转换。</p>
<p>总之，计算机底层存储的数据都是二进制格式，各种高级类型都有对应的编码规则，和二进制进行相互转化。</p>
<h3 id="nodejs-表示二进制"><a href="#nodejs-表示二进制" class="headerlink" title="nodejs 表示二进制"></a>nodejs 表示二进制</h3><p>Buffer 就是 nodejs 中二进制的表述形式。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'学习 nodejs stream'</span></span><br><span class="line"><span class="keyword">var</span> buf = Buffer.from(str, <span class="string">'utf-8'</span>) <span class="comment">// 注意：node 版本 &lt; 6.0 的使用 var buf = new Buffer(str, 'utf-8')</span></span><br><span class="line"><span class="built_in">console</span>.log(buf) <span class="comment">// &lt;Buffer e5 ad a6 e4 b9 a0 20 6e 6f 64 65 6a 73 20 73 74 72 65 61 6d&gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'utf-8'</span>))  <span class="comment">// 学习 nodejs stream</span></span><br></pre></td></tr></table></figure>

<p>以上代码中，先通过 Buffer.from 将一段字符串转换为二进制形式，其中 utf-8 是一个编码规则。二进制打印出来之后是一个类似数组的对象（但它不是数组），每个元素都是两位的 16 进制数字，即代表一个 byte ，打印出来的 buf 一共有 20 byte 。即根据 utf-8 的编码规则，这段字符串需要 20 byte 进行存储。最后，再通过 utf-8 规则将二进制转换为字符串并打印出来。</p>
<h3 id="流动的数据是二进制格式"><a href="#流动的数据是二进制格式" class="headerlink" title="流动的数据是二进制格式"></a>流动的数据是二进制格式</h3><p>先在之前的示例中分别打印一下 chunk instanceof Buffer 和 chunk ，看看结果。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file1.txt'</span>)</span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk <span class="keyword">instanceof</span> Buffer)</span><br><span class="line">    <span class="built_in">console</span>.log(chunk)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>打印结果如下图。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421123223.png" alt=""></p>
<p>可以看到 stream 中流动的数据就是 Buffer 类型，就是二进制。因此，在使用 stream chunk 的时候，需要将这些二进制数据转换为相应的格式。例如之前讲解 post 请求，从 request 中接收数据就是这样。再回归一下之前的代码，就能看明白了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStr = <span class="string">''</span>;</span><br><span class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> chunkStr = chunk.toString()  <span class="comment">// 这里，将二进制转换为字符串</span></span><br><span class="line">    dataStr += chunkStr</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>stream 中为何要“流动”二进制格式的数据呢？回答这个问题得再次考虑一下 stream 的设计目的 —— 为了优化 IO 操作。无论是文件 IO 还是网络 IO ，其中包含的数据格式是未可知的，如字符串、音频、视频、网络包等。即便都是字符串，其编码规则也是未可知的，如 ASC 编码、utf-8 编码。再这么多未可知的情况下，只能是以不变应万变，直接用最通用的二进制格式，谁都能认识。</p>
<p>而且，用二进制格式进行流动和传输，是效率最高的。</p>
<p>PS：补充一点，按照上面的说法，那无论是用 stream 读取文件还是 fs.readFile 读取文件，读出来的都应该是二进制格式？—— 答案是正确的，验证代码如下（下文正好会用到这段代码）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>);</span><br><span class="line">fs.readFile(fileName, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data <span class="keyword">instanceof</span> Buffer)  <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(data)  <span class="comment">// &lt;Buffer 7b 0a 20 20 22 72 65 71 75 69 72 65 ...&gt;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="07-stream-常用类型总结"><a href="#07-stream-常用类型总结" class="headerlink" title="07 stream 常用类型总结"></a>07 stream 常用类型总结</h2><p>再次回顾第一节中讲解的管道换水的图，source 通过一个管道流向了 dest ，如下图。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421111143.png" alt=""></p>
<p>通过之前的学习知道：这里的 source 可能是 http 请求中的 request ，也可能是读取文件的 stream 对象，也可能是 process.stdin ；这里的 dest 可能是 http 请求中的 response ，也可能是写入文件的 stream 对象，也可能是 process.stdout；这里的管道就是 pipe 函数。</p>
<p>先不管 pipe 函数。source 和 dest 完全就是两个不同的类型，一个是读取数据的，叫做 readable stream ，一个是写入数据的，叫做 writeable stream ，下文会详细介绍这两种类型。</p>
<p>除了这两种类型之外，还有一种类型叫做 duplex stream ，中文叫双工流，既有读取功能又有写入功能。例如下面的代码，readStream 读取的数据直接 pipe 到 zlib.createGzip() 这个 duplex stream 就是 gzip 压缩，然后再 pipe 到 writeStream 结束操作。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>)</span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./file1.txt'</span>)</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(<span class="string">'./file1.txt.gz'</span>)</span><br><span class="line">readStream.pipe(zlib.createGzip())</span><br><span class="line">          .pipe(writeStream)</span><br></pre></td></tr></table></figure>
<p>其他类型（transform classic）不常用，暂时可不关注。</p>
<h3 id="readable-stream"><a href="#readable-stream" class="headerlink" title="readable stream"></a>readable stream</h3><p>根据本节一开始的分析，http 请求中的 request 和读取文件的 stream 对象都是 readable stream ，即可以从中读取数据。它有两种常用的操作方式，第一种是直接将数据 pipe 到一个 writeable stream ，例如之前讲解 get 请求时的代码示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'data.txt'</span>);</span><br><span class="line"><span class="keyword">var</span> stream = fs.createReadStream(fileName);</span><br><span class="line">stream.pipe(res); <span class="comment">// 直接将数据 `pipe` 到一个 writeable stream</span></span><br></pre></td></tr></table></figure>
<p>第二种是通过监听 on end 自定义事件来获取数据再手动处理，例如之前讲解 post 请求时的代码示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> dataStr = <span class="string">''</span>;</span><br><span class="line">req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 接收到数据，先存储起来</span></span><br><span class="line">    <span class="keyword">var</span> chunkStr = chunk.toString()</span><br><span class="line">    dataStr += chunkStr</span><br><span class="line">&#125;);</span><br><span class="line">req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 接收数据完成，将数据写入文件</span></span><br><span class="line">    <span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'post.txt'</span>);</span><br><span class="line">    fs.writeFile(fileName, dataStr)</span><br><span class="line"></span><br><span class="line">    res.end(<span class="string">'OK'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>以上说的两个例子，都是已经封装好的 readable stream 。那么它的本来面目是怎样的？先看下面代码。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Readable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Readable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个 readable stream 并往里“灌入”数据</span></span><br><span class="line"><span class="keyword">var</span> rs = <span class="keyword">new</span> Readable;</span><br><span class="line">rs.push(<span class="string">'学习 '</span>);</span><br><span class="line">rs.push(<span class="string">'nodejs '</span>);</span><br><span class="line">rs.push(<span class="string">'stream</span></span><br><span class="line"><span class="string">'</span>);</span><br><span class="line">rs.push(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// pipe 到一个 writable stream</span></span><br><span class="line">rs.pipe(process.stdout);</span><br></pre></td></tr></table></figure>
<p>以上代码可以看出，node.js 提供了 readable stream 的构造函数，可以 new 出一个新的 readable stream 对象。然后通过 push 函数往里“灌入”数据，当传入的是 null 的时候表示“灌入”完成，即可输入了。最后 pipe 到了一个 writeable stream 。</p>
<h3 id="writeable-stream"><a href="#writeable-stream" class="headerlink" title="writeable stream"></a>writeable stream</h3><p>根据本节一开始的分析，http 请求中的 response 和写入文件的 stream 对象都是 writable stream ，它可以作为参数传入 pipe 函数，以读取上游的数据。例如之前讲解文件操作时拷贝文件的代码示例。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fileName = path.resolve(__dirname, <span class="string">'post.txt'</span>);</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(fileName)</span><br><span class="line">req.pipe(writeStream) <span class="comment">// writeStream 作为参数传递到 pipe 函数中</span></span><br></pre></td></tr></table></figure>
<p>以上代码中 writeStream 是已经封装好了的 writeable stream ，下面再看看它的本来面目。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Writable = <span class="built_in">require</span>(<span class="string">'stream'</span>).Writable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ws = Writable();</span><br><span class="line">ws._write = <span class="function"><span class="keyword">function</span> (<span class="params">chunk, enc, next</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk.toString());  <span class="comment">// 输出“流动”的数据</span></span><br><span class="line">    next();  <span class="comment">// 继续监听下一次输出</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">process.stdin.pipe(ws); <span class="comment">// 作为参数传递到 pipe 函数中</span></span><br></pre></td></tr></table></figure>
<p>根据以上代码得知，node.js 提供了 Writable 构造函数可以 new 一个新的 writable stream 。通过实现它的 _write 方法即可监听到每次“流动”的数据，运行 next() 可继续监听。</p>
<h3 id="再谈-pipe"><a href="#再谈-pipe" class="headerlink" title="再谈 pipe"></a>再谈 pipe</h3><p>之前的章节中一直是用 source.pipe(dest) 这种模式来使用 pipe 的，其实 pipe 可以链式调用。例如上文演示的 duplex stream 示例代码 readStream.pipe(zlib.createGzip()).pipe(writeStream) ，还有之前讲解文件操作的那一节最后列举的 gulp 配置文件的示例代码（可翻到那一节再回顾一下）。</p>
<p>之前讲解 source.pipe(dest) 模式是为了方便理解和使用，现在我们更新一个更加严谨的 pipe 用法：</p>
<ul>
<li>调用 pipe 的对象必须是 readable stream 或者 duplex stream ，即具有读取数据的功能。如 req.pipe(..)</li>
<li>传入 pipe 的参数必须是 writeable stream 或者 duplex stream ，即具有写入数据的功能。如 req.pipe(res)</li>
<li>pipe 支持链式调用</li>
</ul>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>stream</tag>
      </tags>
  </entry>
  <entry>
    <title>nodeJs入门系列</title>
    <url>/2020/03/29/nodeJs%E5%85%A5%E9%97%A8%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="01-介绍-安装"><a href="#01-介绍-安装" class="headerlink" title="01 介绍/安装/"></a>01 介绍/安装/</h2><h3 id="node-js-介绍"><a href="#node-js-介绍" class="headerlink" title="node.js 介绍"></a><strong>node.js 介绍</strong></h3><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。<br>Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。<br>Node.js 的包管理器 npm，是全球最大的开源库生态系统。</p>
<a id="more"></a>

<h3 id="Node-js优点"><a href="#Node-js优点" class="headerlink" title="Node.js优点"></a><strong>Node.js优点</strong></h3><p>1、采用事件驱动、异步编程，为网络服务而设计。其实Javascript的匿名函数和闭包特性非常适合事件驱动、异步编程。而且JavaScript也简单易学，很多前端设计人员可以很快上手做后端设计。<br>2、Node.js非阻塞模式的IO处理给Node.js带来在相对低系统资源耗用下的高性能与出众的负载能力，非常适合用作依赖其它IO资源的中间层服务。<br>3、Node.js轻量高效，可以认为是数据密集型分布式部署环境下的实时应用系统的完美解决方案。</p>
<p>Node非常适合如下情况：<br>在响应客户端之前，您预计可能有很高的流量，但所需的服务器端逻辑和处理不一定很多。</p>
<h3 id="Node-js缺点"><a href="#Node-js缺点" class="headerlink" title="Node.js缺点"></a><strong>Node.js缺点</strong></h3><p>1、可靠性低<br>2、单进程，单线程，只支持单核CPU，不能充分的利用多核CPU服务器。一旦这个进程崩掉，那么整个web服务就崩掉了。不过以上缺点可以可以通过代码的健壮性来弥补。</p>
<h3 id="Node-js-安装"><a href="#Node-js-安装" class="headerlink" title="Node.js 安装"></a><strong>Node.js 安装</strong></h3><p>中文官网地址：<br><a href="http://nodejs.cn/download/，进入下载页面选择对应的版本安装即可。" target="_blank" rel="noopener">http://nodejs.cn/download/，进入下载页面选择对应的版本安装即可。</a></p>
<p>更详细的安装教程，包含各类操作系统：<br><a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">http://www.runoob.com/nodejs/nodejs-install-setup.html</a></p>
<h3 id="检查是否安装成功"><a href="#检查是否安装成功" class="headerlink" title="检查是否安装成功"></a><strong>检查是否安装成功</strong></h3><p>命令行输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<p>返回node.js 版本号即代表安装成功。</p>
<h3 id="在命令行中实现hello-world"><a href="#在命令行中实现hello-world" class="headerlink" title="在命令行中实现hello world"></a><strong>在命令行中实现<code>hello world</code></strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">C:\Users\Administrator&gt;node \\此处是一个回车,既进入node交互环境</span><br><span class="line">&gt; <span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br><span class="line">输出：hello world</span><br></pre></td></tr></table></figure>
<h3 id="创建一个js文件并执行它-t-js"><a href="#创建一个js文件并执行它-t-js" class="headerlink" title="创建一个js文件并执行它(t.js)"></a><strong>创建一个js文件并执行它(t.js)</strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//t.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>);</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">D:\&gt;cd node.js</span><br><span class="line">D:\node.js&gt;node t.js</span><br><span class="line">输出：hello world</span><br></pre></td></tr></table></figure>

<h3 id="安装nodemon监控代码调试"><a href="#安装nodemon监控代码调试" class="headerlink" title="安装nodemon监控代码调试"></a>安装nodemon监控代码调试</h3><p>在开发nodejs程序，调试的时候，无论你修改了代码的哪一部分，都需要重启服务才能生效。这是因为 Node.js 只有在第一次引用到某部份时才会去解析脚本文件，以后都会直接访问内存，避免重复载入。。Node.js的这种设计虽然有利于提高性能，却不利于开发调试，因为我们在开发过程中总是希望修改后立即看到效果，而不是每次都要终止进程并重启。nodemon 可以帮助你实现这个功能，它会监视你对代码的改动，并自动重启 Node.js。</p>
<p>nodemon的安装也很简单：</p>
<p>直接用npm安装既可，键入命令: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm -g install nodemon</span><br></pre></td></tr></table></figure>

<p>nodemon 来启动服务了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nodemon index.js</span><br></pre></td></tr></table></figure>

<p>现在，代码发生改变，nodemon会自动重启 Node.js；</p>
<h3 id="服务端原理、语言倾诉对象"><a href="#服务端原理、语言倾诉对象" class="headerlink" title="服务端原理、语言倾诉对象"></a><strong>服务端原理、语言倾诉对象</strong></h3><p>使用node.js作为后端的项目，客户访问过程：<br>客户端发起请求 -&gt; node.js 服务器接到请求并运算、解析 -&gt; 返回请求结果。<br>我们所编写代码语言的倾诉对象就是 node.js 服务器端。</p>
<h2 id="02-NodeJs-创建第一个应用"><a href="#02-NodeJs-创建第一个应用" class="headerlink" title="02 NodeJs 创建第一个应用"></a>02 NodeJs 创建第一个应用</h2><p>在我们创建 Node.js 第一个 “Hello, World!” 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的：</p>
<ol>
<li>引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。</li>
<li>创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。</li>
<li>接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。</li>
</ol>
<h3 id="创建-Node-js-应用"><a href="#创建-Node-js-应用" class="headerlink" title="创建 Node.js 应用"></a>创建 Node.js 应用</h3><p><strong>步骤一、引入 required 模块</strong><br>我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>); <span class="comment">//使用 require函数获取 http模块</span></span><br></pre></td></tr></table></figure>
<p><strong>步骤二、创建服务器</strong><br>接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。</p>
<p>实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用 require函数获取 http模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//不处理favicon.ico</span></span><br><span class="line">    <span class="keyword">if</span>(request.url == <span class="string">"/favicon.ico"</span>)&#123;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="comment">// 发送 HTTP 头部 </span></span><br><span class="line">    <span class="comment">// HTTP 状态值: 200 : OK</span></span><br><span class="line">    <span class="comment">// 内容类型: text/html,解决中文乱码问题</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html;  charset=utf-8'</span>&#125;);</span><br><span class="line">    <span class="comment">//设置编码类型</span></span><br><span class="line">    response.write(<span class="string">'&lt;head&gt;&lt;meta charset="utf-8"/&gt;&lt;/head&gt;'</span>);  </span><br><span class="line">    <span class="comment">// 发送响应数据 "Hello World"</span></span><br><span class="line">    response.write(<span class="string">"中文"</span>);</span><br><span class="line">    response.end(<span class="string">'Hello World'</span>);</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:8888/'</span>);</span><br></pre></td></tr></table></figure>
<p>以上代码我们完成了一个可以工作的 HTTP 服务器。<br>使用 node 命令执行以上的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">node server.js</span><br><span class="line">Server running at http:<span class="comment">//127.0.0.1:8888/</span></span><br></pre></td></tr></table></figure>

<p>接下来，打开浏览器访问 <a href="http://127.0.0.1:8888/，你会看到一个写着" target="_blank" rel="noopener">http://127.0.0.1:8888/，你会看到一个写着</a> “中文 Hello World”的网页。</p>
<h2 id="03-NPM-使用介绍"><a href="#03-NPM-使用介绍" class="headerlink" title="03 NPM 使用介绍"></a>03 NPM 使用介绍</h2><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<p>由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm -v</span><br><span class="line"><span class="number">5.5</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<p>如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：</p>
<p>如果是 Window 系统使用以下命令即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install npm -g</span><br></pre></td></tr></table></figure>

<h3 id="使用-npm-命令安装模块"><a href="#使用-npm-命令安装模块" class="headerlink" title="使用 npm 命令安装模块"></a><strong>使用 npm 命令安装模块</strong></h3><p>npm 安装 Node.js 模块语法格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install &lt;Module Name&gt;</span><br></pre></td></tr></table></figure>

<p>以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure>

<p>安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="全局安装与本地安装"><a href="#全局安装与本地安装" class="headerlink" title="全局安装与本地安装"></a><strong>全局安装与本地安装</strong></h3><p>npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已<br>比如:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">npm install express      # 本地安装</span><br><span class="line">npm install express -g   # 全局安装</span><br></pre></td></tr></table></figure>

<h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a><strong>本地安装</strong></h3><ol>
<li>将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。</li>
<li>可以通过 require() 来引入本地安装的包。</li>
</ol>
<h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a><strong>全局安装</strong></h3><ol>
<li>将安装包放在 /usr/local 下或者你 node 的安装目录。</li>
<li>可以直接在命令行里使用。</li>
</ol>
<h3 id="查看安装信息"><a href="#查看安装信息" class="headerlink" title="查看安装信息"></a><strong>查看安装信息</strong></h3><p>你可以使用以下命令来查看所有全局安装的模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ npm list -g</span><br><span class="line"></span><br><span class="line">├─┬ cnpm@<span class="number">4.3</span><span class="number">.2</span></span><br><span class="line">│ ├── auto-correct@<span class="number">1.0</span><span class="number">.0</span></span><br><span class="line">│ ├── bagpipe@<span class="number">0.3</span><span class="number">.5</span></span><br><span class="line">│ ├── colors@<span class="number">1.1</span><span class="number">.2</span></span><br><span class="line">│ ├─┬ commander@<span class="number">2.9</span><span class="number">.0</span></span><br><span class="line">│ │ └── graceful-readlink@<span class="number">1.0</span><span class="number">.1</span></span><br><span class="line">│ ├─┬ cross-spawn@<span class="number">0.2</span><span class="number">.9</span></span><br><span class="line">│ │ └── lru-cache@<span class="number">2.7</span><span class="number">.3</span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<h3 id="使用-package-json"><a href="#使用-package-json" class="headerlink" title="使用 package.json"></a><strong>使用 package.json</strong></h3><p>每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。<br>直接的说：就是管理你本地安装的npm包 </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="string">"name"</span>: <span class="string">"Hello World"</span>,</span><br><span class="line">	<span class="string">"version"</span>: <span class="string">"0.0.1"</span>,</span><br><span class="line">	<span class="string">"author"</span>: <span class="string">"张三"</span>,</span><br><span class="line">	<span class="string">"description"</span>: <span class="string">"第一个node.js程序"</span>,</span><br><span class="line">	<span class="string">"keywords"</span>:[<span class="string">"node.js"</span>,<span class="string">"javascript"</span>],</span><br><span class="line">	<span class="string">"repository"</span>: &#123;</span><br><span class="line">		<span class="string">"type"</span>: <span class="string">"git"</span>,</span><br><span class="line">		<span class="string">"url"</span>: <span class="string">"https://path/to/url"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"license"</span>:<span class="string">"MIT"</span>,</span><br><span class="line">	<span class="string">"engines"</span>: &#123;<span class="string">"node"</span>: <span class="string">"0.10.x"</span>&#125;,</span><br><span class="line">	<span class="string">"bugs"</span>:&#123;<span class="string">"url"</span>:<span class="string">"http://path/to/bug"</span>,<span class="string">"email"</span>:<span class="string">"bug@example.com"</span>&#125;,</span><br><span class="line">	<span class="string">"contributors"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"李四"</span>,<span class="string">"email"</span>:<span class="string">"lisi@example.com"</span>&#125;],</span><br><span class="line">	<span class="string">"scripts"</span>: &#123;</span><br><span class="line">		<span class="string">"start"</span>: <span class="string">"node index.js"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"dependencies"</span>: &#123;</span><br><span class="line">		<span class="string">"express"</span>: <span class="string">"latest"</span>,</span><br><span class="line">		<span class="string">"mongoose"</span>: <span class="string">"~3.8.3"</span>,</span><br><span class="line">		<span class="string">"handlebars-runtime"</span>: <span class="string">"~1.0.12"</span>,</span><br><span class="line">		<span class="string">"express3-handlebars"</span>: <span class="string">"~0.5.0"</span>,</span><br><span class="line">		<span class="string">"MD5"</span>: <span class="string">"~1.2.0"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">		<span class="string">"bower"</span>: <span class="string">"~1.2.8"</span>,</span><br><span class="line">		<span class="string">"grunt"</span>: <span class="string">"~0.4.1"</span>,</span><br><span class="line">		<span class="string">"grunt-contrib-concat"</span>: <span class="string">"~0.3.0"</span>,</span><br><span class="line">		<span class="string">"grunt-contrib-jshint"</span>: <span class="string">"~0.7.2"</span>,</span><br><span class="line">		<span class="string">"grunt-contrib-uglify"</span>: <span class="string">"~0.2.7"</span>,</span><br><span class="line">		<span class="string">"grunt-contrib-clean"</span>: <span class="string">"~0.5.0"</span>,</span><br><span class="line">		<span class="string">"browserify"</span>: <span class="string">"2.36.1"</span>,</span><br><span class="line">		<span class="string">"grunt-browserify"</span>: <span class="string">"~1.3.0"</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Package-json-属性说明"><a href="#Package-json-属性说明" class="headerlink" title="Package.json 属性说明"></a><strong>Package.json 属性说明</strong></h3><ul>
<li><p>name - 包名。</p>
</li>
<li><p>version - 包的版本号。</p>
</li>
<li><p>description - 包的描述。</p>
</li>
<li><p>homepage - 包的官网 url 。</p>
</li>
<li><p>author - 包的作者姓名。</p>
</li>
<li><p>contributors - 包的其他贡献者姓名。</p>
</li>
<li><p>dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</p>
</li>
<li><p>repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。</p>
</li>
<li><p>main - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。</p>
</li>
<li><p>keywords - 关键字</p>
</li>
</ul>
<p><strong>详细介绍参考</strong> <a href="http://javascript.ruanyifeng.com/nodejs/packagejson.html" target="_blank" rel="noopener">http://javascript.ruanyifeng.com/nodejs/packagejson.html</a></p>
<h3 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a><strong>卸载模块</strong></h3><p>我们可以使用以下命令来卸载 Node.js 模块。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm uninstall express</span><br></pre></td></tr></table></figure>
<h3 id="更新模块"><a href="#更新模块" class="headerlink" title="更新模块"></a><strong>更新模块</strong></h3><p>我们可以使用以下命令更新模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm update express</span><br></pre></td></tr></table></figure>
<h3 id="搜索模块"><a href="#搜索模块" class="headerlink" title="搜索模块"></a><strong>搜索模块</strong></h3><p>使用以下来搜索模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm search express</span><br></pre></td></tr></table></figure>
<h3 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a><strong>创建模块</strong></h3><p>创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm init</span><br><span class="line">This utility will walk you through creating a package.json file.</span><br><span class="line">It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line"></span><br><span class="line">See <span class="string">`npm help json`</span> <span class="keyword">for</span> definitive documentation on these fields</span><br><span class="line">and exactly what they <span class="keyword">do</span>.</span><br><span class="line"></span><br><span class="line">Use <span class="string">`npm install &lt;pkg&gt; --save`</span> afterwards to install a package and</span><br><span class="line">save it <span class="keyword">as</span> a dependency <span class="keyword">in</span> the package.json file.</span><br><span class="line"></span><br><span class="line">Press ^C at any time to quit.</span><br><span class="line">name: (node_modules) test                   # 模块名</span><br><span class="line">version: (<span class="number">1.0</span><span class="number">.0</span>) </span><br><span class="line">description: Node.js 测试模块(www.test.com)  # 描述</span><br><span class="line">entry point: (index.js) </span><br><span class="line">test command: make test</span><br><span class="line">git repository: https:<span class="comment">//github.com/test/runoob.git  # Github 地址</span></span><br><span class="line">keywords: </span><br><span class="line">author: </span><br><span class="line">license: (ISC) </span><br><span class="line">About to write to ……/node_modules/package.json:      # 生成地址</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"learn"</span>,</span><br><span class="line">  <span class="string">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="string">"description"</span>: <span class="string">"Node.js 测试模块"</span>,</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is <span class="keyword">this</span> ok? (yes) yes</span><br></pre></td></tr></table></figure>
<p>以上的信息，你需要根据你自己的情况输入。在最后输入 “yes” 后会生成 package.json 文件。</p>
<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install [-g] 本地或全局安装模块</span><br><span class="line">npm uninstall [-g] 本地或全局卸载模块</span><br><span class="line">npm update 更新模块</span><br><span class="line">npm ls 查看安装的模块</span><br><span class="line">npm list 列出已安装模块</span><br><span class="line">npm show  显示模块详情</span><br><span class="line">npm info 查看模块的详细信息</span><br><span class="line">npm search 搜索模块</span><br><span class="line">npm publish 发布模块</span><br><span class="line">npm unpublish 删除已发布的模块</span><br><span class="line">npm -v 或 npm version显示版本信息</span><br><span class="line">npm view npm versions 列出npm 的所有有效版本</span><br><span class="line">npm install -g npm@<span class="number">2.14</span><span class="number">.14</span> /npm update -g npm@<span class="number">2.14</span><span class="number">.14</span>  安装指定的npm版本</span><br><span class="line">npm init 引导创建一个package.json文件，包括名称、版本、作者这些信息等</span><br><span class="line">npm outdated  #检查模块是否已经过时</span><br><span class="line">npm root  [-g] 查看包的安装路径，输出 node_modules的路径，</span><br><span class="line">npm help 查看某条命令的详细帮助 例如输入npm help install</span><br><span class="line">npm config 管理npm的配置路径</span><br></pre></td></tr></table></figure>

<h3 id="使用淘宝-NPM-镜像"><a href="#使用淘宝-NPM-镜像" class="headerlink" title="使用淘宝 NPM 镜像"></a><strong>使用淘宝 NPM 镜像</strong></h3><p>大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。</p>
<p>淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。</p>
<p>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">这样就可以使用 cnpm 命令来安装模块了：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line"> cnpm install [name]</span><br></pre></td></tr></table></figure>

<h2 id="04-模块（module）"><a href="#04-模块（module）" class="headerlink" title="04 模块（module）"></a>04 模块（module）</h2><p>Node.js中，一个JavaScript文件中定义的变量、函数，都只在这个文件内部有效。当需要从模块外部引用这些变量、函数时，必须使用exports对象进行暴露。使用者要用require()命令引用这个JS文件。</p>
<p>foo.js文件中的代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"你好"</span>;</span><br><span class="line"></span><br><span class="line">exports.msg = msg; </span><br><span class="line"><span class="comment">//msg这个变量，是一个js文件内部才有作用域的变量。如果别人想用这个变量，那么就要用exports进行暴露。</span></span><br></pre></td></tr></table></figure>
<p>使用者：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">"./test/foo.js"</span>);</span><br><span class="line"><span class="comment">//使用者用foo来接收exports对象，也就是说，这里的foo变量，就是文件中的exports变量。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo.msg);</span><br></pre></td></tr></table></figure>
<p>一个JavaScript文件，可以向外exports无数个变量、函数。但是require的时候，仅仅需要require这个JS文件一次。使用的它的变量、函数的时候，用点语法即可</p>
<p>js文件中，可以用exports暴露很多东西，比如函数、变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">"你好"</span>;</span><br><span class="line"><span class="keyword">var</span> info = <span class="string">"呵呵"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(info);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exports.msg = msg;</span><br><span class="line">exports.info = info;</span><br><span class="line">exports.showInfo = showInfo;</span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">在使用者中，只需要require一次。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">"./test/foo.js"</span>);</span><br></pre></td></tr></table></figure>
<p>相当于增加了顶层变量。所有的函数、变量都要从这个顶层变量走：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo.msg);</span><br><span class="line"><span class="built_in">console</span>.log(foo.info);</span><br><span class="line">foo.showInfo();</span><br></pre></td></tr></table></figure>
<p>Node中，js文件和js文件，就是被一个个exports和require构建成为网状的。</p>
<p>如果在require命令中，这么写:<code>var foo = require(&quot;foo.js&quot;);</code> 没有写<code>./</code>,所以不是一个相对路径。是一个特殊的路径,那么Node.js将该文件视为<code>node_modules</code>目录下的一个文件</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>Node中模块分为两类：一类是Node提供的模块，称为核心模块；另一类是用户编写的模块，称为文件模块</p>
<p>核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最快的</p>
<p>文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速度比核心模块慢</p>
<h3 id="module对象信息"><a href="#module对象信息" class="headerlink" title="module对象信息"></a><strong>module对象信息</strong></h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.id 模块的识别符，通常是带有绝对路径的模块文件名。</span><br><span class="line"><span class="built_in">module</span>.filename 模块的文件名，带有绝对路径。</span><br><span class="line"><span class="built_in">module</span>.loaded 返回一个布尔值，表示模块是否已经完成加载。</span><br><span class="line"><span class="built_in">module</span>.parent 返回一个对象，表示调用该模块的模块。</span><br><span class="line"><span class="built_in">module</span>.children 返回一个数组，表示该模块要用到的其他模块。</span><br><span class="line"><span class="built_in">module</span>.exports 表示模块对外输出的值。</span><br></pre></td></tr></table></figure>
<p><img src="http://static.zybuluo.com/wp0214/z19k9k3jwvp9h0oop300x1lh/image.png" alt="image.png-42.3kB"></p>
<h2 id="05-文件系统操作-fs"><a href="#05-文件系统操作-fs" class="headerlink" title="05 文件系统操作-fs"></a>05 文件系统操作-fs</h2><blockquote>
<p><strong>fs文件系统用于对系统文件及目录进行读写操作</strong></p>
</blockquote>
<h3 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h3><h4 id="普通读取"><a href="#普通读取" class="headerlink" title="普通读取"></a>普通读取</h4><p>同步读取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    data = fs.readFileSync(<span class="string">'./fileForRead.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件内容: '</span> + data);</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'读取文件出错: '</span> + err.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/node readFileSync.js</span><br><span class="line">文件内容: hello world</span><br></pre></td></tr></table></figure>

<p>异步读取</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./fileForRead.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">console</span>.error(<span class="string">'读取文件出错: '</span> + err.message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件内容: '</span> + data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/node readFile.js</span><br><span class="line">文件内容: hello world</span><br></pre></td></tr></table></figure>

<h4 id="通过文件流读取"><a href="#通过文件流读取" class="headerlink" title="通过文件流读取"></a>通过文件流读取</h4><p>适合读取大文件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./fileForRead.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">readStream</span><br><span class="line">    .on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'读取数据: '</span> + chunk);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'出错: '</span> + err.message);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 没有数据了</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'没有数据了'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 已经关闭，不会再有事件抛出</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'已经关闭'</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/node createReadStream.js</span><br><span class="line">读取数据: hello world</span><br><span class="line">没有数据了</span><br><span class="line">已经关闭</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"><span class="comment">### 文件写入</span></span><br><span class="line"></span><br><span class="line">备注：以下代码，如果文件不存在，则创建文件；如果文件存在，则覆盖文件内容；</span><br><span class="line"></span><br><span class="line">异步写入</span><br><span class="line"></span><br><span class="line">```javascript</span><br><span class="line">var fs = require(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.writeFile(<span class="string">'./fileForWrite.txt'</span>, <span class="string">'hello world'</span>, <span class="string">'utf8'</span>, function(err)&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    console.log(<span class="string">'文件写入成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同步写入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fs.writeFileSync(<span class="string">'./fileForWrite1.txt'</span>, <span class="string">'hello world'</span>, <span class="string">'utf8'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件写入成功'</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过文件流写入"><a href="#通过文件流写入" class="headerlink" title="通过文件流写入"></a>通过文件流写入</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> writeStream = fs.createWriteStream(<span class="string">'./fileForWrite1.txt'</span>, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">writeStream</span><br><span class="line">    .on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  <span class="comment">// 已经关闭，不会再有事件抛出</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'已经关闭'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">writeStream.write(<span class="string">'hello'</span>);</span><br><span class="line">writeStream.write(<span class="string">'world'</span>);</span><br><span class="line">writeStream.end(<span class="string">''</span>);</span><br></pre></td></tr></table></figure>

<h4 id="相对底层的接口"><a href="#相对底层的接口" class="headerlink" title="相对底层的接口"></a>相对底层的接口</h4><blockquote>
<p>fs.write(fd, buffer, offset, length[, position], callback)<br>fs.write(fd, data[, position[, encoding]], callback)<br>fs.writeSync(fd, buffer, offset, length[, position])<br>fs.writeSync(fd, data[, position[, encoding]])</p>
</blockquote>
<ul>
<li>fd：写入的文件句柄。</li>
<li>buffer：写入的内容。</li>
<li>offset：将buffer从offset位置开始，长度为length的内容写入。</li>
<li>length：写入的buffer内容的长度。</li>
<li>position：从打开文件的position处写入。</li>
<li>callback：参数为 <code>(err, written, buffer)</code>。<code>written</code>表示有xx字节的buffer被写入。</li>
</ul>
<p>备注：<code>fs.write(fd, buffer, offset, length[, position], callback)</code>跟<code>fs.write(fd, data[, position[, encoding]], callback)</code>的区别在于：后面的只能把所有的data写入，而前面的可以写入指定的data子串？</p>
<h3 id="文件是否存在"><a href="#文件是否存在" class="headerlink" title="文件是否存在"></a>文件是否存在</h3><p><code>fs.exists()</code>已经是<code>deprecated</code>状态，现在可以通过下面代码判断文件是否存在。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.access(<span class="string">'./fileForRead.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fileForRead.txt存在'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.access(<span class="string">'./fileForRead2.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fileForRead2.txt存在'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>fs.access()</code>除了判断文件是否存在（默认模式），还可以用来判断文件的权限。</p>
<p>备忘：<code>fs.constants.F_OK</code>等常量无法获取（node v6.1，mac 10.11.4下，<code>fs.constants</code>是<code>undefined</code>）</p>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>异步版本（如果目录已存在，会报错）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.mkdir(<span class="string">'./hello'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'目录创建成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同步版本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.mkdirSync(<span class="string">'./hello'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.unlink(<span class="string">'./fileForUnlink.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件删除成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.unlinkSync(<span class="string">'./fileForUnlink.txt'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="创建目录-1"><a href="#创建目录-1" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.mkdir(path[, mode], callback)</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.mkdir(<span class="string">'sub'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建目录成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.mkdirSync(path[, mode])</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fs.mkdirSync(<span class="string">'hello'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建目录成功'</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h3><p>同步版本，注意：<code>fs.readdirSync()</code>只会读一层，所以需要判断文件类型是否目录，如果是，则进行递归遍历。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.readdirSync(path[, options])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getFilesInDir = <span class="function"><span class="keyword">function</span>(<span class="params">dir</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> results = [ path.resolve(dir) ];</span><br><span class="line">    <span class="keyword">var</span> files = fs.readdirSync(dir, <span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">    files.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">file</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        file = path.resolve(dir, file);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> stats = fs.statSync(file);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stats.isFile())&#123;</span><br><span class="line">            results.push(file);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stats.isDirectory())&#123;</span><br><span class="line">            results = results.concat( getFilesInDir(file) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> files = getFilesInDir(<span class="string">'../'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(files);</span><br></pre></td></tr></table></figure>

<p>异步版本：（TODO）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.rename(oldPath, newPath, callback)</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.rename(<span class="string">'./hello'</span>, <span class="string">'./world'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'重命名成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">fs.renameSync(oldPath, newPath)</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.renameSync(<span class="string">'./world'</span>, <span class="string">'./hello'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><p>移动文件也是我们经常会遇见的，可是fs没有专门移动文件的函数，但是我们可以通过rename函数来达到移动文件的目的，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">fs.rename(oldPath,newPath,function (err) &#123;</span><br><span class="line">   if (err) throw err;</span><br><span class="line">   console.log(&#39;renamed complete&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="监听文件修改"><a href="#监听文件修改" class="headerlink" title="监听文件修改"></a>监听文件修改</h3><p><code>fs.watch()</code>比<code>fs.watchFile()</code>高效很多（why）</p>
<h4 id="fs-watchFile"><a href="#fs-watchFile" class="headerlink" title="fs.watchFile()"></a>fs.watchFile()</h4><p>实现原理：轮询。每隔一段时间检查文件是否发生变化。所以在不同平台上表现基本是一致的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    persistent: <span class="literal">true</span>,  <span class="comment">// 默认就是true</span></span><br><span class="line">    interval: <span class="number">2000</span>  <span class="comment">// 多久检查一次</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// curr, prev 是被监听文件的状态, fs.Stat实例</span></span><br><span class="line"><span class="comment">// 可以通过 fs.unwatch() 移除监听</span></span><br><span class="line">fs.watchFile(<span class="string">'./fileForWatch.txt'</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">curr, prev</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'修改时间为: '</span> + curr.mtime);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>修改<code>fileForWatch.txt</code>，可以看到控制台下打印出日志</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/node watchFile.js</span><br><span class="line">修改时间为: Sat Jul <span class="number">16</span> <span class="number">2016</span> <span class="number">19</span>:<span class="number">03</span>:<span class="number">57</span> GMT+<span class="number">0800</span> (CST)</span><br><span class="line">修改时间为: Sat Jul <span class="number">16</span> <span class="number">2016</span> <span class="number">19</span>:<span class="number">04</span>:<span class="number">05</span> GMT+<span class="number">0800</span> (CST)</span><br></pre></td></tr></table></figure>

<p>为啥子？莫非单纯访问文件也会触发回调？</p>
<blockquote>
<p>If you want to be notified when the file was modified, not just accessed, you need to compare curr.mtime and prev.mtime.</p>
</blockquote>
<p>在 <strong>v0.10</strong> 之后的改动。如果监听的文件不存在，会怎么处理。如下</p>
<blockquote>
<p>Note: when an fs.watchFile operation results in an ENOENT error, it will invoke the listener once, with all the fields zeroed (or, for dates, the Unix Epoch). In Windows, blksize and blocks fields will be undefined, instead of zero. If the file is created later on, the listener will be called again, with the latest stat objects. This is a change in functionality since v0.10.</p>
</blockquote>
<h4 id="fs-watch"><a href="#fs-watch" class="headerlink" title="fs.watch()"></a>fs.watch()</h4><blockquote>
<p>fs.watch(filename[, options][, listener])<br>fs.unwatchFile(filename[, listener])</p>
</blockquote>
<p>这接口非常不靠谱（当前测试用的v6.1.0），参考 <a href="https://github.com/nodejs/node/issues/7420" target="_blank" rel="noopener">https://github.com/nodejs/node/issues/7420</a></p>
<blockquote>
<p>fs.watch(filename[, options][, listener])#</p>
</blockquote>
<p>注意：<code>fs.watch()</code>这个接口并不是在所有的平台行为都一致，并且在某些情况下是不可用的。<code>recursive</code>这个选项只在<code>mac</code>、<code>windows</code>下可用。</p>
<p>问题来了：</p>
<ol>
<li>不一致的表现。</li>
<li>不可用的场景。</li>
<li>linux上要recursive咋整。</li>
</ol>
<blockquote>
<p>The fs.watch API is not 100% consistent across platforms, and is unavailable in some situations.<br>The recursive option is only supported on OS X and Windows.</p>
</blockquote>
<p>备忘，不可用的场景。比如网络文件系统等。</p>
<blockquote>
<p>For example, watching files or directories can be unreliable, and in some cases impossible, on network file systems (NFS, SMB, etc), or host file systems when using virtualization software such as Vagrant, Docker, etc.</p>
</blockquote>
<p>另外，listener回调有两个参数，分别是<code>event</code>、<code>filename</code>。其中，<code>filename</code>仅在linux、windows上会提供，并且不是100%提供，所以，尽量不要依赖<code>filename</code>。</p>
<p>在linux、osx上，<code>fs.watch()</code>监听的是inode。如果文件被删除，并重新创建，那么删除事件会触发。同时，<code>fs.watch()</code>监听的还是最初的inode。（API的设计就是这样的）</p>
<p>结论：怎么看都感觉这个API很不靠谱，虽然性能比fs.watchFile()要高很多。</p>
<p>先来个例子，在osx下测试了一下，简直令人绝望。。。无论是创建、修改、删除文件，<code>evt</code>都是<code>rename</code>。。。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    persistent: <span class="literal">true</span>,</span><br><span class="line">    recursive: <span class="literal">true</span>,</span><br><span class="line">    encoding: <span class="string">'utf8'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fs.watch(<span class="string">'../'</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">event, filename</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'触发事件:'</span> + event);</span><br><span class="line">    <span class="keyword">if</span>(filename)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'文件名是: '</span> + filename);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'文件名是没有提供'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>修改下<code>fileForWatch.txt</code>，看到下面输出。。。感觉打死也不想用这个API。。。</p>
<p>贴下环境：osx 10.11.4, node v6.1.0。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">触发事件:rename</span><br><span class="line">文件名是: fs/fileForWatch.txt___jb_bak___</span><br><span class="line">触发事件:rename</span><br><span class="line">文件名是: fs/fileForWatch.txt</span><br><span class="line">触发事件:rename</span><br><span class="line">文件名是: fs/fileForWatch.txt___jb_old___</span><br><span class="line">触发事件:rename</span><br><span class="line">文件名是: .idea/workspace.xml___jb_bak___</span><br><span class="line">触发事件:rename</span><br><span class="line">文件名是: .idea/workspace.xml</span><br><span class="line">触发事件:rename</span><br><span class="line">文件名是: .idea/workspace.xml___jb_old___</span><br></pre></td></tr></table></figure>

<h3 id="修改所有者"><a href="#修改所有者" class="headerlink" title="修改所有者"></a>修改所有者</h3><p>参考linux命令行，不举例子了。。。</p>
<blockquote>
<p>fs.chown(path, uid, gid, callback)<br>fs.chownSync(path, uid, gid)<br>fs.fchown(fd, uid, gid, callback)<br>fs.fchownSync(fd, uid, gid)</p>
</blockquote>
<h3 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h3><p>可以用<code>fs.chmod()</code>，也可以用<code>fs.fchmod()</code>。两者的区别在于，前面传的是文件路径，后面传的的文件句柄。</p>
<ol>
<li><code>fs.chmod)</code>、<code>fs.fchmod()</code>区别：传的是文件路径，还是文件句柄。</li>
<li><code>fs.chmod()</code>、<code>fs.lchmod()</code>区别：如果文件是软连接，那么<code>fs.chmod()</code>修改的是软连接指向的目标文件；<code>fs.lchmod()</code>修改的是软连接。</li>
</ol>
<blockquote>
<p>fs.chmod(path, mode, callback)<br>fs.chmodSync(path, mode)</p>
</blockquote>
<blockquote>
<p>fs.fchmod(fd, mode, callback)<br>fs.fchmodSync(fd, mode)</p>
</blockquote>
<blockquote>
<p>fs.lchmod(path, mode, callback)#<br>fs.lchmodSync(path, mode)</p>
</blockquote>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.chmod(<span class="string">'./fileForChown.txt'</span>, <span class="string">'777'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'权限修改成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同步版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">fs.chmodSync(&#39;.&#x2F;fileForChown.txt&#39;, &#39;777&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="获取文件状态"><a href="#获取文件状态" class="headerlink" title="获取文件状态"></a>获取文件状态</h3><p>区别：</p>
<ul>
<li><code>fs.stat()</code> vs <code>fs.fstat()</code>：传文件路径 vs 文件句柄。</li>
<li><code>fs.stat()</code> vs <code>fs.lstat()</code>：如果文件是软链接，那么<code>fs.stat()</code>返回目标文件的状态，<code>fs.lstat()</code>返回软链接本身的状态。</li>
</ul>
<blockquote>
<p>fs.stat(path, callback)<br>fs.statSync(path)</p>
</blockquote>
<blockquote>
<p>fs.fstat(fd, callback)<br>fs.fstatSync(fd)</p>
</blockquote>
<blockquote>
<p>fs.lstat(path, callback)<br>fs.lstatSync(path)</p>
</blockquote>
<p>主要关注<code>Class: fs.Stats</code>。</p>
<p>首先是方法</p>
<ul>
<li>stats.isFile()  – 是否文件</li>
<li>stats.isDirectory() – 是否目录</li>
<li>stats.isBlockDevice() – 什么鬼</li>
<li>stats.isCharacterDevice() – 什么鬼</li>
<li>stats.isSymbolicLink() (only valid with fs.lstat()) – 什么鬼</li>
<li>stats.isFIFO() – 什么鬼</li>
<li>stats.isSocket() – 是不是socket文件</li>
</ul>
<p>官网例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  dev: <span class="number">2114</span>,</span><br><span class="line">  ino: <span class="number">48064969</span>,</span><br><span class="line">  mode: <span class="number">33188</span>,</span><br><span class="line">  nlink: <span class="number">1</span>,</span><br><span class="line">  uid: <span class="number">85</span>,</span><br><span class="line">  gid: <span class="number">100</span>,</span><br><span class="line">  rdev: <span class="number">0</span>,</span><br><span class="line">  size: <span class="number">527</span>,</span><br><span class="line">  blksize: <span class="number">4096</span>,</span><br><span class="line">  blocks: <span class="number">8</span>,</span><br><span class="line">  atime: Mon, <span class="number">10</span> Oct <span class="number">2011</span> <span class="number">23</span>:<span class="number">24</span>:<span class="number">11</span> GMT, <span class="comment">// 访问时间</span></span><br><span class="line">  mtime: Mon, <span class="number">10</span> Oct <span class="number">2011</span> <span class="number">23</span>:<span class="number">24</span>:<span class="number">11</span> GMT,  <span class="comment">// 文件内容修改时间</span></span><br><span class="line">  ctime: Mon, <span class="number">10</span> Oct <span class="number">2011</span> <span class="number">23</span>:<span class="number">24</span>:<span class="number">11</span> GMT,  <span class="comment">// 文件状态修改时间</span></span><br><span class="line">  birthtime: Mon, <span class="number">10</span> Oct <span class="number">2011</span> <span class="number">23</span>:<span class="number">24</span>:<span class="number">11</span> GMT  <span class="comment">// 创建时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>atime：Access Time // 访问时间</li>
<li>mtime:: Modified Time  // 文件内容修改时间</li>
<li>ctime: Changed Time.  // 文件状态修改时间，比如修改文件所有者、修改权限、重命名等</li>
<li>birthtime: Birth Time // 创建时间。在某些系统上是不可靠的，因为拿不到。</li>
</ul>
<p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getTimeDesc = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [d.getFullYear(), d.getMonth()+<span class="number">1</span>, d.getDate()].join(<span class="string">'-'</span>) + <span class="string">' '</span> + [d.getHours(), d.getMinutes(), d.getSeconds()].join(<span class="string">':'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">fs.stat(<span class="string">'./fileForStat.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, stats</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件大小: '</span> + stats.size);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建时间: '</span> + getTimeDesc(stats.birthtime));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'访问时间: '</span> + getTimeDesc(stats.atime));</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'修改时间: '</span> + getTimeDesc(stats.mtime));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/node stat.js</span><br><span class="line">文件大小: <span class="number">3613</span></span><br><span class="line">创建时间: <span class="number">2016</span><span class="literal">-7</span><span class="literal">-16</span> <span class="number">12</span>:<span class="number">40</span>:<span class="number">49</span></span><br><span class="line">访问时间: <span class="number">2016</span><span class="literal">-7</span><span class="literal">-16</span> <span class="number">12</span>:<span class="number">40</span>:<span class="number">49</span></span><br><span class="line">修改时间: <span class="number">2016</span><span class="literal">-7</span><span class="literal">-16</span> <span class="number">12</span>:<span class="number">40</span>:<span class="number">49</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Process</span> finished with <span class="keyword">exit</span> code <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>同步的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getTimeDesc = <span class="function"><span class="keyword">function</span>(<span class="params">d</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [d.getFullYear(), d.getMonth()+<span class="number">1</span>, d.getDate()].join(<span class="string">'-'</span>) + <span class="string">' '</span> + [d.getHours(), d.getMinutes(), d.getSeconds()].join(<span class="string">':'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stats = fs.statSync(<span class="string">'./fileForStat.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'文件大小: '</span> + stats.size);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'创建时间: '</span> + getTimeDesc(stats.birthtime));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'访问时间: '</span> + getTimeDesc(stats.atime));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'修改时间: '</span> + getTimeDesc(stats.mtime));</span><br></pre></td></tr></table></figure>

<h3 id="访问-权限检测"><a href="#访问-权限检测" class="headerlink" title="访问/权限检测"></a>访问/权限检测</h3><p>例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.access(path[, mode], callback)</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.access(<span class="string">'./fileForAccess.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'可以访问'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>同步版本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fs.accessSync(path[, mode])</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果成功，则返回undefined，如果失败，则抛出错误（什么鬼）</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    fs.accessSync(<span class="string">'./fileForAccess.txt'</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    <span class="keyword">throw</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件打开-关闭"><a href="#文件打开-关闭" class="headerlink" title="文件打开/关闭"></a>文件打开/关闭</h3><p>比较底层的接口，实际需要用到的机会不多。需要用到的时候看下<a href="https://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback" target="_blank" rel="noopener">文档</a>就行。</p>
<ul>
<li>flags：文件打开模式，比如<code>r</code>、<code>r+</code>、<code>w</code>、<code>w+</code>等。可选模式非常多。</li>
<li>mode：默认是<code>666</code>，可读+可写。</li>
</ul>
<blockquote>
<p>fs.open(path, flags[, mode], callback)<br>fs.openSync(path, flags[, mode])<br>fs.close(fd, callback)<br>fs.closeSync(fd)</p>
</blockquote>
<h3 id="文件读取（底层）"><a href="#文件读取（底层）" class="headerlink" title="文件读取（底层）"></a>文件读取（底层）</h3><p>相对底层的读取接口，参数如下</p>
<ul>
<li>fd：文件句柄。</li>
<li>buffer：将读取的文件内容写到buffer里。</li>
<li>offset：buffer开始写入的位置。（在offset开始写入，还是offset+1？）</li>
<li>length：要读取的字节数。</li>
<li>position：文件从哪个位置开始读取。如果是null，那么就从当前位置开始读取。（读取操作会记录下上一个位置）</li>
</ul>
<p>此外，<code>callback</code>的回调参数为<code>(err, bytesRead, buffer)</code></p>
<blockquote>
<p>fs.read(fd, buffer, offset, length, position, callback)</p>
</blockquote>
<h3 id="追加文件内容"><a href="#追加文件内容" class="headerlink" title="追加文件内容"></a>追加文件内容</h3><blockquote>
<p>fs.appendFile(file, data[, options], callback)</p>
</blockquote>
<ul>
<li>file：可以是文件路径，也可以是文件句柄。（还可以是buffer？）</li>
<li>data：要追加的内容。string或者buffer。</li>
<li>options<ul>
<li>encoding：编码，默认是<code>utf8</code></li>
<li>mode：默认是<code>0o666</code></li>
<li>flag：默认是<code>a</code></li>
</ul>
</li>
</ul>
<p>注意：如果<code>file</code>是文件句柄，那么</p>
<ul>
<li>开始追加数据前，file需要已经打开。</li>
<li>file需要手动关闭。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.appendFile(<span class="string">'./extra/fileForAppend.txt'</span>, <span class="string">'helo'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'append成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="文件内容截取"><a href="#文件内容截取" class="headerlink" title="文件内容截取"></a>文件内容截取</h3><blockquote>
<p>fs.truncate(path, len, callback)<br>fs.truncateSync(path, len)</p>
<p>fs.ftruncate(fd, len, callback)<br>fs.ftruncateSync(fd, len)</p>
</blockquote>
<p>用途参考<a href="http://man7.org/linux/man-pages/man2/ftruncate.2.html" target="_blank" rel="noopener">linux说明文档</a>。</p>
<p>要点：</p>
<ul>
<li><code>offset</code>不会变化。比如通过<code>fs.read()</code>读取文件内容，就需要特别注意。</li>
<li>如果<code>len</code>小于文件内容长度，剩余文件内容部分会丢失；如果<code>len</code>大于文件内容长度，那么超出的部分，会用<code>\0</code>进行填充。</li>
<li>如果传的是文件路径，需要确保文件是可写的；如果传的是文件句柄，需要确保文件句柄已经打开并且可写入。</li>
</ul>
<blockquote>
<p>The truncate() and ftruncate() functions cause the regular file named<br>by path or referenced by fd to be truncated to a size of precisely<br>length bytes.</p>
</blockquote>
<blockquote>
<p>If the file previously was larger than this size, the extra data is<br>lost.  If the file previously was shorter, it is extended, and the<br>extended part reads as null bytes (‘\0’).</p>
</blockquote>
<blockquote>
<p>The file offset is not changed.</p>
</blockquote>
<blockquote>
<p>With ftruncate(), the file must be open for writing; with truncate(), the file must be writable.</p>
</blockquote>
<h3 id="修改文件属性（时间）"><a href="#修改文件属性（时间）" class="headerlink" title="修改文件属性（时间）"></a>修改文件属性（时间）</h3><ul>
<li>path/fd：文件路径/文件句柄</li>
<li>atime：Access Time。上一次访问文件数据的时间。</li>
<li>mtime：Modified Time。修改时间。</li>
</ul>
<blockquote>
<p>fs.utimes(path, atime, mtime, callback)<br>fs.utimesSync(path, atime, mtime)</p>
</blockquote>
<blockquote>
<p>fs.futimes(fd, atime, mtime, callback)<br>fs.futimesSync(fd, atime, mtime)</p>
</blockquote>
<p>备注，在命令行下可以</p>
<ul>
<li>通过<code>stat</code>查看文件的状态信息，包括了上面的atime、mtime。</li>
<li>通过<code>touch</code>修改这几个时间。</li>
</ul>
<h3 id="创建文件链接"><a href="#创建文件链接" class="headerlink" title="创建文件链接"></a>创建文件链接</h3><blockquote>
<p>fs.symlink(target, path[, type], callback)<br>fs.symlinkSync(target, path[, type])</p>
<p>fs.link(srcpath, dstpath, callback)<br>fs.linkSync(srcpath, dstpath)</p>
</blockquote>
<blockquote>
<p> link() creates a new link (also known as a hard link) to an existing file.</p>
</blockquote>
<p>软链接、硬链接区别：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/" target="_blank" rel="noopener">参考</a> 或者 [这个]。(<a href="http://www.cnblogs.com/itech/archive/2009/04/10/1433052.html" target="_blank" rel="noopener">http://www.cnblogs.com/itech/archive/2009/04/10/1433052.html</a>)</p>
<ul>
<li>硬链接：inode相同，多个别名。删除一个硬链接文件，不会影响其他有相同inode的文件。</li>
<li>软链接：有自己的inode，用户数据块存放指向文件的inode。</li>
</ul>
<p>参考<a href="http://man7.org/linux/man-pages/man2/link.2.html" target="_blank" rel="noopener">这里</a>。</p>
<h3 id="创建临时目录"><a href="#创建临时目录" class="headerlink" title="创建临时目录"></a>创建临时目录</h3><blockquote>
<p>fs.mkdtemp(prefix, callback)<br>fs.mkdtempSync(prefix)</p>
</blockquote>
<p>备忘：跟普通的随便找个目录，创建个随机名字的文件夹，有什么区别？</p>
<p>代码示例如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.mkdtemp(<span class="string">'/tmp/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, folder</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'创建临时目录: '</span> + folder);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/node mkdtemp.js</span><br><span class="line">创建临时目录: /tmp/Cxw51O</span><br></pre></td></tr></table></figure>

<h3 id="找出软连接指向的真实路径"><a href="#找出软连接指向的真实路径" class="headerlink" title="找出软连接指向的真实路径"></a>找出软连接指向的真实路径</h3><blockquote>
<p>fs.readlink(path[, options], callback)<br>fs.readlinkSync(path[, options])</p>
</blockquote>
<p>如下面例子，创建了个软链接指向<code>fileForReadLink.txt</code>，通过<code>fs.readlink()</code>就可以找出原始的路径。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> randomFileName = <span class="string">'./extra/fileForReadLink-'</span> + <span class="built_in">String</span>(<span class="built_in">Math</span>.random()).slice(<span class="number">2</span>, <span class="number">6</span>) + <span class="string">'.txt'</span>;</span><br><span class="line"></span><br><span class="line">fs.symlinkSync(<span class="string">'./extra/fileForReadLink.txt'</span>, randomFileName);</span><br><span class="line">fs.readlink(randomFileName, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, linkString</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'链接文件内容: '</span> + linkString);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>类似终端下直接运行<code>readlink</code>。对于软链接文件，效果同上面代码。对于硬链接，没有输出。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">➜  extra git:(master) ✗ readlink fileForReadLink<span class="literal">-9827</span>.txt</span><br><span class="line">./extra/fileForReadLink.txt</span><br><span class="line">➜  extra git:(master) ✗ readlink fileForLinkHard.txt </span><br><span class="line">➜  extra git:(master) ✗ readlink fileForLinkSoft.txt</span><br><span class="line">./extra/fileForLink.txt</span><br></pre></td></tr></table></figure>

<h3 id="真实路径"><a href="#真实路径" class="headerlink" title="真实路径"></a>真实路径</h3><blockquote>
<p>fs.realpath(path[, options], callback)<br>fs.realpathSync(path[, options])</p>
</blockquote>
<p>例子：（不能作用于软链接？）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fileForRealPath1.txt 是普通文件,正常运行</span></span><br><span class="line">fs.realpath(<span class="string">'./extra/inner/fileForRealPath1.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, resolvedPath</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fs.realpath: '</span> + resolvedPath);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// fileForRealPath.txt 是软链接, 会报错,提示找不到文件</span></span><br><span class="line">fs.realpath(<span class="string">'./extra/inner/fileForRealPath.txt'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, resolvedPath</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fs.realpath: '</span> + resolvedPath);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">'path.resolve: '</span> + path.resolve(<span class="string">'./extra/inner/fileForRealpath.txt'</span>) );</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">path.resolve: /Users/a/Documents/git<span class="literal">-code</span>/git<span class="literal">-blog</span>/demo/<span class="number">2015.05</span>.<span class="number">21</span><span class="literal">-node</span><span class="literal">-basic</span>/fs/extra/inner/fileForRealpath.txt</span><br><span class="line">fs.realpath: /Users/a/Documents/git<span class="literal">-code</span>/git<span class="literal">-blog</span>/demo/<span class="number">2015.05</span>.<span class="number">21</span><span class="literal">-node</span><span class="literal">-basic</span>/fs/extra/inner/fileForRealPath1.txt</span><br><span class="line">/Users/a/Documents/git<span class="literal">-code</span>/git<span class="literal">-blog</span>/demo/<span class="number">2015.05</span>.<span class="number">21</span><span class="literal">-node</span><span class="literal">-basic</span>/fs/realpath.js:<span class="number">12</span></span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">            ^</span><br><span class="line"></span><br><span class="line">Error: ENOENT: no such file or directory, realpath <span class="string">'./extra/inner/fileForRealPath.txt'</span></span><br><span class="line">    at Error (native)</span><br><span class="line"></span><br><span class="line"><span class="keyword">Process</span> finished with <span class="keyword">exit</span> code <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><blockquote>
<p>fs.rmdir(path, callback)<br>fs.rmdirSync(path)</p>
</blockquote>
<p>例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.rmdir(<span class="string">'./dirForRemove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'目录删除成功'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="不常用"><a href="#不常用" class="headerlink" title="不常用"></a>不常用</h3><h4 id="缓冲区内容写到磁盘"><a href="#缓冲区内容写到磁盘" class="headerlink" title="缓冲区内容写到磁盘"></a>缓冲区内容写到磁盘</h4><blockquote>
<p>fs.fdatasync(fd, callback)<br>fs.fdatasyncSync(fd)</p>
</blockquote>
<p>可以参考这里：</p>
<blockquote>
<p>1、sync函数<br>sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。<br>通常称为update的系统守护进程会周期性地（一般每隔30秒）调用sync函数。这就保证了定期冲洗内核的块缓冲区。命令sync(1)也调用sync函数。<br>2、fsync函数<br>fsync函数只对由文件描述符filedes指定的单一文件起作用，并且等待写磁盘操作结束，然后返回。<br>fsync可用于数据库这样的应用程序，这种应用程序需要确保将修改过的块立即写到磁盘上。<br>3、fdatasync函数<br>fdatasync函数类似于fsync，但它只影响文件的数据部分。而除数据外，fsync还会同步更新文件的属性。<br>对于提供事务支持的数据库，在事务提交时，都要确保事务日志（包含该事务所有的修改操作以及一个提交记录）完全写到硬盘上，才认定事务提交成功并返回给应用层。</p>
</blockquote>
<h2 id="06-网络服务-http"><a href="#06-网络服务-http" class="headerlink" title="06 网络服务-http"></a>06 网络服务-http</h2><p>大多数nodejs开发者都是冲着开发web server的目的选择了nodejs。正如官网所展示的，借助http模块，可以几行代码就搞定一个超迷你的web server。</p>
<p>在nodejs中，<code>http</code>可以说是最核心的模块，同时也是比较复杂的一个模块。上手很简单，但一旦深入学习，不少初学者就会觉得头疼，不知从何入手。</p>
<p>本文先从一个简单的例子出发，引出<code>http</code>模块最核心的四个实例。看完本文，应该就能够对http模块有个整体的认识。</p>
<h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>在下面的例子中，我们创建了1个web服务器、1个http客户端</p>
<ul>
<li>服务器server：接收来自客户端的请求，并将客户端请求的地址返回给客户端。</li>
<li>客户端client：向服务器发起请求，并将服务器返回的内容打印到控制台。</li>
</ul>
<p>代码如下所示，只有几行，但包含了不少信息量。下一小节会进行简单介绍。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http server 例子</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">serverReq, serverRes</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url = serverReq.url;</span><br><span class="line">    serverRes.end( <span class="string">'您访问的地址是：'</span> + url );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http client 例子</span></span><br><span class="line"><span class="keyword">var</span> client = http.get(<span class="string">'http://127.0.0.1:3000'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">clientRes</span>)</span>&#123;</span><br><span class="line">    clientRes.pipe(process.stdout);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="例子解释"><a href="#例子解释" class="headerlink" title="例子解释"></a>例子解释</h3><p>在上面这个简单的例子里，涉及了4个实例。大部分时候，serverReq、serverRes 才是主角。</p>
<ul>
<li>server：http.Server实例，用来提供服务，处理客户端的请求。</li>
<li>client：http.ClientReques实例，用来向服务端发起请求。</li>
<li>serverReq/clientRes：其实都是 http.IncomingMessage实。serverReq 用来获取客户端请求的相关信息，如request header；而clientRes用来获取服务端返回的相关信息，比如response header。</li>
<li>serverRes：http.ServerResponse实例</li>
</ul>
<h3 id="关于http-IncomingMessage、http-ServerResponse"><a href="#关于http-IncomingMessage、http-ServerResponse" class="headerlink" title="关于http.IncomingMessage、http.ServerResponse"></a>关于http.IncomingMessage、http.ServerResponse</h3><p>先讲下 http.ServerResponse 实例。作用很明确，服务端通过http.ServerResponse 实例，来个请求方发送数据。包括发送响应表头，发送响应主体等。</p>
<p>接下来是 http.IncomingMessage 实例，由于在 server、client 都出现了，初学者难免有点迷茫。它的作用是</p>
<p>在server端：获取请求发送方的信息，比如请求方法、路径、传递的数据等。<br>在client端：获取 server 端发送过来的信息，比如请求方法、路径、传递的数据等。</p>
<p>http.IncomingMessage实例 有三个属性需要注意：method、statusCode、statusMessage。</p>
<ul>
<li>method：只在 server 端的实例有（也就是 serverReq.method）</li>
<li>statusCode/statusMessage：只在 client 端 的实例有（也就是 clientRes.method）</li>
</ul>
<h3 id="关于继承与扩展"><a href="#关于继承与扩展" class="headerlink" title="关于继承与扩展"></a>关于继承与扩展</h3><h4 id="http-Server"><a href="#http-Server" class="headerlink" title="http.Server"></a>http.Server</h4><ul>
<li>http.Server 继承了 net.Server （于是顺带需要学一下 net.Server 的API、属性、相关事件）</li>
<li>net.createServer(fn)，回调中的 <code>socket</code> 是个双工的stream接口，也就是说，读取发送方信息、向发送方发送信息都靠他。</li>
</ul>
<p>备注：socket的客户端、服务端是相对的概念，所以其实 net.Server 内部也是用了 net.Socket（不负责任猜想）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参考：https://cnodejs.org/topic/4fb1c1fd1975fe1e1310490b</span></span><br><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> PORT = <span class="number">8989</span>;</span><br><span class="line"><span class="keyword">var</span> HOST = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">socket</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Connected: '</span> + socket.remoteAddress + <span class="string">':'</span> + socket.remotePort);</span><br><span class="line">    </span><br><span class="line">    socket.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'DATA '</span> + socket.remoteAddress + <span class="string">': '</span> + data);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Data is: '</span> + data);</span><br><span class="line"></span><br><span class="line">        socket.write(<span class="string">'Data from you is  "'</span> + data + <span class="string">'"'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    socket.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'CLOSED: '</span> +</span><br><span class="line">            socket.remoteAddress + <span class="string">' '</span> + socket.remotePort);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(PORT, HOST);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(server <span class="keyword">instanceof</span> net.Server);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="http-ClientRequest"><a href="#http-ClientRequest" class="headerlink" title="http.ClientRequest"></a>http.ClientRequest</h4><p>http.ClientRequest 内部创建了一个socket来发起请求，<a href="https://github.com/nodejs/node/blob/master/lib/_http_client.js#L174" target="_blank" rel="noopener">代码如下</a>。</p>
<p>当你调用 http.request(options) 时，内部是这样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">self.onSocket(net.createConnection(options));</span><br></pre></td></tr></table></figure>

<h4 id="http-ServerResponse"><a href="#http-ServerResponse" class="headerlink" title="http.ServerResponse"></a>http.ServerResponse</h4><ul>
<li>实现了 Writable Stream interface，内部也是通过socket来发送信息。</li>
</ul>
<h4 id="http-IncomingMessage"><a href="#http-IncomingMessage" class="headerlink" title="http.IncomingMessage"></a>http.IncomingMessage</h4><ul>
<li>实现了 Readable Stream interface，参考<a href="https://github.com/nodejs/node/blob/master/lib/_http_incoming.js#L62" target="_blank" rel="noopener">这里</a></li>
<li>req.socket –&gt; 获得跟这次连接相关的socket</li>
</ul>
<h2 id="07-网络服务-http-req请求"><a href="#07-网络服务-http-req请求" class="headerlink" title="07 网络服务 http-req请求"></a>07 网络服务 http-req请求</h2><h3 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h3><p>本文的重点会放在<code>req</code>这个对象上。前面已经提到，它其实是http.IncomingMessage实例，在服务端、客户端作用略微有差异</p>
<ul>
<li>服务端处：获取请求方的相关信息，如request header等。</li>
<li>客户端处：获取响应方返回的相关信息，如statusCode等。</li>
</ul>
<p>服务端例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的 req</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(req.headers);</span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>客户端例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的res</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.get(<span class="string">'http://127.0.0.1:3000'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.statusCode);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="属性-方法-事件-分类"><a href="#属性-方法-事件-分类" class="headerlink" title="属性/方法/事件 分类"></a>属性/方法/事件 分类</h3><p>http.IncomingMessage的属性/方法/事件 不是特别多，按照是否客户端/服务端 特有的，下面进行简单归类。可以看到</p>
<ul>
<li>服务端处特有：url</li>
<li>客户端处特有：statusCode、statusMessage</li>
</ul>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="center">名称</th>
<th align="center">服务端</th>
<th align="center">客户端</th>
</tr>
</thead>
<tbody><tr>
<td align="left">事件</td>
<td align="center">aborted</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="left">事件</td>
<td align="center">close</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="left">属性</td>
<td align="center">headers</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="left">属性</td>
<td align="center">rawHeaders</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="left">属性</td>
<td align="center">statusCode</td>
<td align="center">✕</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="left">属性</td>
<td align="center">statusMessage</td>
<td align="center">✕</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="left">属性</td>
<td align="center">httpVersion</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="left">属性</td>
<td align="center">httpVersion</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="left">属性</td>
<td align="center">url</td>
<td align="center">✓</td>
<td align="center">✕</td>
</tr>
<tr>
<td align="left">属性</td>
<td align="center">socket</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="left">方法</td>
<td align="center">.destroy()</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
<tr>
<td align="left">方法</td>
<td align="center">.setTimeout()</td>
<td align="center">✓</td>
<td align="center">✓</td>
</tr>
</tbody></table>
<h3 id="服务端的例子"><a href="#服务端的例子" class="headerlink" title="服务端的例子"></a>服务端的例子</h3><h4 id="例子一：获取httpVersion-method-url"><a href="#例子一：获取httpVersion-method-url" class="headerlink" title="例子一：获取httpVersion/method/url"></a>例子一：获取httpVersion/method/url</h4><p>下面是一个典型的HTTP请求报文，里面最重要的内容包括：HTTP版本、请求方法、请求地址、请求头部。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/hello</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 127.0.0.1:3000</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br></pre></td></tr></table></figure>

<p>那么，如何获取上面提到的信息呢？很简单，直接上代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getClientInfo.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'1、客户端请求url：'</span> + req.url );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'2、http版本：'</span> + req.httpVersion );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'3、http请求方法：'</span> + req.method );</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">'4、http请求头部'</span> + <span class="built_in">JSON</span>.stringify(req.headers) );</span><br><span class="line"></span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、客户端请求url：/hello</span><br><span class="line">2、http版本：1.1</span><br><span class="line">3、http请求方法：GET</span><br><span class="line">4、http headers：&#123;<span class="string">"host"</span>:<span class="string">"127.0.0.1:3000"</span>,<span class="string">"connection"</span>:<span class="string">"keep-alive"</span>,<span class="string">"cache-control"</span>:<span class="string">"no-cache"</span>,<span class="string">"user-agent"</span>:<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36"</span>,<span class="string">"postman-token"</span>:<span class="string">"1148986a-ddfb-3569-e2c0-585634655fe4"</span>,<span class="string">"accept"</span>:<span class="string">"*/*"</span>,<span class="string">"accept-encoding"</span>:<span class="string">"gzip, deflate, sdch, br"</span>,<span class="string">"accept-language"</span>:<span class="string">"zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4"</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例子二：获取get请求参数"><a href="#例子二：获取get请求参数" class="headerlink" title="例子二：获取get请求参数"></a>例子二：获取get请求参数</h4><p>服务端代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getClientGetQuery.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> urlObj = url.parse(req.url);</span><br><span class="line">    <span class="keyword">var</span> query = urlObj.query;</span><br><span class="line">    <span class="keyword">var</span> queryObj = querystring.parse(query);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(queryObj) );</span><br><span class="line">    </span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>访问地址 <a href="http://127.0.0.1:3000/hello?nick=chyingp&amp;hello=world" target="_blank" rel="noopener">http://127.0.0.1:3000/hello?nick=chyingp&amp;hello=world</a></p>
<p>服务端输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"nick"</span>:<span class="string">"chyingp"</span>,<span class="string">"hello"</span>:<span class="string">"world"</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="例子三：获取post请求参数"><a href="#例子三：获取post请求参数" class="headerlink" title="例子三：获取post请求参数"></a>例子三：获取post请求参数</h4><p>服务端代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getClientPostBody.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body = <span class="string">''</span>;  </span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">thunk</span>)</span>&#123;</span><br><span class="line">        body += thunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'post body is: '</span> + body );</span><br><span class="line">        res.end(<span class="string">'ok'</span>);</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>通过curl构造post请求：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">'nick=casper&amp;hello=world'</span> http://127.0.0.1:3000</span><br></pre></td></tr></table></figure>

<p>服务端打印如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">post body is: nick=casper&amp;hello=world</span><br></pre></td></tr></table></figure>

<p>备注：post请求中，不同的<code>Content-type</code>，post body有不小差异，感兴趣的同学可以研究下。</p>
<p>本例中的post请求，HTTP报文大概如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 127.0.0.1:3000</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br><span class="line"></span><br><span class="line">nick=casper&amp;hello=world</span><br></pre></td></tr></table></figure>

<h3 id="客户端处例子"><a href="#客户端处例子" class="headerlink" title="客户端处例子"></a>客户端处例子</h3><h4 id="例子一：获取httpVersion-statusCode-statusMessage"><a href="#例子一：获取httpVersion-statusCode-statusMessage" class="headerlink" title="例子一：获取httpVersion/statusCode/statusMessage"></a>例子一：获取httpVersion/statusCode/statusMessage</h4><p>代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'content-type'</span>: <span class="string">'text/plain'</span>,&#125;);</span><br><span class="line">    res.end(<span class="string">'from server'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = http.get(<span class="string">'http://127.0.0.1:3000'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1、http版本：'</span> + res.httpVersion);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2、返回状态码：'</span> + res.statusCode);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3、返回状态描述信息：'</span> + res.statusMessage);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4、返回正文：'</span>);</span><br><span class="line"></span><br><span class="line">    res.pipe(process.stdout);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、http版本：1.1</span><br><span class="line">2、返回状态码：200</span><br><span class="line">3、返回状态描述信息：OK</span><br><span class="line">4、返回正文：</span><br><span class="line">from server</span><br></pre></td></tr></table></figure>

<h3 id="事件对比：aborted、close"><a href="#事件对比：aborted、close" class="headerlink" title="事件对比：aborted、close"></a>事件对比：aborted、close</h3><p>官方文档对这两个事件的解释是：当客户端终止请求时，触发aborted事件；当客户端连接断开时，触发close事件；官方文档传送们：<a href="https://nodejs.org/api/http.html#http_event_aborted_1" target="_blank" rel="noopener">地址</a></p>
<p>解释得比较含糊，从实际实验对比上来看，跟官方文档有不小出入。此外，客户端处、服务端处的表现也是不同的。</p>
<h4 id="服务端表现"><a href="#服务端表现" class="headerlink" title="服务端表现"></a>服务端表现</h4><p>根据实际测试结果来看，当客户端：</p>
<ul>
<li>abort请求时，服务端req的aborted、close事件都会触发；（诡异）</li>
<li>请求正常完成时，服务端req的close事件不会触发；（也很诡异）</li>
</ul>
<p>直接扒了下nodejs的源代码，发现的确是同时触发的，触发场景：请求正常结束前，客户端abort请求。</p>
<p>测试代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1、收到客户端请求: '</span> + req.url);</span><br><span class="line">    </span><br><span class="line">    req.on(<span class="string">'aborted'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'2、客户端请求aborted'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    req.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'3、客户端请求close'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// res.end('ok'); 故意不返回，等着客户端中断请求</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> client = http.get(<span class="string">'http://127.0.0.1:3000/aborted'</span>);</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        client.abort();  <span class="comment">// 故意延迟100ms，确保请求发出</span></span><br><span class="line">    &#125;, <span class="number">100</span>);    </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下</span></span><br><span class="line"><span class="comment">// 1、收到客户端请求: /aborted</span></span><br><span class="line"><span class="comment">// 2、客户端请求aborted</span></span><br><span class="line"><span class="comment">// 3、客户端请求close</span></span><br></pre></td></tr></table></figure>

<p>以下代码来自nodejs源码（_http_server.js）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abortIncoming</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (incoming.length) &#123;</span><br><span class="line">    <span class="keyword">var</span> req = incoming.shift();</span><br><span class="line">    req.emit(<span class="string">'aborted'</span>);</span><br><span class="line">    req.emit(<span class="string">'close'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// abort socket._httpMessage ?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来一波对比，<code>req.on(&#39;close&#39;)</code>和<code>req.socket.on(&#39;close&#39;)</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// reqSocketClose.js</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'server: 收到客户端请求'</span>);</span><br><span class="line">    </span><br><span class="line">    req.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'server: req close'</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    req.socket.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'server: req.socket close'</span>);</span><br><span class="line">    &#125;);    </span><br><span class="line">    </span><br><span class="line">    res.end(<span class="string">'ok'</span>); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = http.get(<span class="string">'http://127.0.0.1:3000/aborted'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'client: 收到服务端响应'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出如下，正儿八经的close事件触发了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server: 收到客户端请求</span><br><span class="line">server: req.socket close</span><br><span class="line">client: 收到服务端响应</span><br></pre></td></tr></table></figure>

<h4 id="客户端表现"><a href="#客户端表现" class="headerlink" title="客户端表现"></a>客户端表现</h4><p>猜测客户端的aborted、close也是在类似场景下触发，测试代码如下。发现一个比较有意思的情况，<code>res.pipe(process.stdout)</code> 这行代码是否添加，会影响<code>close</code>是否触发。</p>
<ul>
<li>没有<code>res.pipe(process.stdout)</code>：close不触发。</li>
<li>有<code>res.pipe(process.stdout)</code>：close触发。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1、服务端：收到客户端请求'</span>);</span><br><span class="line">    </span><br><span class="line">    res.flushHeaders();</span><br><span class="line">    res.setTimeout(<span class="number">100</span>);    <span class="comment">// 故意不返回，3000ms后超时</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> client = http.get(<span class="string">'http://127.0.0.1:3000/aborted'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'2、客户端：收到服务端响应'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// res.pipe(process.stdout); 注意这行代码</span></span><br><span class="line">        </span><br><span class="line">        res.on(<span class="string">'aborted'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'3、客户端：aborted触发！'</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        res.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'4、客户端：close触发！'</span>);</span><br><span class="line">        &#125;);     </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="信息量略大的-destroy"><a href="#信息量略大的-destroy" class="headerlink" title="信息量略大的 .destroy()"></a>信息量略大的 .destroy()</h3><p>经过前面aborted、close的摧残，本能的觉得 .destroy() 方法的表现会有很多惊喜之处。</p>
<p>测试代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务端：收到客户端请求'</span>);</span><br><span class="line">    </span><br><span class="line">    req.destroy(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'测试destroy'</span>));</span><br><span class="line">    </span><br><span class="line">    req.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'服务端：req error: '</span> + error.message);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    req.socket.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'服务端：req socket error: '</span> + error.message);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'服务端：server error: '</span> + error.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> client = http.get(<span class="string">'http://127.0.0.1:3000/aborted'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    client.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'客户端：client error触发！'</span> + error.message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>输出如下。根据 .destroy() 调用的时机不同，error 触发的对象不同。（测试过程比较枯燥，有时间再总结一下）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">服务端：收到客户端请求</span><br><span class="line">服务端：req socket error: 测试destroy</span><br><span class="line">客户端：client error触发！socket hang up</span><br></pre></td></tr></table></figure>

<h3 id="不常用属性"><a href="#不常用属性" class="headerlink" title="不常用属性"></a>不常用属性</h3><ul>
<li>rawHeaders：未解析前的request header。</li>
<li>trailers：在分块传输编码(chunk)中用到，表示trailer后的header可分块传输。（感兴趣的可以研究下）</li>
<li>rawTrailers：</li>
</ul>
<p>关于trailers属性：</p>
<blockquote>
<p>The request/response trailers object. Only populated at the ‘end’ event.</p>
</blockquote>
<h3 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h3><p>一个貌似很简单的对象，实际比想的要复杂一些。做了不少对比实验，也发现了一些好玩的东西，打算深入学习的同学可以自己多动手尝试一下 :)</p>
<p>TODO：</p>
<ol>
<li>对close、aborted进行更深入对比</li>
<li>对.destroy()进行更深入对比</li>
</ol>
<h2 id="08-网络服务-http-res响应"><a href="#08-网络服务-http-res响应" class="headerlink" title="08 网络服务 http-res响应"></a>08 网络服务 http-res响应</h2><h3 id="概览-1"><a href="#概览-1" class="headerlink" title="概览"></a>概览</h3><p>http模块四剑客之一的<code>res</code>，应该都不陌生了。一个web服务程序，接受到来自客户端的http请求后，向客户端返回正确的响应内容，这就是<code>res</code>的职责。</p>
<p>返回的内容包括：状态代码/状态描述信息、响应头部、响应主体。下文会举几个简单的例子。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.send(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>在下面的例子中，我们同时设置了 状态代码/状态描述信息、响应头部、响应主体，就是这么简单。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置状态码、状态描述信息、响应主体</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, <span class="string">'ok'</span>, &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end(<span class="string">'hello'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="设置状态代码、状态描述信息"><a href="#设置状态代码、状态描述信息" class="headerlink" title="设置状态代码、状态描述信息"></a>设置状态代码、状态描述信息</h4><p><code>res</code>提供了 res.writeHead()、res.statusCode/res.statusMessage 来实现这个目的。</p>
<p>举例，如果想要设置 200/ok ，可以</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.writeHead(<span class="number">200</span>, <span class="string">'ok'</span>);</span><br></pre></td></tr></table></figure>

<p>也可以</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.statusCode = <span class="number">200</span>;</span><br><span class="line">res.statusMessage = <span class="string">'ok'</span>;</span><br></pre></td></tr></table></figure>

<p>两者差不多，差异点在于</p>
<ol>
<li>res.writeHead() 可以提供额外的功能，比如设置响应头部。</li>
<li>当响应头部发送出去后，res.statusCode/res.statusMessage 会被设置成已发送出去的 状态代码/状态描述信息。</li>
</ol>
<h4 id="设置响应头部"><a href="#设置响应头部" class="headerlink" title="设置响应头部"></a>设置响应头部</h4><p><code>res</code>提供了 res.writeHead()、response.setHeader() 来实现响应头部的设置。</p>
<p>举例，比如想把 <code>Content-Type</code> 设置为 <code>text-plain</code>，那么可以</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">res.writeHead(<span class="number">200</span>, <span class="string">'ok'</span>, &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'text-plain'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text-plain'</span>);</span><br></pre></td></tr></table></figure>

<p>两者的差异点在哪里呢？</p>
<ol>
<li>res.writeHead() 不单单是设置header。</li>
<li>已经通过 res.setHeader() 设置了header，当通过 res.writeHead() 设置同名header，res.writeHead() 的设置会覆盖之前的设置。</li>
</ol>
<p>关于第2点差异，这里举个例子。下面代码，最终的 <code>Content-Type</code> 为 <code>text/plain</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>);</span><br><span class="line">    res.writeHead(<span class="number">200</span>, <span class="string">'ok'</span>, &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end(<span class="string">'hello'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>而下面的例子，则直接报错。报错信息为 <code>Error: Can&#39;t set headers after they are sent.</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;    </span><br><span class="line">    res.writeHead(<span class="number">200</span>, <span class="string">'ok'</span>, &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>);</span><br><span class="line">    res.end(<span class="string">'hello'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="其他响应头部操作"><a href="#其他响应头部操作" class="headerlink" title="其他响应头部操作"></a>其他响应头部操作</h4><p>增、删、改、查 是配套的。下面分别举例说明下，例子太简单就直接上代码了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 增</span></span><br><span class="line">res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删</span></span><br><span class="line">res.removeHeader(<span class="string">'Content-Type'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line">res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line">res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>);  <span class="comment">// 覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查</span></span><br><span class="line">res.getHeader(<span class="string">'content-type'</span>);</span><br></pre></td></tr></table></figure>

<p>其中略显不同的是 res.getHeader(name)，name 用的是小写，返回值没做特殊处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'TEXT/HTML'</span>);</span><br><span class="line"><span class="built_in">console</span>.log( res.getHeader(<span class="string">'content-type'</span>) );  <span class="comment">// TEXT/HTML</span></span><br><span class="line"></span><br><span class="line">res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/plain'</span>);</span><br><span class="line"><span class="built_in">console</span>.log( res.getHeader(<span class="string">'content-type'</span>) );  <span class="comment">// text/plain</span></span><br></pre></td></tr></table></figure>

<p>此外，还有不那么常用的：</p>
<ul>
<li>res.headersSent：header是否已经发送；</li>
<li>res.sendDate：默认为true。但为true时，会在response header里自动设置Date首部。</li>
</ul>
<h3 id="设置响应主体"><a href="#设置响应主体" class="headerlink" title="设置响应主体"></a>设置响应主体</h3><p>主要用到 res.write() 以及 res.end() 两个方法。</p>
<p>res.write() API的信息量略大，建议看下<a href="https://nodejs.org/api/http.html#http_response_write_chunk_encoding_callback" target="_blank" rel="noopener">官方文档</a>。</p>
<h4 id="response-write-chunk-encoding-callback"><a href="#response-write-chunk-encoding-callback" class="headerlink" title="response.write(chunk[, encoding][, callback])"></a>response.write(chunk[, encoding][, callback])</h4><ul>
<li>chunk：响应主体的内容，可以是string，也可以是buffer。当为string时，encoding参数用来指明编码方式。（默认是utf8）</li>
<li>encoding：编码方式，默认是 utf8。</li>
<li>callback：当响应体flushed时触发。（TODO 这里想下更好的解释。。。）</li>
</ul>
<p>使用上没什么难度，只是有些注意事项：</p>
<ol>
<li>如果 res.write() 被调用时， res.writeHead() 还没被调用过，那么，就会把header flush出去。</li>
<li>res.write() 可以被调用多次。</li>
<li>当 res.write(chunk) 第一次被调用时，node 会将 header 信息 以及 chunk 发送到客户端。第二次调用 res.write(chunk) ，node 会认为你是要streaming data（WTF，该怎么翻译）。。。</li>
</ol>
<blockquote>
<p>Returns true if the entire data was flushed successfully to the kernel buffer. Returns false if all or part of the data was queued in user memory. ‘drain’ will be emitted when the buffer is free again.</p>
</blockquote>
<h4 id="response-end-data-encoding-callback"><a href="#response-end-data-encoding-callback" class="headerlink" title="response.end([data][, encoding][, callback])"></a>response.end([data][, encoding][, callback])</h4><p>掌握了 res.write() 的话，res.end() 就很简单了。res.end() 的用处是告诉nodejs，header、body都给你了，这次响应就到这里吧。</p>
<p>有点像个语法糖，可以看成下面两个调用的组合。至于callback，当响应传递结束后触发。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.write(data, encoding);</span><br><span class="line">res.end()</span><br></pre></td></tr></table></figure>

<h3 id="chunk数据"><a href="#chunk数据" class="headerlink" title="chunk数据"></a>chunk数据</h3><p>参考这里：<a href="http://stackoverflow.com/questions/6258210/how-can-i-output-data-before-i-end-the-response" target="_blank" rel="noopener">http://stackoverflow.com/questions/6258210/how-can-i-output-data-before-i-end-the-response</a></p>
<p>也就是说，除了nodejs的特性，还需要了解 HTTP协议、浏览器的具体实现。（细思极恐）</p>
<p>如果是 <code>text/html</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;    </span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html; charset=utf-8'</span>);</span><br><span class="line">    res.write(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        res.write(<span class="string">' world!'</span>);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>如果是 <code>text/plain</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/plain; charset=utf-8'</span>,</span><br><span class="line">        <span class="string">'X-Content-Type-Options'</span>: <span class="string">'nosniff'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="string">'hello'</span>);</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.write(<span class="string">'world'</span>);</span><br><span class="line">        res.end()</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>失败例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, <span class="string">'ok'</span>, &#123;</span><br><span class="line">        <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(<span class="string">'hello'</span>);</span><br><span class="line">    </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        res.write(<span class="string">'world'</span>);</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="超时处理"><a href="#超时处理" class="headerlink" title="超时处理"></a>超时处理</h3><p>接口：response.setTimeout(msecs, callback)</p>
<p>关于 timeout 事件的说明，同样是言简意赅（WTF），话少信息量大，最好来个demo TODO</p>
<blockquote>
<p>If no ‘timeout’ listener is added to the request, the response, or the server, then sockets are destroyed when they time out. If you assign a handler on the request, the response, or the server’s ‘timeout’ events, then it is your responsibility to handle timed out sockets.</p>
</blockquote>
<h3 id="事件-close-finish"><a href="#事件-close-finish" class="headerlink" title="事件 close/finish"></a>事件 close/finish</h3><ul>
<li>close：response.end() 被调用前，连接就断开了。此时会触发这个事件。</li>
<li>finish：响应header、body都已经发送出去（交给操作系统，排队等候传输），但客户端是否实际收到数据为止。（这个事件后，res 上就不会再有其他事件触发）</li>
</ul>
<h3 id="其他不常用属性-方法"><a href="#其他不常用属性-方法" class="headerlink" title="其他不常用属性/方法"></a>其他不常用属性/方法</h3><ul>
<li>response.finished：一开始是false，响应结束后，设置为true。</li>
<li>response.sendDate：默认是true。是否自动设置Date头部。（按HTTP协议是必须要的，除非是调试用，不然不要设置为false）</li>
<li>response.headersSent：只读属性。响应头部是否已发送。</li>
<li>response.writeContinue()：发送  HTTP/1.1 100 Continue 消息给客户端，提示说服务端愿意接受客户端的请求，请继续发送请求正文（body)。（TODO 做个demo啥的是大大的好）</li>
</ul>
<h2 id="09-网络服务-http-client"><a href="#09-网络服务-http-client" class="headerlink" title="09 网络服务-http-client"></a>09 网络服务-http-client</h2><h3 id="ClientRequest概览"><a href="#ClientRequest概览" class="headerlink" title="ClientRequest概览"></a>ClientRequest概览</h3><p>当你调用 http.request(options) 时，会返回 ClientRequest实例，主要用来创建HTTP客户端请求。</p>
<p>在前面的章节里，已经对http模块的的其他方面进行了不少介绍，如http.Server、http.ServerResponse、http.IncomingMessage。</p>
<p>有了前面的基础，详细本文不难理解，本文更多的以例子为主。</p>
<h3 id="简单的GET请求"><a href="#简单的GET请求" class="headerlink" title="简单的GET请求"></a>简单的GET请求</h3><p>下面构造了个GET请求，访问 <a href="http://id.qq.com/" target="_blank" rel="noopener">http://id.qq.com/</a> ，并将返回的网页内容打印在控制台下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">    protocol: <span class="string">'http:'</span>,</span><br><span class="line">    hostname: <span class="string">'id.qq.com'</span>,</span><br><span class="line">    port: <span class="string">'80'</span>,</span><br><span class="line">    path: <span class="string">'/'</span>,</span><br><span class="line">    method: <span class="string">'GET'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">    res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">    res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        data += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.end();</span><br></pre></td></tr></table></figure>

<p>当然，也可以用便捷方法 http.get(options) 进行重写</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.get(<span class="string">'http://id.qq.com/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">    res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">    res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        data += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="简单的post请求"><a href="#简单的post请求" class="headerlink" title="简单的post请求"></a>简单的post请求</h3><p>在下面例子中，首先创建了个http server，负责将客户端发送过来的数据回传。</p>
<p>接着，创建客户端POST请求，向服务端发送数据。需要注意的点有：</p>
<ol>
<li>method 指定为 POST。</li>
<li>headers 里声明了 content-type 为 application/x-www-form-urlencoded。</li>
<li>数据发送前，用 querystring.stringify(obj) 对传输的对象进行了格式化。</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> createClientPostRequest = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options = &#123;</span><br><span class="line">        method: <span class="string">'POST'</span>,</span><br><span class="line">        protocol: <span class="string">'http:'</span>,</span><br><span class="line">        hostname: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        port: <span class="string">'3000'</span>,</span><br><span class="line">        path: <span class="string">'/post'</span>,</span><br><span class="line">        headers: &#123;</span><br><span class="line">            <span class="string">"connection"</span>: <span class="string">"keep-alive"</span>,</span><br><span class="line">            <span class="string">"content-type"</span>: <span class="string">"application/x-www-form-urlencoded"</span></span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送给服务端的数据</span></span><br><span class="line">    <span class="keyword">var</span> postBody = &#123;</span><br><span class="line">        nick: <span class="string">'chyingp'</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建客户端请求</span></span><br><span class="line">    <span class="keyword">var</span> client = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 最终输出：Server got client data: nick=chyingp</span></span><br><span class="line">        res.pipe(process.stdout);  </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送的报文主体，记得先用 querystring.stringify() 处理下</span></span><br><span class="line">    client.write( querystring.stringify(postBody) );</span><br><span class="line">    client.end();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务端程序，只是负责回传客户端数据</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.write(<span class="string">'Server got client data: '</span>);</span><br><span class="line">    req.pipe(res);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, createClientPostRequest);</span><br></pre></td></tr></table></figure>

<h3 id="各种事件"><a href="#各种事件" class="headerlink" title="各种事件"></a>各种事件</h3><p>在官方文档里，http.RequestClient相关的事件共有7个。跟HTTP协议密切相关的有3个，分别是 connect、continue、upgrade，其他4个分别是 abort、aborted、socket、response。</p>
<ul>
<li>其他：abort、aborted、socket、response</li>
<li>与HTTP协议相关：connect、continue、upgrade</li>
</ul>
<p>跟HTTP协议相关的会相对复杂些，因为涉及HTTP协议的设计细节。其他3个相对简单。下面分别进行简单的介绍。</p>
<h4 id="response事件"><a href="#response事件" class="headerlink" title="response事件"></a>response事件</h4><p>最容易理解的一个，当收到来自服务端的响应时触发，其实跟 http.get(url, cbk) 中的回调是一样的，看下程序运行的打印信息就知道。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'http://id.qq.com/'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = http.get(url, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1. response event'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">'response'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2. response event'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.end();</span><br></pre></td></tr></table></figure>

<p>打印信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. response event</span><br><span class="line">2. response event</span><br></pre></td></tr></table></figure>

<h4 id="socket事件"><a href="#socket事件" class="headerlink" title="socket事件"></a>socket事件</h4><p>当给client分配socket的时候触发，如果熟悉net模块对这个事件应该不陌生。大部分时候并不需要关注这个事件，虽然内部其实挺复杂的。</p>
<h4 id="abort-aborted-事件"><a href="#abort-aborted-事件" class="headerlink" title="abort/aborted 事件"></a>abort/aborted 事件</h4><p>这两个事件看着非常像，都是请求中断时触发，差异在于中断的发起方：</p>
<ul>
<li>abort：客户端主动中断请求（第一次调用 client.abort() 时触发）</li>
<li>aborted：服务端主动中断请求，且请求已经中断时触发。</li>
</ul>
<h4 id="continue事件"><a href="#continue事件" class="headerlink" title="continue事件"></a>continue事件</h4><p>当收到服务端的响应 <code>100 Continue</code> 时触发。熟悉HTTP协议的同学应该对 <code>100 Continue</code> 有所了解。当客户端向服务端发送首部 <code>Expect: 100-continue</code> ，服务端经过一定的校验后，决定对客户端的后续请求放行，于是返回返回 <code>100 Continue</code>，知会客户端，可以继续发送数据。（request body）</p>
<h4 id="upgrade事件"><a href="#upgrade事件" class="headerlink" title="upgrade事件"></a>upgrade事件</h4><p>同样是跟HTTP协议密切相关。当客户端向客户端发起请求时，可以在请求首部里声明 <code>&#39;Connection&#39;: &#39;Upgrade&#39;</code> ，以此要求服务端，将当前连接升级到新的协议。如果服务器同意，那么就升级协议继续通信。这里不打算展开太多细节，直接上官方文档的代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an HTTP server</span></span><br><span class="line"><span class="keyword">var</span> srv = http.createServer( <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'okay'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">srv.on(<span class="string">'upgrade'</span>, (req, socket, head) =&gt; &#123;</span><br><span class="line">  socket.write(<span class="string">'HTTP/1.1 101 Web Socket Protocol Handshake\r\n'</span> +</span><br><span class="line">               <span class="string">'Upgrade: WebSocket\r\n'</span> +</span><br><span class="line">               <span class="string">'Connection: Upgrade\r\n'</span> +</span><br><span class="line">               <span class="string">'\r\n'</span>);</span><br><span class="line"></span><br><span class="line">  socket.pipe(socket); <span class="comment">// echo back</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// now that server is running</span></span><br><span class="line">srv.listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>, () =&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// make a request</span></span><br><span class="line">  <span class="keyword">var</span> options = &#123;</span><br><span class="line">    port: <span class="number">1337</span>,</span><br><span class="line">    hostname: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Connection'</span>: <span class="string">'Upgrade'</span>,</span><br><span class="line">      <span class="string">'Upgrade'</span>: <span class="string">'websocket'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> req = http.request(options);</span><br><span class="line">  req.end();</span><br><span class="line"></span><br><span class="line">  req.on(<span class="string">'upgrade'</span>, (res, socket, upgradeHead) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'got upgraded!'</span>);</span><br><span class="line">    socket.end();</span><br><span class="line">    process.exit(<span class="number">0</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除了上面讲解到的属性、方法、事件外，还有下面方法没有讲到。并不是它们不重要，篇幅有限，后面再展开。</p>
<ul>
<li>client.abort()：中断请求；</li>
<li>client.setTimeout(timeout)：请求超时设置；</li>
<li>client.flushHeaders() 及早将请求首部发送出去；</li>
<li>client.setSocketKeepAlive()：当内部分配 socket 并连接上时，就会内部调用 socket.keepAlive()；</li>
<li>client.setNoDelay([noDelay])：当内部分配 socket 并连接上时，就会内部调用 socket.setNoDelay()；</li>
</ul>
<h2 id="10-网络服务-http-server"><a href="#10-网络服务-http-server" class="headerlink" title="10 网络服务-http-server"></a>10 网络服务-http-server</h2><h3 id="http服务端概览"><a href="#http服务端概览" class="headerlink" title="http服务端概览"></a>http服务端概览</h3><h3 id="创建server"><a href="#创建server" class="headerlink" title="创建server"></a>创建server</h3><p>几行代码搞定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> requestListener = <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> server = http.createServer(requestListener);</span><br><span class="line"><span class="comment">// var server = new http.Server(requestListener); 跟上面是等价的</span></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<h3 id="获取请求方信息"><a href="#获取请求方信息" class="headerlink" title="获取请求方信息"></a>获取请求方信息</h3><h4 id="HTTP版本、HTTP-method、headers、url"><a href="#HTTP版本、HTTP-method、headers、url" class="headerlink" title="HTTP版本、HTTP method、headers、url"></a>HTTP版本、HTTP method、headers、url</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'客户端请求url：'</span> + req.url);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'http版本：'</span> + req.httpVersion);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'http请求方法：'</span> + req.method);</span><br><span class="line"></span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">客户端请求url：/hello</span><br><span class="line">http版本：1.1</span><br><span class="line">http请求方法：GET</span><br><span class="line">http headers：&#123;<span class="string">"host"</span>:<span class="string">"127.0.0.1:3000"</span>,<span class="string">"connection"</span>:<span class="string">"keep-alive"</span>,<span class="string">"cache-control"</span>:<span class="string">"max-age=0"</span>,<span class="string">"upgrade-insecure-requests"</span>:<span class="string">"1"</span>,<span class="string">"user-agent"</span>:<span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36"</span>,<span class="string">"accept"</span>:<span class="string">"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8"</span>,<span class="string">"accept-encoding"</span>:<span class="string">"gzip, deflate, sdch, br"</span>,<span class="string">"accept-language"</span>:<span class="string">"zh-CN,zh;q=0.8,en;q=0.6,zh-TW;q=0.4"</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取get请求参数"><a href="#获取get请求参数" class="headerlink" title="获取get请求参数"></a>获取get请求参数</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> urlObj = url.parse(req.url);</span><br><span class="line">    <span class="keyword">var</span> query = urlObj.query;</span><br><span class="line">    <span class="keyword">var</span> queryObj = querystring.parse(query);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log( <span class="built_in">JSON</span>.stringify(queryObj) );</span><br><span class="line">    </span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl http://127.0.0.1:3000/hello\?nick\=chyingp\&amp;hello\=world</span><br></pre></td></tr></table></figure>

<p>服务端输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">"nick"</span>:<span class="string">"chyingp"</span>,<span class="string">"hello"</span>:<span class="string">"world"</span>&#125;</span><br></pre></td></tr></table></figure>


<h4 id="获取post请求参数"><a href="#获取post请求参数" class="headerlink" title="获取post请求参数"></a>获取post请求参数</h4><p>代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body = <span class="string">''</span>;  </span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">thunk</span>)</span>&#123;</span><br><span class="line">        body += thunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'post body is: '</span> + body );</span><br><span class="line">        res.end(<span class="string">'ok'</span>);</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>

<p>通过curl构造极简post请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -d <span class="string">'nick=casper&amp;hello=world'</span> http://127.0.0.1:3000</span><br></pre></td></tr></table></figure>

<p>服务端打印如下。注意，在post请求中，不同的<code>Content-type</code>，post body有不小差异，感兴趣的同学可以自己试下。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">post body is: nick=casper&amp;hello=world</span><br></pre></td></tr></table></figure>

<p>比如本例中的post请求，HTTP报文大概如下</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 127.0.0.1:3000</span><br><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br><span class="line"></span><br><span class="line">nick=casper&amp;hello=world</span><br></pre></td></tr></table></figure>


<h3 id="枯燥的事件"><a href="#枯燥的事件" class="headerlink" title="枯燥的事件"></a>枯燥的事件</h3><p>首先，我们来看下有哪些事件</p>
<p>checkContinue、checkExpectation、clientError、close、connect、connection、request、upgrade</p>
<h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> PORT = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">var</span> noop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> svr = http.createServer(noop);</span><br><span class="line"><span class="keyword">var</span> anotherSvr = http.createServer(noop);</span><br><span class="line"></span><br><span class="line">anotherSvr.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'出错啦！'</span> + e.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">svr.listen(PORT, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    anotherSvr.listen(PORT);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>运行代码，输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">出错啦！listen EADDRINUSE :::3000</span><br></pre></td></tr></table></figure>

<h4 id="connect-vs-connection"><a href="#connect-vs-connection" class="headerlink" title="connect vs connection"></a>connect vs connection</h4><p>两者差别非常大，虽然字眼看着有点像。</p>
<ul>
<li>connect：当客户端的HTTP method为connect时触发。</li>
<li>connection：当TCP连接建立时触发，大部分时候可以忽略这个事件（目测模块内部自己用到而已）。此外，可以通过 req.connection 来获取这个socket（从nodejs源码来看，req.socket、req.connection 都指向了这个socket）。此外，socket上的readable事件不会触发（具体原因请看模块内部实现，反正我是还没研究）</li>
</ul>
<p>大部分时候都不会用到，除非你要开发HTTP代理。当客户端发起 connect 请求时触发（注意绕过了 requestListener）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> PORT = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意：发起connect请求的例子在 ./httpServerEventConnectClient.js 里</span></span><br><span class="line">server.on(<span class="string">'connect'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, socket, head</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'connect事件触发'</span>);</span><br><span class="line">    socket.end();   <span class="comment">// 反正我就只想举个例子，没打算正经处理。。。</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(PORT);</span><br></pre></td></tr></table></figure>

<h4 id="request"><a href="#request" class="headerlink" title="request"></a>request</h4><p>当有新的连接到来时触发。那跟 connection 有什么区别呢？</p>
<p>好了，<code>keep-alive</code>闪亮登场！在持久化连接的情况下，多个 request 可能对应的是 一个 connection。</p>
<p>先来看下没有<code>keep-alive</code>的场景</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> PORT = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">var</span> requestIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> connectionIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    res.end(<span class="string">'ok'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    requestIndex++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'request event: 第'</span>+ requestIndex +<span class="string">'个请求！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">    connectionIndex++;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'connection event: 第'</span>+ connectionIndex +<span class="string">'个请求！'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(PORT);</span><br></pre></td></tr></table></figure>

<p>通过curl连续发送3个请求，看下效果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 1 3`; <span class="keyword">do</span> curl http://127.0.0.1:3000; <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>服务端输出如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">connection event: 第1个请求！</span><br><span class="line">request event: 第1个请求！</span><br><span class="line">connection event: 第2个请求！</span><br><span class="line">request event: 第2个请求！</span><br><span class="line">connection event: 第3个请求！</span><br><span class="line">request event: 第3个请求！</span><br></pre></td></tr></table></figure>

<p>然后，再来看下有<code>keep-alive</code>的场景。用 postman 构造包含 keep-alive 的请求，最终的HTTP请求报文如下</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: 127.0.0.1:3000</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">Cache-Control</span>: no-cache</span><br><span class="line"><span class="attribute">Postman-Token</span>: 6027fda7-f936-d3ac-e54f-dafcbf5e58ff</span><br></pre></td></tr></table></figure>

<p>连续发送3个请求，服务端打印日志如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">connection event: 第1个请求！</span><br><span class="line">request event: 第1个请求！</span><br><span class="line">request event: 第2个请求！</span><br><span class="line">request event: 第3个请求！</span><br></pre></td></tr></table></figure>

<h3 id="不常用接口"><a href="#不常用接口" class="headerlink" title="不常用接口"></a>不常用接口</h3><h4 id="server-close-callback"><a href="#server-close-callback" class="headerlink" title="server.close([callback]);"></a>server.close([callback]);</h4><p>关闭服务器。其实就是 (new net.Server()).close()，停止接受新的连接。<br>已经连接上的请求会继续处理，当所有连接结束的时候，server 正式关闭，并抛出 close 事件。<br>一般提供了callback，就不用监听close; 监听了close，就不用添加callback。</p>
<h4 id="其他server-listen"><a href="#其他server-listen" class="headerlink" title="其他server.listen()"></a>其他server.listen()</h4><p>其实除了 server.listen(PORT) 这种监听方式外，还有以下几种相对不那么常用的监听方式。用到的时候看看文档就行了。</p>
<p>server.listen(handle[, callback])：监听本地文件描述符（fd）（windows不支持），或者server，或者socket<br>server.listen(path[, callback])：监听本地socket，创建一个 UNIX socket server 。<br>server.listen([port][, hostname][, backlog][, callback])</p>
<h4 id="网络超时-server-setTimeout-msecs-callback"><a href="#网络超时-server-setTimeout-msecs-callback" class="headerlink" title="网络超时 server.setTimeout(msecs, callback)"></a>网络超时 server.setTimeout(msecs, callback)</h4><p>设置网络连接的超时时间。当超过 msecs 没有响应时，网络就会自动断开。</p>
<p>如果传了 callback，那么当 timeout 发生时，就会将timeout的socket作为参数传给callback。</p>
<p>注意，一般情况下超时的socket会自动销毁。但当你传了callback后，你就需要手动end或者destroy这个socket。</p>
<h3 id="不常用属性-1"><a href="#不常用属性-1" class="headerlink" title="不常用属性"></a>不常用属性</h3><p>server.listening：是否在监听连接<br>server.timeout：设置超时时间（毫秒），注意，修改这个值，只会对新建立的连接产生影响。此外，将timeout设置为0，就会禁用自动超时行为。（目测不推荐）<br>server.maxHeadersCount：客户端最多传送的header数量，默认是1000，如果设置为0，则没有限制。（问题：如果超过1000怎么办？？）</p>
<h2 id="11-网络地址解析-url"><a href="#11-网络地址解析-url" class="headerlink" title="11 网络地址解析 url"></a>11 网络地址解析 url</h2><h3 id="模块概述"><a href="#模块概述" class="headerlink" title="模块概述"></a>模块概述</h3><p>nodejs中，提供了<strong>url</strong>这个非常实用的模块，用来做URL的解析。在做node服务端的开发时会经常用到。使用很简单，总共只有3个方法。</p>
<p>正式讲解前，各位同学先把下面这个图记在心上（来自nodejs官网），先对URL有一个直观的认识。</p>
<p><img src="/assets/url.png" alt=""></p>
<h3 id="模块方法概述"><a href="#模块方法概述" class="headerlink" title="模块方法概述"></a>模块方法概述</h3><p>url模块三个方法分别是：</p>
<ul>
<li><strong>.parse(urlString)</strong>：将url字符串，解析成object，便于开发者进行操作。</li>
<li><strong>.format(urlObj)</strong>：.parse() 方法的反向操作。</li>
<li><strong>.resove(from, to)</strong>：以from作为起始地址，解析出完整的目标地址（还是看直接看例子好些）</li>
</ul>
<h3 id="url解析：url-parse"><a href="#url解析：url-parse" class="headerlink" title="url解析：url.parse()"></a>url解析：url.parse()</h3><blockquote>
<p>完整语法：url.parse(urlString[, parseQueryString[, slashesDenoteHost]])</p>
</blockquote>
<p>使用比较简单，几个要点备忘如下。</p>
<ol>
<li><strong>parseQueryString</strong>：（默认为false）如为false，则<code>urlObject.query</code>为未解析的字符串，比如<code>nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1</code>，且对应的值不会decode；如果<code>parseQueryString</code>为true，则<code>urlObject.query</code>为object，比如<code>{ nick: &#39;程序猿小卡&#39; }</code>，且值会被decode；</li>
<li><strong>slashesDenoteHos</strong>：（默认为false）如果为true，那么类似<code>//foo/bar</code>里的<code>foo</code>就会被认为是<code>hostname</code>；如果为false，则<code>foo</code>被认为是pathname的一部分。</li>
<li>关于解析得到的 urlObject ，会在下一小节进行详细介绍。</li>
</ol>
<h4 id="例子1：参数值不进行解析"><a href="#例子1：参数值不进行解析" class="headerlink" title="例子1：参数值不进行解析"></a>例子1：参数值不进行解析</h4><p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'http://Chyingp:HelloWorld@ke.qq.com:8080/index.html?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1#part=1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = url.parse(str);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Url &#123;</span><br><span class="line">  protocol: <span class="string">'http:'</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="string">'Chyingp:HelloWorld'</span>,</span><br><span class="line">  host: <span class="string">'ke.qq.com:8080'</span>,</span><br><span class="line">  port: <span class="string">'8080'</span>,</span><br><span class="line">  hostname: <span class="string">'ke.qq.com'</span>,</span><br><span class="line">  hash: <span class="string">'#part=1'</span>,</span><br><span class="line">  search: <span class="string">'?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1'</span>,</span><br><span class="line">  query: <span class="string">'nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1'</span>,</span><br><span class="line">  pathname: <span class="string">'/index.html'</span>,</span><br><span class="line">  path: <span class="string">'/index.html?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1'</span>,</span><br><span class="line">  href: <span class="string">'http://Chyingp:HelloWorld@ke.qq.com:8080/index.html?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1#part=1'</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="例子2：对参数值进行decode"><a href="#例子2：对参数值进行decode" class="headerlink" title="例子2：对参数值进行decode"></a>例子2：对参数值进行decode</h4><p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'http://Chyingp:HelloWorld@ke.qq.com:8080/index.html?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1#part=1'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = url.parse(str, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure>

<p>输出如下，对比上面的例子会发现，<strong>query</strong> 字段被解析成了object，并且decode过。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Url &#123;</span><br><span class="line">  protocol: <span class="string">'http:'</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="string">'Chyingp:HelloWorld'</span>,</span><br><span class="line">  host: <span class="string">'ke.qq.com:8080'</span>,</span><br><span class="line">  port: <span class="string">'8080'</span>,</span><br><span class="line">  hostname: <span class="string">'ke.qq.com'</span>,</span><br><span class="line">  <span class="built_in">hash</span>: <span class="string">'#part=1'</span>,</span><br><span class="line">  search: <span class="string">'?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1'</span>,</span><br><span class="line">  query: &#123; nick: <span class="string">'程序猿小卡'</span> &#125;,</span><br><span class="line">  pathname: <span class="string">'/index.html'</span>,</span><br><span class="line">  path: <span class="string">'/index.html?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1'</span>,</span><br><span class="line">  href: <span class="string">'http://Chyingp:HelloWorld@ke.qq.com:8080/index.html?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1#part=1'</span> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="例子3：针对路径-foo-bar-的处理"><a href="#例子3：针对路径-foo-bar-的处理" class="headerlink" title="例子3：针对路径 //foo/bar 的处理"></a>例子3：针对路径 //foo/bar 的处理</h4><p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var url &#x3D; require(&#39;url&#39;);</span><br><span class="line">var str &#x3D; &#39;&#x2F;&#x2F;foo&#x2F;bar&#39;;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; url.parse(str, true, false);</span><br><span class="line">console.log(obj);</span><br><span class="line"></span><br><span class="line">obj &#x3D; url.parse(str, true, true);</span><br><span class="line">console.log(obj);</span><br></pre></td></tr></table></figure>

<p>输出如下，自行对比两者之间的差异：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Url &#123;</span><br><span class="line">  protocol: null,</span><br><span class="line">  slashes: null,</span><br><span class="line">  auth: null,</span><br><span class="line">  host: null,</span><br><span class="line">  port: null,</span><br><span class="line">  hostname: null,</span><br><span class="line">  <span class="built_in">hash</span>: null,</span><br><span class="line">  search: <span class="string">''</span>,</span><br><span class="line">  query: &#123;&#125;,</span><br><span class="line">  pathname: <span class="string">'//foo/bar'</span>,</span><br><span class="line">  path: <span class="string">'//foo/bar'</span>,</span><br><span class="line">  href: <span class="string">'//foo/bar'</span> &#125;</span><br><span class="line">Url &#123;</span><br><span class="line">  protocol: null,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: null,</span><br><span class="line">  host: <span class="string">'foo'</span>,</span><br><span class="line">  port: null,</span><br><span class="line">  hostname: <span class="string">'foo'</span>,</span><br><span class="line">  <span class="built_in">hash</span>: null,</span><br><span class="line">  search: <span class="string">''</span>,</span><br><span class="line">  query: &#123;&#125;,</span><br><span class="line">  pathname: <span class="string">'/bar'</span>,</span><br><span class="line">  path: <span class="string">'/bar'</span>,</span><br><span class="line">  href: <span class="string">'//foo/bar'</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="关于urlObject"><a href="#关于urlObject" class="headerlink" title="关于urlObject"></a>关于urlObject</h3><p>以上面的作为例子，粗略讲解下<code>urlObject</code>。更多细节可参考<a href="https://nodejs.org/api/url.html#url_url_strings_and_url_objects" target="_blank" rel="noopener">官方文档</a>。</p>
<ul>
<li>protocol：协议，需要注意的是包含了<code>:</code>，并且是小写的。</li>
<li>slashes：如果<code>:</code>后面跟了两个<code>//</code>，那么为true。</li>
<li>auth：认证信息，如果有密码，为<code>usrname:passwd</code>，如果没有，则为<code>usrname</code>。注意，这里区分大小写。</li>
<li>host：主机名。注意包含了端口，比如<code>ke.qq.com:8080</code>，并且是小写的。</li>
<li>hostname：主机名，不包含端口，并且是小写的。</li>
<li>hash：哈希部分，注意包含了<code>#</code>。</li>
<li>search：查询字符串，注意，包含了<code>?</code>，此外，值是没有经过decode的。</li>
<li>query：字符串 或者 对象。如果是字符串，则是<code>search</code>去掉<code>?</code>，其余一样；如果是对象，那么是decode过的。</li>
<li>path：路径部分，包含search部分。</li>
<li>pathname：路径部分，不包含search部分。</li>
<li>href：原始的地址。不过需要注意的是，<code>protocol</code>、<code>host</code>会被转成小写字母。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  protocol: <span class="string">'http:'</span>,</span><br><span class="line">  slashes: <span class="literal">true</span>,</span><br><span class="line">  auth: <span class="string">'Chyingp:HelloWorld'</span>,</span><br><span class="line">  host: <span class="string">'ke.qq.com:8080'</span>,</span><br><span class="line">  port: <span class="string">'8080'</span>,</span><br><span class="line">  hostname: <span class="string">'ke.qq.com'</span>,</span><br><span class="line">  hash: <span class="string">'#part=1'</span>,</span><br><span class="line">  search: <span class="string">'?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1'</span>,</span><br><span class="line">  query: &#123; <span class="attr">nick</span>: <span class="string">'程序猿小卡'</span> &#125;,</span><br><span class="line">  pathname: <span class="string">'/index.html'</span>,</span><br><span class="line">  path: <span class="string">'/index.html?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1'</span>,</span><br><span class="line">  href: <span class="string">'http://Chyingp:HelloWorld@ke.qq.com:8080/index.html?nick=%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%B0%8F%E5%8D%A1#part=1'</span> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="url拼接：url-format-urlObject"><a href="#url拼接：url-format-urlObject" class="headerlink" title="url拼接：url.format(urlObject)"></a>url拼接：url.format(urlObject)</h3><blockquote>
<p>完整语法：url.format(urlObject)</p>
</blockquote>
<p><code>url.parse(str)</code>的反向操作，没什么好说的。<code>urlObject</code>包含了很多字段，比如<code>protocol</code>、<code>slashes</code>、<code>protocol</code>等，且不一定需要全部传，所以有一套解析逻辑。</p>
<p>过程比较冗长，大部分时候不需要用到，直接贴<a href="https://nodejs.org/api/url.html#url_url_format_urlobject" target="_blank" rel="noopener">官方文档</a>的链接，有需要再看。</p>
<h3 id="url-resolve-from-to"><a href="#url-resolve-from-to" class="headerlink" title="url.resolve(from, to)"></a>url.resolve(from, to)</h3><p>用法比较简单，直接贴官方文档的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">url.resolve(<span class="string">'/one/two/three'</span>, <span class="string">'four'</span>)         <span class="comment">// '/one/two/four'</span></span><br><span class="line">url.resolve(<span class="string">'http://example.com/'</span>, <span class="string">'/one'</span>)    <span class="comment">// 'http://example.com/one'</span></span><br><span class="line">url.resolve(<span class="string">'http://example.com/one'</span>, <span class="string">'/two'</span>) <span class="comment">// 'http://example.com/two'</span></span><br></pre></td></tr></table></figure>

<h2 id="12-URL查询字符串-querystring"><a href="#12-URL查询字符串-querystring" class="headerlink" title="12 URL查询字符串 querystring"></a>12 URL查询字符串 querystring</h2><h3 id="模块概述-1"><a href="#模块概述-1" class="headerlink" title="模块概述"></a>模块概述</h3><p>在nodejs中，提供了<strong>querystring</strong>这个模块，用来做url查询参数的解析，使用非常简单。</p>
<p>模块总共有四个方法，绝大部分时，我们只会用到 <strong>.parse()</strong>、 <strong>.stringify()</strong>两个方法。剩余的方法，感兴趣的同学可自行查看文档。</p>
<ul>
<li><strong>.parse()</strong>：对url查询参数（字符串）进行解析，生成易于分析的json格式。</li>
<li><strong>.stringif()</strong>：跟<strong>.parse()</strong>相反，用于拼接查询查询。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">querystring.parse(str[, sep[, eq[, options]]])</span><br><span class="line">querystring.stringify(obj[, sep[, eq[, options]]])</span><br></pre></td></tr></table></figure>

<h3 id="查询参数解析：querystring-parse"><a href="#查询参数解析：querystring-parse" class="headerlink" title="查询参数解析：querystring.parse()"></a>查询参数解析：querystring.parse()</h3><blockquote>
<p>参数：querystring.parse(str[, sep[, eq[, options]]])</p>
</blockquote>
<p>第四个参数几乎不会用到,直接不讨论. 第二个, 第三个其实也很少用到,但某些时候还是可以用一下。直接看例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> str = <span class="string">'nick=casper&amp;age=24'</span>;</span><br><span class="line"><span class="keyword">var</span> obj = querystring.parse(str);</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"nick"</span>: <span class="string">"casper"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="string">"24"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看下<code>sep</code>、<code>eq</code>有什么作用。相当于可以替换<code>&amp;</code>、<code>=</code>为自定义字符，对于下面的场景来说还是挺省事的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">'nick=casper&amp;age=24&amp;extra=name-chyingp|country-cn'</span>;</span><br><span class="line"><span class="keyword">var</span> obj1 = querystring.parse(str1);</span><br><span class="line"><span class="keyword">var</span> obj2 = querystring.parse(obj1.extra, <span class="string">'|'</span>, <span class="string">'-'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(obj2, <span class="literal">null</span>, <span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"chyingp"</span>,</span><br><span class="line">    <span class="string">"country"</span>: <span class="string">"cn"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询参数拼接：querystring-stringify"><a href="#查询参数拼接：querystring-stringify" class="headerlink" title="查询参数拼接：querystring.stringify()"></a>查询参数拼接：querystring.stringify()</h3><blockquote>
<p>querystring.stringify(obj[, sep[, eq[, options]]])</p>
</blockquote>
<p>没什么好说的，相当于<code>parse</code>的逆向操作。直接看代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    <span class="string">"nick"</span>: <span class="string">"casper"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="string">"24"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> str1 = querystring.stringify(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(str1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"chyingp"</span>,</span><br><span class="line">    <span class="string">"country"</span>: <span class="string">"cn"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> str2 = querystring.stringify(obj2, <span class="string">'|'</span>, <span class="string">'-'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(str2);</span><br></pre></td></tr></table></figure>

<p>输出如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">nick=casper&amp;age=<span class="number">24</span></span><br><span class="line">name-chyingp|country-cn</span><br></pre></td></tr></table></figure>

<h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p>官方文档：<a href="https://nodejs.org/api/querystring.html" target="_blank" rel="noopener">https://nodejs.org/api/querystring.html</a></p>
<h2 id="13-本地路径处理-path"><a href="#13-本地路径处理-path" class="headerlink" title="13 本地路径处理 path"></a>13 本地路径处理 path</h2><h3 id="模块概览"><a href="#模块概览" class="headerlink" title="模块概览"></a>模块概览</h3><p>在nodejs中，path是个使用频率很高，但却让人又爱又恨的模块。部分因为文档说的不够清晰，部分因为接口的平台差异性。</p>
<p>将path的接口按照用途归类，仔细琢磨琢磨，也就没那么费解了。</p>
<h3 id="获取路径-文件名-扩展名"><a href="#获取路径-文件名-扩展名" class="headerlink" title="获取路径/文件名/扩展名"></a>获取路径/文件名/扩展名</h3><ul>
<li>获取路径：path.dirname(filepath)</li>
<li>获取文件名：path.basename(filepath)</li>
<li>获取扩展名：path.extname(filepath)</li>
</ul>
<h4 id="获取所在路径"><a href="#获取所在路径" class="headerlink" title="获取所在路径"></a>获取所在路径</h4><p>例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> filepath = <span class="string">'/tmp/demo/js/test.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：/tmp/demo/js</span></span><br><span class="line"><span class="built_in">console</span>.log( path.dirname(filepath) );</span><br></pre></td></tr></table></figure>

<h4 id="获取文件名"><a href="#获取文件名" class="headerlink" title="获取文件名"></a>获取文件名</h4><p>严格意义上来说，path.basename(filepath) 只是输出路径的最后一部分，并不会判断是否文件名。</p>
<p>但大部分时候，我们可以用它来作为简易的“获取文件名“的方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：test.js</span></span><br><span class="line"><span class="built_in">console</span>.log( path.basename(<span class="string">'/tmp/demo/js/test.js'</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：test</span></span><br><span class="line"><span class="built_in">console</span>.log( path.basename(<span class="string">'/tmp/demo/js/test/'</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：test</span></span><br><span class="line"><span class="built_in">console</span>.log( path.basename(<span class="string">'/tmp/demo/js/test'</span>) );</span><br></pre></td></tr></table></figure>

<p>如果只想获取文件名，单不包括文件扩展呢？可以用上第二个参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出：test</span></span><br><span class="line"><span class="built_in">console</span>.log( path.basename(<span class="string">'/tmp/demo/js/test.js'</span>, <span class="string">'.js'</span>) );</span><br></pre></td></tr></table></figure>

<h4 id="获取文件扩展名"><a href="#获取文件扩展名" class="headerlink" title="获取文件扩展名"></a>获取文件扩展名</h4><p>简单的例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> filepath = <span class="string">'/tmp/demo/js/test.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：.js</span></span><br><span class="line"><span class="built_in">console</span>.log( path.extname(filepath) );</span><br></pre></td></tr></table></figure>

<p>更详细的规则是如下：（假设 path.basename(filepath) === B ）</p>
<ul>
<li>从B的最后一个<code>.</code>开始截取，直到最后一个字符。</li>
<li>如果B中不存在<code>.</code>，或者B的第一个字符就是<code>.</code>，那么返回空字符串。</li>
</ul>
<p>直接看<a href="https://nodejs.org/api/path.html#path_path_extname_path" target="_blank" rel="noopener">官方文档</a>的例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path.extname(<span class="string">'index.html'</span>)</span><br><span class="line"><span class="comment">// returns '.html'</span></span><br><span class="line"></span><br><span class="line">path.extname(<span class="string">'index.coffee.md'</span>)</span><br><span class="line"><span class="comment">// returns '.md'</span></span><br><span class="line"></span><br><span class="line">path.extname(<span class="string">'index.'</span>)</span><br><span class="line"><span class="comment">// returns '.'</span></span><br><span class="line"></span><br><span class="line">path.extname(<span class="string">'index'</span>)</span><br><span class="line"><span class="comment">// returns ''</span></span><br><span class="line"></span><br><span class="line">path.extname(<span class="string">'.index'</span>)</span><br><span class="line"><span class="comment">// returns ''</span></span><br></pre></td></tr></table></figure>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><h4 id="path-normalize-p"><a href="#path-normalize-p" class="headerlink" title="path.normalize(p)"></a>path.normalize(p)</h4><p>规范化路径，处理冗余的“..”、“.”、“/”字符。发现多个斜杠时，会替换成一个斜杠。当路径末尾包含一个斜杠时，保留。Windows系统使用反斜杠　</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var path &#x3D; require(&#39;path&#39;);</span><br><span class="line">console.log(path.normalize(&#39;a&#x2F;b&#x2F;c&#x2F;..&#x2F;user&#x2F;bin&#39;));&#x2F;&#x2F; a\b\user\bin</span><br><span class="line">console.log(path.normalize(&#39;a&#x2F;b&#x2F;c&#x2F;&#x2F;&#x2F;..&#x2F;user&#x2F;bin&#x2F;&#39;));&#x2F;&#x2F; a\b\user\bin\</span><br><span class="line">console.log(path.normalize(&#39;a&#x2F;b&#x2F;c&#x2F;..&#x2F;..&#x2F;user&#x2F;bin&#39;));&#x2F;&#x2F; a\user\bin</span><br><span class="line">console.log(path.normalize(&#39;a&#x2F;b&#x2F;c&#x2F;..&#x2F;.&#x2F;&#x2F;&#x2F;&#x2F;..&#x2F;user&#x2F;bin&#x2F;..&#39;));&#x2F;&#x2F; a\user</span><br><span class="line">console.log(path.normalize(&#39;a&#x2F;b&#x2F;c&#x2F;..&#x2F;..&#x2F;user&#x2F;bin&#x2F;..&#x2F;..&#x2F;&#39;));&#x2F;&#x2F; a\</span><br><span class="line">console.log(path.normalize(&#39;a&#x2F;..&#x2F;..&#x2F;user&#x2F;bin&#x2F;..&#x2F;..&#x2F;&#39;));&#x2F;&#x2F;..\</span><br><span class="line">console.log(path.normalize(&#39;a&#x2F;..&#x2F;..&#x2F;user&#x2F;bin&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;&#39;));&#x2F;&#x2F; ..\..\..\</span><br><span class="line">console.log(path.normalize(&#39;.&#x2F;a&#x2F;..&#x2F;.&#x2F;user&#x2F;bin&#x2F;.&#x2F;&#39;));&#x2F;&#x2F;user\bin\</span><br></pre></td></tr></table></figure>
<h4 id="path-join-path1-path2-…"><a href="#path-join-path1-path2-…" class="headerlink" title="path.join([path1], [path2], […])"></a>path.join([path1], [path2], […])</h4><p>将多个路径结合在一起，并转换为规范化路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var path &#x3D; require(&#39;path&#39;);</span><br><span class="line">console.log(path.join(&#39;&#x2F;&#x2F;&#x2F;&#x2F;.&#x2F;a&#39;, &#39;b&#x2F;&#x2F;&#x2F;&#x2F;c&#39;, &#39;user&#x2F;&#39;));&#x2F;&#x2F;\a\b\c\user</span><br><span class="line">console.log(path.join(&#39;a&#39;, &#39;..&#x2F;..&#x2F;&#39;, &#39;user&#x2F;&#39;));&#x2F;&#x2F;..\user\</span><br></pre></td></tr></table></figure>

<h4 id="path-resolve-from-…-to"><a href="#path-resolve-from-…-to" class="headerlink" title="path.resolve([from …], to)"></a>path.resolve([from …], to)</h4><p>从源地址 from 到目的地址 to 的绝对路径，类似在shell里执行一系列的cd命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path.resolve(&#39;foo&#x2F;bar&#39;, &#39;&#x2F;tmp&#x2F;file&#x2F;&#39;, &#39;..&#39;, &#39;a&#x2F;..&#x2F;subfile&#39;)</span><br></pre></td></tr></table></figure>
<p>类似于:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd foo&#x2F;bar</span><br><span class="line">cd &#x2F;tmp&#x2F;file&#x2F;</span><br><span class="line">cd ..</span><br><span class="line">cd a&#x2F;..&#x2F;subfile</span><br><span class="line">pwd</span><br></pre></td></tr></table></figure>
<p>如果某个from或to参数是绝对路径（比如 ‘E:/abc’，或是以“/”开头的路径），则将忽略之前的from参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var path &#x3D; require(&#39;path&#39;);</span><br><span class="line">console.log(path.resolve(&#39;.&#39;, &#39;testFiles&#x2F;..&#39;, &#39;trdLayer&#39;));&#x2F;&#x2F;D:\project\trdLayer</span><br><span class="line">console.log(path.resolve(&#39;..&#39;, &#39;testFiles&#39;, &#39;a.txt&#39;));&#x2F;&#x2F;D:\testFiles\a.txt</span><br><span class="line">console.log(path.resolve(&#39;D:&#39;, &#39;abc&#39;, &#39;D:&#x2F;a&#39;));&#x2F;&#x2F;D:\a</span><br><span class="line">console.log(path.resolve(&#39;abc&#39;, &#39;ok.gif&#39;));&#x2F;&#x2F;D:\project\abc\ok.gif</span><br><span class="line">console.log(path.resolve(&#39;abc&#39;, &#39;..&#39;, &#39;a&#x2F;..&#x2F;subfile&#39;)); &#x2F;&#x2F;D:\project\subfile</span><br></pre></td></tr></table></figure>

<h4 id="path-resolve-…paths"><a href="#path-resolve-…paths" class="headerlink" title="path.resolve([…paths])"></a>path.resolve([…paths])</h4><p>这个接口的说明有点啰嗦。你可以想象现在你在shell下面，从左到右运行一遍<code>cd path</code>命令，最终获取的绝对路径/文件名，就是这个接口所返回的结果了。</p>
<p>比如 <code>path.resolve(&#39;/foo/bar&#39;, &#39;./baz&#39;)</code> 可以看成下面命令的结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /foo/bar</span><br><span class="line"><span class="built_in">cd</span> ./baz</span><br></pre></td></tr></table></figure>

<p>更多对比例子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设当前工作路径是 /Users/a/Documents/git-code/nodejs-learning-guide/examples/2016.11.08-node-path</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 /Users/a/Documents/git-code/nodejs-learning-guide/examples/2016.11.08-node-path</span></span><br><span class="line"><span class="built_in">console</span>.log( path.resolve(<span class="string">''</span>) )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 /Users/a/Documents/git-code/nodejs-learning-guide/examples/2016.11.08-node-path</span></span><br><span class="line"><span class="built_in">console</span>.log( path.resolve(<span class="string">'.'</span>) )</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 /foo/bar/baz</span></span><br><span class="line"><span class="built_in">console</span>.log( path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'./baz'</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 /foo/bar/baz</span></span><br><span class="line"><span class="built_in">console</span>.log( path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'./baz/'</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 /tmp/file</span></span><br><span class="line"><span class="built_in">console</span>.log( path.resolve(<span class="string">'/foo/bar'</span>, <span class="string">'/tmp/file/'</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 /Users/a/Documents/git-code/nodejs-learning-guide/examples/2016.11.08-node-path/www/js/mod.js</span></span><br><span class="line"><span class="built_in">console</span>.log( path.resolve(<span class="string">'www'</span>, <span class="string">'js/upload'</span>, <span class="string">'../mod.js'</span>) );</span><br></pre></td></tr></table></figure>

<h3 id="路径解析"><a href="#路径解析" class="headerlink" title="路径解析"></a>路径解析</h3><h4 id="path-normalize-filepath"><a href="#path-normalize-filepath" class="headerlink" title="path.normalize(filepath)"></a>path.normalize(filepath)</h4><p>从官方文档的描述来看，path.normalize(filepath) 应该是比较简单的一个API，不过用起来总是觉得没底。</p>
<p>为什么呢？API说明过于简略了，包括如下：</p>
<ul>
<li>如果路径为空，返回<code>.</code>，相当于当前的工作路径。</li>
<li>将对路径中重复的路径分隔符（比如linux下的<code>/</code>)合并为一个。</li>
<li>对路径中的<code>.</code>、<code>..</code>进行处理。（类似于shell里的<code>cd ..</code>）</li>
<li>如果路径最后有<code>/</code>，那么保留该<code>/</code>。</li>
</ul>
<p>感觉stackoverflow上一个兄弟对这个API的解释更实在，<a href="http://stackoverflow.com/questions/10822574/difference-between-path-normalize-and-path-resolve-in-node-js" target="_blank" rel="noopener">原文链接</a>。</p>
<blockquote>
<p>In other words, path.normalize is “What is the shortest path I can take that will take me to the same place as the input”</p>
</blockquote>
<p>代码示例如下。建议读者把代码拷贝出来运行下，看下实际效果。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> filepath = <span class="string">'/tmp/demo/js/test.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> compare = <span class="function"><span class="keyword">function</span>(<span class="params">desc, callback</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[用例%d]：%s'</span>, ++index, desc);</span><br><span class="line">  callback();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'\n'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">compare(<span class="string">'路径为空'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 输出 .</span></span><br><span class="line">  <span class="built_in">console</span>.log( path.normalize(<span class="string">''</span>) );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">compare(<span class="string">'路径结尾是否带/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 输出 /tmp/demo/js/upload</span></span><br><span class="line">  <span class="built_in">console</span>.log( path.normalize(<span class="string">'/tmp/demo/js/upload'</span>) );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// /tmp/demo/js/upload/</span></span><br><span class="line">  <span class="built_in">console</span>.log( path.normalize(<span class="string">'/tmp/demo/js/upload/'</span>) );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">compare(<span class="string">'重复的/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 输出 /tmp/demo/js</span></span><br><span class="line">  <span class="built_in">console</span>.log( path.normalize(<span class="string">'/tmp/demo//js'</span>) );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">compare(<span class="string">'路径带..'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 输出 /tmp/demo/js</span></span><br><span class="line">  <span class="built_in">console</span>.log( path.normalize(<span class="string">'/tmp/demo/js/upload/..'</span>) );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">compare(<span class="string">'相对路径'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 输出 demo/js/upload/</span></span><br><span class="line">  <span class="built_in">console</span>.log( path.normalize(<span class="string">'./demo/js/upload/'</span>) );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出 demo/js/upload/</span></span><br><span class="line">  <span class="built_in">console</span>.log( path.normalize(<span class="string">'demo/js/upload/'</span>) );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">compare(<span class="string">'不常用边界'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 输出 ..</span></span><br><span class="line">  <span class="built_in">console</span>.log( path.normalize(<span class="string">'./..'</span>) );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出 ..</span></span><br><span class="line">  <span class="built_in">console</span>.log( path.normalize(<span class="string">'..'</span>) );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出 ../</span></span><br><span class="line">  <span class="built_in">console</span>.log( path.normalize(<span class="string">'../'</span>) );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出 /</span></span><br><span class="line">  <span class="built_in">console</span>.log( path.normalize(<span class="string">'/../'</span>) );</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 输出 /</span></span><br><span class="line">  <span class="built_in">console</span>.log( path.normalize(<span class="string">'/..'</span>) );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>感兴趣的可以看下 path.normalize(filepath) 的node源码如下：<a href="https://github.com/nodejs/node/blob/master/lib/path.js" target="_blank" rel="noopener">传送门</a></p>
<h3 id="文件路径分解-组合"><a href="#文件路径分解-组合" class="headerlink" title="文件路径分解/组合"></a>文件路径分解/组合</h3><ul>
<li>path.format(pathObject)：将pathObject的root、dir、base、name、ext属性，按照一定的规则，组合成一个文件路径。</li>
<li>path.parse(filepath)：path.format()方法的反向操作。</li>
</ul>
<p>我们先来看看官网对相关属性的说明。</p>
<p>首先是linux下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌─────────────────────┬────────────┐</span><br><span class="line">│          dir        │    base    │</span><br><span class="line">├──────┬              ├──────┬─────┤</span><br><span class="line">│ root │              │ name │ ext │</span><br><span class="line"><span class="string">"  /    home/user/dir / file  .txt "</span></span><br><span class="line">└──────┴──────────────┴──────┴─────┘</span><br><span class="line">(all spaces <span class="keyword">in</span> the <span class="string">""</span> line should be ignored -- they are purely <span class="keyword">for</span> formatting)</span><br></pre></td></tr></table></figure>


<p>然后是windows下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">┌─────────────────────┬────────────┐</span><br><span class="line">│          dir        │    base    │</span><br><span class="line">├──────┬              ├──────┬─────┤</span><br><span class="line">│ root │              │ name │ ext │</span><br><span class="line"><span class="string">" C:\      path\dir   \ file  .txt "</span></span><br><span class="line">└──────┴──────────────┴──────┴─────┘</span><br><span class="line">(all spaces <span class="keyword">in</span> the <span class="string">""</span> line should be ignored -- they are purely <span class="keyword">for</span> formatting)</span><br></pre></td></tr></table></figure>

<h4 id="path-format-pathObject"><a href="#path-format-pathObject" class="headerlink" title="path.format(pathObject)"></a>path.format(pathObject)</h4><p>阅读相关API文档说明后发现，path.format(pathObject)中，pathObject的配置属性是可以进一步精简的。</p>
<p>根据接口的描述来看，以下两者是等价的。</p>
<ul>
<li><code>root</code> vs <code>dir</code>：两者可以互相替换，区别在于，路径拼接时，<code>root</code>后不会自动加<code>/</code>，而<code>dir</code>会。</li>
<li><code>base</code> vs <code>name+ext</code>：两者可以互相替换。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = path.format(&#123;</span><br><span class="line">  root: <span class="string">'/tmp/'</span>, </span><br><span class="line">  base: <span class="string">'hello.js'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log( p1 ); <span class="comment">// 输出 /tmp/hello.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = path.format(&#123;</span><br><span class="line">  dir: <span class="string">'/tmp'</span>, </span><br><span class="line">  name: <span class="string">'hello'</span>,</span><br><span class="line">  ext: <span class="string">'.js'</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log( p2 );  <span class="comment">// 输出 /tmp/hello.js</span></span><br></pre></td></tr></table></figure>

<h4 id="path-parse-filepath"><a href="#path-parse-filepath" class="headerlink" title="path.parse(filepath)"></a>path.parse(filepath)</h4><p>path.format(pathObject) 的反向操作，直接上官网例子。</p>
<p>四个属性，对于使用者是挺便利的，不过path.format(pathObject) 中也是四个配置属性，就有点容易搞混。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">path.parse(<span class="string">'/home/user/dir/file.txt'</span>)</span><br><span class="line"><span class="comment">// returns</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//    root : "/",</span></span><br><span class="line"><span class="comment">//    dir : "/home/user/dir",</span></span><br><span class="line"><span class="comment">//    base : "file.txt",</span></span><br><span class="line"><span class="comment">//    ext : ".txt",</span></span><br><span class="line"><span class="comment">//    name : "file"</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="获取相对路径"><a href="#获取相对路径" class="headerlink" title="获取相对路径"></a>获取相对路径</h3><p>接口：path.relative(from, to)</p>
<p>描述：从<code>from</code>路径，到<code>to</code>路径的相对路径。</p>
<p>边界：</p>
<ul>
<li>如果<code>from</code>、<code>to</code>指向同个路径，那么，返回空字符串。</li>
<li>如果<code>from</code>、<code>to</code>中任一者为空，那么，返回当前工作路径。</li>
</ul>
<p>上例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = path.relative(<span class="string">'/data/orandea/test/aaa'</span>, <span class="string">'/data/orandea/impl/bbb'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p1);  <span class="comment">// 输出 "../../impl/bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = path.relative(<span class="string">'/data/demo'</span>, <span class="string">'/data/demo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p2);  <span class="comment">// 输出 ""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p3 = path.relative(<span class="string">'/data/demo'</span>, <span class="string">''</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p3);  <span class="comment">// 输出 "../../Users/a/Documents/git-code/nodejs-learning-guide/examples/2016.11.08-node-path"</span></span><br></pre></td></tr></table></figure>


<h3 id="平台相关接口-属性"><a href="#平台相关接口-属性" class="headerlink" title="平台相关接口/属性"></a>平台相关接口/属性</h3><p>以下属性、接口，都跟平台的具体实现相关。也就是说，同样的属性、接口，在不同平台上的表现不同。</p>
<ul>
<li>path.posix：path相关属性、接口的linux实现。</li>
<li>path.win32：path相关属性、接口的win32实现。</li>
<li>path.sep：路径分隔符。在linux上是<code>/</code>，在windows上是<code>\</code>。</li>
<li>path.delimiter：path设置的分割符。linux上是<code>:</code>，windows上是<code>;</code>。</li>
</ul>
<p>注意，当使用 path.win32 相关接口时，参数同样可以使用<code>/</code>做分隔符，但接口返回值的分割符只会是<code>\</code>。</p>
<p>直接来例子更直观。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; path.win32.join(<span class="string">'/tmp'</span>, <span class="string">'fuck'</span>)</span><br><span class="line"><span class="string">'\\tmp\\fuck'</span></span><br><span class="line">&gt; path.win32.sep</span><br><span class="line"><span class="string">'\\'</span></span><br><span class="line">&gt; path.win32.join(<span class="string">'\tmp'</span>, <span class="string">'demo'</span>)</span><br><span class="line"><span class="string">'\\tmp\\demo'</span></span><br><span class="line">&gt; path.win32.join(<span class="string">'/tmp'</span>, <span class="string">'demo'</span>)</span><br><span class="line"><span class="string">'\\tmp\\demo'</span></span><br></pre></td></tr></table></figure>

<h4 id="path-delimiter"><a href="#path-delimiter" class="headerlink" title="path.delimiter"></a>path.delimiter</h4><p>linux系统例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">console.log(process.env.PATH)</span><br><span class="line">// <span class="string">'/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin'</span></span><br><span class="line"></span><br><span class="line">process.env.PATH.split(path.delimiter)</span><br><span class="line">// returns [<span class="string">'/usr/bin'</span>, <span class="string">'/bin'</span>, <span class="string">'/usr/sbin'</span>, <span class="string">'/sbin'</span>, <span class="string">'/usr/local/bin'</span>]</span><br></pre></td></tr></table></figure>

<p>windows系统例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">console.log(process.env.PATH)</span><br><span class="line">// <span class="string">'C:\Windows\system32;C:\Windows;C:\Program Files\node\'</span></span><br><span class="line"></span><br><span class="line">process.env.PATH.split(path.delimiter)</span><br><span class="line">// returns [<span class="string">'C:\\Windows\\system32'</span>, <span class="string">'C:\\Windows'</span>, <span class="string">'C:\\Program Files\\node\\'</span>]</span><br></pre></td></tr></table></figure>

<h2 id="14-事件机制-events"><a href="#14-事件机制-events" class="headerlink" title="14 事件机制 events"></a>14 事件机制 events</h2><h3 id="模块概览-1"><a href="#模块概览-1" class="headerlink" title="模块概览"></a>模块概览</h3><p>events模块是node的核心模块之一，几乎所有常用的node模块都继承了events模块，比如http、fs等。</p>
<p>模块本身非常简单，API虽然也不少，但常用的就那么几个，这里举几个简单例子。</p>
<h3 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h3><p>下面一共是6个例子，都非常简单，可以直接拷贝出来运行。例子5比较有意思，虽然也并不复杂，但确实是容易记错的点，感兴趣的同学可以看下。</p>
<h4 id="例子1：单个事件监听器"><a href="#例子1：单个事件监听器" class="headerlink" title="例子1：单个事件监听器"></a>例子1：单个事件监听器</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Man();</span><br><span class="line"></span><br><span class="line">man.on(<span class="string">'wakeup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'man has woken up'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">man.emit(<span class="string">'wakeup'</span>);</span><br><span class="line"><span class="comment">// 输出如下：</span></span><br><span class="line"><span class="comment">// man has woken up</span></span><br></pre></td></tr></table></figure>

<h4 id="例子2：同个事件，多个事件监听器"><a href="#例子2：同个事件，多个事件监听器" class="headerlink" title="例子2：同个事件，多个事件监听器"></a>例子2：同个事件，多个事件监听器</h4><p>可以看到，事件触发时，事件监听器按照注册的顺序执行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Man();</span><br><span class="line"></span><br><span class="line">man.on(<span class="string">'wakeup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'man has woken up'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">man.on(<span class="string">'wakeup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'man has woken up again'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">man.emit(<span class="string">'wakeup'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下：</span></span><br><span class="line"><span class="comment">// man has woken up</span></span><br><span class="line"><span class="comment">// man has woken up again</span></span><br></pre></td></tr></table></figure>

<h4 id="例子3：只运行一次的事件监听器"><a href="#例子3：只运行一次的事件监听器" class="headerlink" title="例子3：只运行一次的事件监听器"></a>例子3：只运行一次的事件监听器</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Man();</span><br><span class="line"></span><br><span class="line">man.on(<span class="string">'wakeup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'man has woken up'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">man.once(<span class="string">'wakeup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'man has woken up again'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">man.emit(<span class="string">'wakeup'</span>);</span><br><span class="line">man.emit(<span class="string">'wakeup'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下：</span></span><br><span class="line"><span class="comment">// man has woken up</span></span><br><span class="line"><span class="comment">// man has woken up again</span></span><br><span class="line"><span class="comment">// man has woken up</span></span><br></pre></td></tr></table></figure>

<h4 id="例子4：注册事件监听器前，事件先触发"><a href="#例子4：注册事件监听器前，事件先触发" class="headerlink" title="例子4：注册事件监听器前，事件先触发"></a>例子4：注册事件监听器前，事件先触发</h4><p>可以看到，注册事件监听器前，事件先触发，则该事件会直接被忽略。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Man();</span><br><span class="line"></span><br><span class="line">man.emit(<span class="string">'wakeup'</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">man.on(<span class="string">'wakeup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'man has woken up -&gt;'</span> + index);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">man.emit(<span class="string">'wakeup'</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 输出如下：</span></span><br><span class="line"><span class="comment">// man has woken up -&gt;2</span></span><br></pre></td></tr></table></figure>

<h4 id="例子5：异步执行，还是顺序执行"><a href="#例子5：异步执行，还是顺序执行" class="headerlink" title="例子5：异步执行，还是顺序执行"></a>例子5：异步执行，还是顺序执行</h4><p>例子很简单，但非常重要。究竟是代码1先执行，还是代码2先执行，这点差异，无论对于我们理解别人的代码，还是自己编写node程序，都非常关键。</p>
<p>实践证明，代码1先执行了。(node v6.1.0)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Man();</span><br><span class="line"></span><br><span class="line">man.on(<span class="string">'wakeup'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'man has woken up'</span>); <span class="comment">// 代码1</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">man.emit(<span class="string">'wakeup'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'woman has woken up'</span>);  <span class="comment">// 代码2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下：</span></span><br><span class="line"><span class="comment">// man has woken up</span></span><br><span class="line"><span class="comment">// woman has woken up</span></span><br></pre></td></tr></table></figure>

<h4 id="例子6：移除事件监听器"><a href="#例子6：移除事件监听器" class="headerlink" title="例子6：移除事件监听器"></a>例子6：移除事件监听器</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> EventEmitter = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wakeup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'man has woken up'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Man();</span><br><span class="line"></span><br><span class="line">man.on(<span class="string">'wakeup'</span>, wakeup);</span><br><span class="line">man.emit(<span class="string">'wakeup'</span>);</span><br><span class="line"></span><br><span class="line">man.removeListener(<span class="string">'wakeup'</span>, wakeup);</span><br><span class="line">man.emit(<span class="string">'wakeup'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出如下：</span></span><br><span class="line"><span class="comment">// man has woken up</span></span><br></pre></td></tr></table></figure>

<h3 id="相关链接-1"><a href="#相关链接-1" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://nodejs.org/api/events.html" target="_blank" rel="noopener">https://nodejs.org/api/events.html</a></p>
<h2 id="15-流操作-stream"><a href="#15-流操作-stream" class="headerlink" title="15 流操作 stream"></a>15 流操作 stream</h2><h3 id="模块概览-2"><a href="#模块概览-2" class="headerlink" title="模块概览"></a>模块概览</h3><p>nodejs的核心模块，基本上都是stream的的实例，比如process.stdout、http.clientRequest。</p>
<p>对于大部分的nodejs开发者来说，平常并不会直接用到stream模块，只需要了解stream的运行机制即可（非常重要）。</p>
<p>而对于想要实现自定义stream实例的开发者来说，就得好好研究stream的扩展API了，比如gulp的内部实现就大量用到了自定义的stream类型。</p>
<p>来个简单的例子镇楼，几行代码就实现了读取文件内容，并打印到控制台：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.createReadStream(<span class="string">'./sample.txt'</span>).pipe(process.stdout);</span><br></pre></td></tr></table></figure>

<h3 id="Stream分类"><a href="#Stream分类" class="headerlink" title="Stream分类"></a>Stream分类</h3><p>在nodejs中，有四种stream类型：</p>
<ul>
<li>Readable：用来读取数据，比如 <code>fs.createReadStream()</code>。</li>
<li>Writable：用来写数据，比如 <code>fs.createWriteStream()</code>。</li>
<li>Duplex：可读+可写，比如 <code>net.Socket()</code>。</li>
<li>Transform：在读写的过程中，可以对数据进行修改，比如 <code>zlib.createDeflate()</code>（数据压缩/解压）。</li>
</ul>
<h3 id="Readable-Stream"><a href="#Readable-Stream" class="headerlink" title="Readable Stream"></a>Readable Stream</h3><p>以下都是nodejs中常见的Readable Stream，当然还有其他的，可自行查看文档。</p>
<ul>
<li>http.IncomingRequest</li>
<li>fs.createReadStream()</li>
<li>process.stdin</li>
<li>其他</li>
</ul>
<p>例子一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./sample.txt'</span>, <span class="string">'utf8'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, content</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 文件读取完成，文件内容是 [你好，我是程序猿小卡]</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'文件读取完成，文件内容是 [%s]'</span>, content);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>例子二：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readStream = fs.createReadStream(<span class="string">'./sample.txt'</span>);</span><br><span class="line"><span class="keyword">var</span> content = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">readStream.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"></span><br><span class="line">readStream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">	content += chunk;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readStream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">	<span class="comment">// 文件读取完成，文件内容是 [你好，我是程序猿小卡]</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'文件读取完成，文件内容是 [%s]'</span>, content);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>例子三：</p>
<p>这里使用了<code>.pipe(dest)</code>，好处在于，如果文件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line">fs.createReadStream(<span class="string">'./sample.txt'</span>).pipe(process.stdout);</span><br></pre></td></tr></table></figure>

<p>注意：这里只是原封不动的将内容输出到控制台，所以实际上跟前两个例子有细微差异。可以稍做修改，达到上面同样的效果</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> onEnd = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	process.stdout.write(<span class="string">']'</span>);	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fileStream = fs.createReadStream(<span class="string">'./sample.txt'</span>);</span><br><span class="line">fileStream.on(<span class="string">'end'</span>, onEnd)</span><br><span class="line"></span><br><span class="line">fileStream.pipe(process.stdout);</span><br><span class="line"></span><br><span class="line">process.stdout.write(<span class="string">'文件读取完成，文件内容是['</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件读取完成，文件内容是[你好，我是程序猿小卡]</span></span><br></pre></td></tr></table></figure>

<h3 id="Writable-Stream"><a href="#Writable-Stream" class="headerlink" title="Writable Stream"></a>Writable Stream</h3><p>同样以写文件为例子，比如想将<code>hello world</code>写到<code>sample.txt</code>里。</p>
<p>例子一：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> content = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="keyword">var</span> filepath = <span class="string">'./sample.txt'</span>;</span><br><span class="line"></span><br><span class="line">fs.writeFile(filepath, content);</span><br></pre></td></tr></table></figure>

<p>例子二：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> content = <span class="string">'hello world'</span>;</span><br><span class="line"><span class="keyword">var</span> filepath = <span class="string">'./sample.txt'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> writeStram = fs.createWriteStream(filepath);</span><br><span class="line">writeStram.write(content);</span><br><span class="line">writeStram.end();</span><br></pre></td></tr></table></figure>

<h3 id="Duplex-Stream"><a href="#Duplex-Stream" class="headerlink" title="Duplex Stream"></a>Duplex Stream</h3><p>最常见的Duplex stream应该就是<code>net.Socket</code>实例了，在前面的文章里有接触过，这里就直接上代码了，这里包含服务端代码、客户端代码。</p>
<p>服务端代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">var</span> opt = &#123;</span><br><span class="line">	host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">	port: <span class="string">'3000'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = net.connect(opt, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	client.write(<span class="string">'msg from client'</span>);  <span class="comment">// 可写</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可读</span></span><br><span class="line">client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// server: msg from client [msg from client]</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'client: got reply from server [%s]'</span>, data);</span><br><span class="line">	client.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>客户端代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">var</span> opt = &#123;</span><br><span class="line">	host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">	port: <span class="string">'3000'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = net.connect(opt, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	client.write(<span class="string">'msg from client'</span>);  <span class="comment">// 可写</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可读</span></span><br><span class="line">client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// lient: got reply from server [reply from server]</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'client: got reply from server [%s]'</span>, data);</span><br><span class="line">	client.end();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Transform-Stream"><a href="#Transform-Stream" class="headerlink" title="Transform Stream"></a>Transform Stream</h3><p>Transform stream是Duplex stream的特例，也就是说，Transform stream也同时可读可写。跟Duplex stream的区别点在于，Transform stream的输出与输入是存在相关性的。</p>
<p>常见的Transform stream包括<code>zlib</code>、<code>crypto</code>，这里举个简单例子：文件的gzip压缩。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> zlib = <span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gzip = zlib.createGzip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> inFile = fs.createReadStream(<span class="string">'./extra/fileForCompress.txt'</span>);</span><br><span class="line"><span class="keyword">var</span> out = fs.createWriteStream(<span class="string">'./extra/fileForCompress.txt.gz'</span>);</span><br><span class="line"></span><br><span class="line">inFile.pipe(gzip).pipe(out);</span><br></pre></td></tr></table></figure>

<h3 id="相关链接-2"><a href="#相关链接-2" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://nodejs.org/api/stream.html" target="_blank" rel="noopener">https://nodejs.org/api/stream.html</a></p>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>nodeJs入门系列</tag>
      </tags>
  </entry>
  <entry>
    <title>极速入门Node·Vue·React服务器部署</title>
    <url>/2020/04/21/%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8Node%C2%B7Vue%C2%B7React%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="你为什么要学习部署上线？"><a href="#你为什么要学习部署上线？" class="headerlink" title="你为什么要学习部署上线？"></a>你为什么要学习部署上线？</h2><p>试想，你用 Node.js 开发了一个网站，一个 App，一个小程序，一个公众号，或者是一个 API 服务器的后台，然后你一直藏在电脑的后面，默默的写着代码，静静的看着效果，却没有足够的信心，把开发的产品，扔到互联网上！</p>
<p>那如何凭借一人之力，把一个 Nodejs 的项目部署到互联网的某台服务器上去，完成一个项目的 “最后一公里” 呢？</p>
<p>这一公里，隔断了前端和后端，隔断了本地和上线，隔绝了此时此刻的你和明天你期望的全栈，这一公里，有域名和服务器的选购备案，有域名到 IP 的解析指向，有服务器的远程连接与系统权限，有 Node.js 生产环境的搭建，有数据库的安装配置和备份，有单台主机多个应用的端口代理和映射，有项目源代码从本地同步到线上，有远程自动化的项目更新发布与服务器的平滑重启，这一公里很短，却有很多你意想不到的 “坑”。</p>
<p>那我来帮你走完这最后一公里，让你的全栈成为可能，让你从前端走向后端，我会利用无数据库的静态站点、有数据库的电影站点、Vue 纯前端项目、React/Egg 前后端分离这 4 个项目，演示全部的流程，从如何购买主机，如何域名解析，如何配置环境，一直到数据库的自动备份，项目的部署上线，让你足够应对绝大多数的部署上线工作。</p>
<a id="more"></a>

<p><strong>部署上线，要把一个 Node 项目成功部署上线会涉及这几个技能点：</strong></p>
<ul>
<li>域名与云服务器的选购与备案</li>
<li>基于 Ubuntu/CentOS 或者其他 Linux 系统的配置</li>
<li>Node.js 环境的线上配置</li>
<li>基于 iptables 防火墙和 Fail2Ban 动作防御等对于服务器和 web 服务的保护</li>
<li>线上 MongoDB 数据库的安装配置与权限角色，库表导入导出与迁移备份</li>
<li>Nginx 作为前置引擎映射端口进行服务识别和转发</li>
<li>SSL 证书的申请安装与配置</li>
<li>项目部署上线的 PM2 的配置使用和服务守护</li>
</ul>
<h2 id="部署Node项目重要的技术："><a href="#部署Node项目重要的技术：" class="headerlink" title="部署Node项目重要的技术："></a>部署Node项目重要的技术：</h2><p>首先，先看下发布部署 Node 项目会用到的几个重要的技术：</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421131904.png" alt=""></p>
<p>整个部署的流程自下向上、自左向右的操作流程如下：</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421131927.png" alt=""></p>
<h2 id="Node-js-诞生简要回顾"><a href="#Node-js-诞生简要回顾" class="headerlink" title="Node.js 诞生简要回顾"></a>Node.js 诞生简要回顾</h2><p>大家都知道，前端跟后端有着难以逾越的门槛，它包括语言和系统知识门槛，知识门槛（网络知识、操作系统知识）还可以慢慢看书充电，但语言门槛还是会很大程度上增加新手的学习难度，更不要提把一个后端语言的服务，手动部署到线上了，<strong>而 Node.js 的诞生则打破了这个局面，让前后端可以用 JavaScript 一门语言横跨前后端。</strong></p>
<p>因为 Node.js 底层是 Chrome V8 对 JavaScript 代码进行编译和执行，所以天然支持 Javascript 语法特性，那么你写惯了 JavaScript 代码，使用 Node.js 也自然会很顺手的。</p>
<blockquote>
<p>阿特伍德定律：“Any application that can be written in JavaScript, will eventually be written in JavaScript”，任何可以用 JavaScript 来写的应用，最终都将用JavaScript 来写。</p>
</blockquote>
<p>这是早在 2007 年，Jeff Atwood 在文章中提出的观点，那时候 Node.js 还没出现，作者对 JavaScript 的前途是非常看好的，到今天为止，这个定律也基本已经被证实了。</p>
<p>与此同时，有一个程序员，名字叫做 Ryan Dahl，那时候 Ruby on Rails 很火，他也不例外地学习了它。早期的时候 Ryan Dahl 的生活方式就是接项目，然后去客户的地方工作，在他眼中，拿工资和上班其实就是去那里旅行。</p>
<p>此后他去了阿根廷的布宜诺斯艾利斯、德国科隆、奥地利的维也纳这些地方为当地的客户服务，在经过两年的工作后，Ryan Dahl 成为了高性能 Web 服务器的专家，从开发应用到变成专门帮客户解决性能问题的专家。</p>
<p>期间他开始写一些开源项目帮助客户解决 Web 服务器的高并发性能问题，尝试过的语言有 Ruby、C、Lua，当然这些尝试都最终失败了，只有其中通过 C 写的 HTTP 服务库 libebb 项目略有起色，基本上算作 libuv 的前身。</p>
<p>这些失败各有各的原因：</p>
<ul>
<li>Ruby 因为虚拟机性能太烂而无法解决根本问题；</li>
<li>C 代码的性能高，但是让业务通过 C 进行开发太多底层显然是不太现实的事情；</li>
<li>Lua 则是已有的同步 I/O 导致无法发挥性能优势。</li>
</ul>
<p>虽然经历了失败，但 Ryan Dahl 大致的感觉到了解决问题的关键是要通过事件驱动和异步 I/O 来达成目的，在他快绝望的时候，V8 引擎来了，V8 满足他关于高性能 Web 服务器的想象：</p>
<ul>
<li>没有历史包袱，没有同步 I/O，不会出现一个同步 I/O 导致事件循环性能急剧降低的情况</li>
<li>V8 性能足够好，远远比 Python、Ruby 等其他脚本语言的引擎快</li>
<li>JavaScript 语言的闭包特性非常方便，比 C 中的回调函数好用</li>
</ul>
<p>于是在 2009 年的 2 月，按照这个想法他提交了项目的第一行代码，这个项目的名字最终被定名为 “Node”，2009 年 5 月，Ryan Dahl 正式向外界宣布他做的这个项目</p>
<p>2009 年底，Ryan Dahl 在柏林举行的 JSConf EU 会议上发表关于 Node.js 的演讲，之后 Node.js 逐渐流行起来，这就是 Node.js 项目的由来，也是一个普通程序员的励志奋斗史，从一个专注于实现高性能 Web 服务器优化的程序员，几经探索几经挫折后，遇到 V8 而诞生了一个风靡全球的项目。</p>
<p>此时 36 岁的 Ryan Dahl 还不知道，Node.js 将怎么深远的影响到全球的整个开发者生态，因为自此之后，这短短 10 年，Node.js 走完了其他语言可能需要 20 年才能走完的路，无论是在前端开发者群体里还是服务端开发者群体中，都得到了广泛而深入的应用，Node 本身的版本发展也像坐火箭一样，一跃冲天，自此前后端不可逾越的疆界也被打开了。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421132824.png" alt=""></p>
<p><strong>小结</strong></p>
<p>疆界一旦打开，便如洪水之势一般，迅速蚕食可被重塑重构的地带，而 Node.js 就在扮演这样的“洪水猛兽”，不仅在前端的生态里攻城掠地，也在前后端的边界包括后端领域强势推进，直到它把整个开发生态翻个底朝天再也无可拓展市场才会放缓停止。</p>
<h2 id="要不要学习-Node-js？"><a href="#要不要学习-Node-js？" class="headerlink" title="要不要学习 Node.js？"></a>要不要学习 Node.js？</h2><p>这一篇专栏我们会对要不要学习 Node.js 进行讨论，分别从前端开发、后端开发、运营和产品经理的角度出发，来分析学习 Node.js 对各自的本职工作会带来怎么样的便利。</p>
<p>Node.js 的前世今生我们已经了解了，那真的需要学习它么，对我有什么直接可见的好处呢，我们来角色扮演一下。</p>
<p><strong>如果你是前端开发工程师</strong></p>
<p>你本地电脑上一定会要安装 Node.js，它作为工具也好，作为服务器也好，会帮助你处理完很多又脏又累的事情，比如 LESS/SCSS 的编译，ES6/7 到 ES5 的转换，JavaScript 代码的压缩合并，切换页面调试样式的热更新，无论是通过社区迅速更新换代的 Grunt/Gulp/Webpack，还是通过自己集成或者定制到本地的其他模块，Node.js 的这个运行环境都是你得力的助手。</p>
<p><strong>如果你是后端开发工程师</strong><br>如果你之前是 PHP 或 Java 工程师，最近转行做 Node.js， 或者想要增加一个语言技能才来学习 Node.js，你不可避免的要去了解 ES5/6/7， 或者说 JavaScipt 的整个语法，去翻阅 Node.js 的各个 API，最后借助 Node.js 社区的一些流行框架，比如 Express/Koa，甚至是阿里开源的 Egg，用你现有的后端开发经验（对于 Web 服务层交互的知识）再套上这些框架的 API，来玩票性质的搭建一些子项目，运行一些产品业务。</p>
<p><strong>如果你是运营或者产品经理</strong><br>通常喜欢鼓捣的运营和产品经理，会对代码有一定的接触，事实上我认识的不少产品经理对 Express/React/Vue 这些很喜欢，能高效的帮他们实现一些产品原型的测试，已具备了一些基本的开发技能，比如 HTML/CSS/JavaScript，还有 Linux 主机的系统使用，域名解析也有一些经验，在不去学习另外一种全新的语言下，你可能也更愿意，借助 Node.js 搭建你的 Web 服务，帮你的小点子、小创意快速上线测试，获取一些用户的反馈或者价值验证。</p>
<p>以上举例，其实是为了说明影响你职业发展的其中一个因素，便是某项技能的深度，或者是某些技能的广度，这些技能不限于前端后端或者产品，不要给自己设限。</p>
<p>从事某个工种，不代表你只可以钻研这个工种，就拿前端举例，既然本地有了 Node.js 的运行环境，那么适度的往下扩展技能树，是顺水推舟的事情，而对 Node.js 很感兴趣的无论任何职业的人来说，什么时候学习它都不晚，因为整个互联网经过几十年的发展目前的现状就是： JavaScript 成为了 Web 层最容易入门语言，而且最被工业标准和厂商推广的语言，掌握了它，就掌握了 Node.js 的 1/3，剩下的 2/3 分别是 HTTP 知识和 Node.js 本身的运行机制的系统能力。</p>
<h2 id="搭建线上生产环境需要做什么？"><a href="#搭建线上生产环境需要做什么？" class="headerlink" title="搭建线上生产环境需要做什么？"></a>搭建线上生产环境需要做什么？</h2><p>这一小节我们就开始真正的课程主题内容了，我们先来说一说搭建配置一个线上生产环境，把应用部署到服务器中，通过域名再暴露到互联网上，需要几个步骤来完成它，它们是购买域名、购买服务器、备案、服务环境配置、数据库配置运维、项目部署发布。下面我们来分别看看它们各自的大概意思，后面会有相应篇幅来详细讲解它们的步骤。</p>
<h3 id="一、购买域名"><a href="#一、购买域名" class="headerlink" title="一、购买域名"></a>一、购买域名</h3><p>我们要做的第一件事情是，购买一个属于自己的域名，虽然 IP 地址也可以访问到资源，但是 IP 不够友好不容易记住，而且一些第三方应用平台对于 IP 的支持度也不够，比如苹果商店和微信小程序是不支持 IP 绑定的，必须是域名，而域名的访问协议还必须是 HTTPS 的，所以域名这个一定需要买，关于在哪里买、如何购买、生成 HTTPS 的证书，域名的解析等等，后面章节会有介绍。</p>
<h3 id="二、购买服务器"><a href="#二、购买服务器" class="headerlink" title="二、购买服务器"></a>二、购买服务器</h3><p>搞定域名后，第二件事情是需要购买一个服务器，无论它是共享的还是独享的，可以理解为一台带外网 IP 的电脑，在这台服务器上，我们会把服务端的 Node.js 代码部署上去，启动后，我们会监听 80 端口的请求，然后根据一些转发机制，比如通过 Nginx 来把这些请求转发到这个 Node.js 的服务端口上，让它接管以及给予响应。</p>
<h3 id="三、备案"><a href="#三、备案" class="headerlink" title="三、备案"></a>三、备案</h3><p>第三件事情，就是购买域名和购买服务器后，通过服务器的配置提供一个可外面访问的网站，我们需要对这个域名进行备案，几年前，备案是让站长十分头疼的事情，现在已经容易多了，为什么要备案的原因我相信你懂的，除非你是在国外提供服务，什么都在国外，但是只要你对国内提供一些服务或者使用一些服务，比如你想用一些短信服务或者邮件服务，包括基于微信公众号和小程序的服务，备案都是我们作为公民要去遵守的一个规范，这个专栏中我也会告诉大家如何备案。</p>
<h3 id="四、服务环境配置"><a href="#四、服务环境配置" class="headerlink" title="四、服务环境配置"></a>四、服务环境配置</h3><p>第四件事情，就是服务器的配置，这个配置包含：</p>
<ul>
<li>用户权限和无密码登录</li>
<li>Node.js 环境和必备包组件安装搭建</li>
<li>端口转发</li>
<li>HTTPS 证书的生成配置</li>
<li>Nginx 的安装配置</li>
<li>防火墙</li>
<li>本地数据库</li>
<li>自动备份机制等</li>
</ul>
<h3 id="五、数据库配置运维"><a href="#五、数据库配置运维" class="headerlink" title="五、数据库配置运维"></a>五、数据库配置运维</h3><p>第五件事情，就是数据库，这个跟服务器配置强相关，如果我们使用服务器上安装的本地数据库的话（如果是用云数据库，就不需要这一步了，不过云数据库一般价格不菲，我们还是尽量选择免费的东西，让大家尽量低成本地学习），服务器的本地数据库就会涉及数据库的角色、读写权限和自动备份机制，这里面会有很多坑，也有很多容易让人望而却步的流程，所以也会单独拎出来讲。</p>
<h3 id="六、项目部署发布"><a href="#六、项目部署发布" class="headerlink" title="六、项目部署发布"></a>六、项目部署发布</h3><p>第六件事情，就是项目的部署发布，我们可以粗暴的把代码拷贝和上传，比如 FTP 到服务器中启动，但是这样低效也容易出错，现在可以选择的方式很多。</p>
<p>我个人推荐使用付费或者是免费但私密的第三方 Git 仓库平台。</p>
<p>把本地代码自动化部署到线上，本地一句命令，就可以实现服务器自动拉代码，拉分支，部署代码，然后在线上自动重启，整个过程尽量的傻瓜化，通过技术来解决效率问题。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421140424.png" alt=""></p>
<h2 id="准备待部署的项目"><a href="#准备待部署的项目" class="headerlink" title="准备待部署的项目"></a>准备待部署的项目</h2><p>要想学习布署项目到服务器上发布，咱们总得有项目吧，这一篇我们就准备了 4 个非常具有代表性的项目：纯静态站点、前端项目、前后端分离的项目，以及带有数据库的项目。现在我们来熟悉下它们的结构，最后预览下部署后访问时的效果，通过这个过程，我们会了解到前端静态项目，和后端服务发布到网上会是什么样的效果。</p>
<h3 id="案例-1：快速搭建一个纯静态简易站点"><a href="#案例-1：快速搭建一个纯静态简易站点" class="headerlink" title="案例 1：快速搭建一个纯静态简易站点"></a>案例 1：快速搭建一个纯静态简易站点</h3><p>第一个项目，我们设计一个简单的静态站点，只有一个网站首页，我们不依赖任何第三方的框架库或模块，用纯的 Node.js 原生 API 来实现。</p>
<p>好，现在我们在本地新建一个项目文件夹，名字叫 node-deploy-static，里面只有一个 app.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> homePage = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">  &lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">      &lt;meta charset="utf-8"&gt;</span></span><br><span class="line"><span class="string">      &lt;title&gt;Node.js 部署上线示例&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;Nodejs 部署发布&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.statusCode = <span class="number">200</span></span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)</span><br><span class="line">  res.end(homePage)</span><br><span class="line">&#125;).listen(<span class="number">5000</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server running at 5000'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>然后在本地 node app 我们把这个项目测试一下，跑起来服务后，网页中打开 <a href="http://127.0.0.1:5000" target="_blank" rel="noopener">http://127.0.0.1:5000</a> 或者命令行中执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">➜  curl http:<span class="comment">//127.0.0.1:5000</span></span><br></pre></td></tr></table></figure>
<p>返回内容是一个 HTML 文档：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Node.js 部署上线示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Nodejs 部署发布<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这就是一个纯静态的极简项目，但是要把它部署到线上，也是要有一些方法论和流程在里面的，后面会给大家讲解。</p>
<h3 id="案例-2：准备一个-Vue-的前端站点"><a href="#案例-2：准备一个-Vue-的前端站点" class="headerlink" title="案例 2：准备一个 Vue 的前端站点"></a>案例 2：准备一个 Vue 的前端站点</h3><p>除了纯静态项目（用纯的 Node.js 原生 API 来实现的），我们还准备了一个 Vue 的前端项目，部署 Vue 前端项目的资源有很多种方式，最简易的一种是在本地编译后，把编译后的资源再同步到服务器上，再进阶一些，会把 JS/CSS、图片这些静态资源单独传到图床上，然后把图床的地址拿回来替换到 HTML 文件中，最终往服务器上部署的是这个 HTML 文件。</p>
<p>这里为你们准备了一个简单的 Vue 前端站点项目 demo，我们要把这样的一个项目部署上线，它的项目结构很简单，首先是 index.html：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width,initial-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;title&gt;Vue 前端站点部署案例&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;div id=<span class="string">"app"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后会有一个 main.js 来作为入口文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>以及站点的首页模板 App.vue：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">    &lt;img src=<span class="string">"./assets/logo.png"</span>&gt;</span><br><span class="line">    &lt;Demo /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">import</span> Demo <span class="keyword">from</span> <span class="string">'./components/demo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'App'</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    Demo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;style&gt;</span></span><br><span class="line"><span class="regexp">#app &#123;</span></span><br><span class="line"><span class="regexp">  font-family: 'Avenir', Helvetica, Arial, sans-serif;</span></span><br><span class="line"><span class="regexp">  -webkit-font-smoothing: antialiased;</span></span><br><span class="line"><span class="regexp">  -moz-osx-font-smoothing: grayscale;</span></span><br><span class="line"><span class="regexp">  text-align: center;</span></span><br><span class="line"><span class="regexp">  color: #2c3e50;</span></span><br><span class="line"><span class="regexp">  margin-top: 60px;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>style&gt;</span><br></pre></td></tr></table></figure>
<p>最后是首页的内容模板 demo.vue：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"hello"</span>&gt;</span><br><span class="line">    &lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;搭建配置一个线上生产环境，把应用部署到服务器中，通过域名再暴露到互联网上，主要有这几件事情大家需要了解下：     &lt;/</span>p&gt;</span><br><span class="line">&lt;<span class="regexp">/template&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script&gt;</span></span><br><span class="line"><span class="regexp">export default &#123;</span></span><br><span class="line"><span class="regexp">  data () &#123;</span></span><br><span class="line"><span class="regexp">    return &#123;</span></span><br><span class="line"><span class="regexp">      msg: 'Vue 前端项目部署案例'</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped&gt;</span><br><span class="line">  .hello &#123;</span><br><span class="line">    width: <span class="number">680</span>px;</span><br><span class="line">    margin: <span class="number">0</span> auto;</span><br><span class="line">    text-align: left;</span><br><span class="line">  &#125;</span><br><span class="line">  h1 &#123;</span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>
<p>主要的代码就这些了，大家可以直接 vue-cli 来跑个模板项目，然后把刚才这些代码参考上面修改一下就可以了</p>
<h3 id="案例-3：准备一个-Node-MongoDB-服务端渲染的站点"><a href="#案例-3：准备一个-Node-MongoDB-服务端渲染的站点" class="headerlink" title="案例 3：准备一个 Node + MongoDB 服务端渲染的站点"></a>案例 3：准备一个 Node + MongoDB 服务端渲染的站点</h3><p>现在稍微复杂一些的网站项目都需要信息存储，比如用户、账号、密码等登录信息，这就需要数据库的支持。我们的课程也为大家准备了这样的一个带有 MongoDB 数据库的网站项目。</p>
<h3 id="如何部署这几个项目呢"><a href="#如何部署这几个项目呢" class="headerlink" title="如何部署这几个项目呢"></a>如何部署这几个项目呢</h3><p>这里给大家用简单的一句话介绍一下这几个项目大概的布署方法，后面会手把手给大家进行详细讲解。所以这里看不懂的同学不要着急。</p>
<ul>
<li><p>对于纯静态简易站点，部署的办法非常简单，只需要把资源同步到服务器上即可，我们给它一个域名来访问，</p>
</li>
<li><p>对于 Vue 的前端网站，部署的时候需要把必要的资源编译上传好，最后把 HTML 文件同步到服务器上后，通过 Nginx 代理就行，我们同样给它一个域名来访问</p>
</li>
<li><p>对于有数据库的站点，我们部署的时候，主要就是更新代码后重启服务，但需要额外把数据库相关的事情都处理好，包括 SSL 证书的集成，我们给它分配一个域名</p>
</li>
</ul>
<h2 id="域名与云服务器的选购与备案"><a href="#域名与云服务器的选购与备案" class="headerlink" title="域名与云服务器的选购与备案"></a>域名与云服务器的选购与备案</h2><p>这一篇专栏，主要讲解我前面讲到的前三步中的 ”准备工作“，包括购买域名、购买服务器，还有最后的备案。</p>
<h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>出售域名的厂商有很多，比如国外的 GoDaddy，国内的阿里云，大家百度随便搜一下，也是一抓一大把，我个人购买域名，通常会看厂商背景，而不会特别在意它的价格，原因是服务好的厂商对于域名的管理、解析甚至备案都有较好的流程可以保障。而小厂商的服务可能比较薄弱，很可能会倒闭跑路。</p>
<p>如果大家考虑备案的话，域名尽量从国内买</p>
<p>如果是从阿里云购买了域名，会有一个管理域名的列表：<br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421141700.png" alt=""></p>
<h3 id="购买阿里云服务器"><a href="#购买阿里云服务器" class="headerlink" title="购买阿里云服务器"></a>购买阿里云服务器</h3><p>现在是云的时代，许多公司的服务器也通常是部署到云上的，再也不像 10 年前，可能需要抱着机器到某地的一个机房，去换配件、架网线、装系统，现在通过云主机，可以方便的对外提供服务。</p>
<p>那么大家选择主机时，应该选择什么样配置的主机，多高价位的主机，哪家厂商的主机呢？老实讲，关于这个问题，我很难做到绝对客观公正，只能从我自身的使用经验来看，过去的 10 年中，我用过 Windows 主机，Lamp 标配主机，朋友自己在机房承包的主机，共享的虚拟主机，一直到三四年前开始尝试使用青云、ucloud、阿里云、包括国外的 DigitalOcean、PSY、Linode 主机、亚马逊的主机，甚至是可以直接部署 Node.js 应用的 Heroku，百度云 等等，这些主机机房有在香港的、东京的、新加坡的、马来西亚的、旧金山的，甚至我还折腾过部署树莓派的主机。</p>
<p>这么多年折腾下来，我最大的感受是，自己的青春，无数个夜晚都浪费在主机的选择和无谓的折腾上了，如果让我重新选择，我情愿选择一两家主流厂商使用到底，而不是完全从成本和追风热情上主观折腾。这里给大家分享以下几点建议。</p>
<p><strong>1. 尽量选择大厂商或知名厂商的主机</strong><br>不要只图便宜，没有强大背景的创业公司所推出的主机尽量不要选择，因为有的后面会倒闭，会被收购，就比如 nodejistu，后来被 GoDaddy 收购了整个团队，导致 nodejistu 云主机逐步被关闭了，如果你是它的用户，迁移业务的时候会无比痛苦。那么哪些算是知名厂商或者大厂商呢？在我的心目中也就只有阿里云、亚马逊 AWS、Linode、DigitalOcean、heroku 云平台等，如果让我选择，我会首选阿里云。</p>
<p><strong>2. 尽量选择国内的主机商</strong><br>跟域名一样，你会面临不可越过的一关，就是备案和国家的监控审核，选择国内的主机，最起码的一点，你基本上不会被那个众所周知的原因，拦截掉你的服务，其次审核备案什么的，也基本都能快速通过。同时因为你机子在国内，无论是华东机房，还是青岛机房，你连上服务器的时间都在几十毫秒之内，远程操作会比较便捷。而要说国内的主机商，我掰着指头算算，也就剩下阿里云了。像青云、 UCloud、 百度云等，我都使用过，在客服的跟进速度，平台的技术背景，被阿里云拉开不是一条街。当然也不是不能考虑，比如我之前就把我的一个公司业务部署到了 UCloud 上面，后来有了一次事故，UCloud 给我赔了 3000 多块钱代金券，让我免费用一年，服务的诚意还是满满的，但是最后我还是选择迁移到阿里云。如果你想要稳定的服务，那么可以毫不犹豫的选择阿里云，不要太考虑价格，因为现在试图通过小厂商省下的钱，都会在其他方面让你几倍几十倍的偿还，特别是时间成本。</p>
<p>这样的建议比较有偏向性，因为发现好像只剩下阿里云可选了，这一次的教学内容，也确实是使用阿里云 ECS 主机来讲解，我个人也是强烈建议，如果你是服务器新手，对服务器接触较少，请务必购买阿里云服务器来跟进，当然你动手能力强的话，选别的也可以，只是有可能要花更数倍的时间折腾服务器，可能因小失大不太划算。</p>
<p>选定厂商之后，就是购买服务器和购买域名，大家只要有微信和支付宝或者银行卡，很容易操作，我就不再演示，另外选购阿里云主机或者其他厂商主机的时机，可以凑 618/双 11/双 12 这样的大促活动日来购买，会更实惠一些。</p>
<p><strong>域名备案流程走起来</strong><br>在远程登录我们的服务器之前呢，我们先插一节，先把域名的备案流程走起来，如果是通过阿里云购买的云服务器和域名，那就可以从阿里云这里的平台进行备案，如果没有购买阿里云的服务器，是不能通过阿里云进行备案的，所以服务对于平台的依赖还是很强的，大家也可以选择从自己服务器或者网络提供商的平台进行备案，比如 UCloud 或者电信联通，我自己没有实际弄过，可能会比较麻烦。</p>
<p>在之前我从阿里云这里走过好几次备案流程，备案过四五个域名，有的是从公司的账户走，有的从我个人的域名走，其他的云服务商我没有尝试过，没有对比，但阿里云的备案流程，我个人觉得还是比较完善，比较快捷的。</p>
<h3 id="如何购买阿里云的-MySQL-数据库-RDS"><a href="#如何购买阿里云的-MySQL-数据库-RDS" class="headerlink" title="如何购买阿里云的 MySQL 数据库 RDS"></a>如何购买阿里云的 MySQL 数据库 RDS</h3><p>我们后文中会使用 MongoDB 数据库来介绍项目部署，如果大家不想选择 MongoDB，想用付费的数据库比如阿里云，可以参考我这里的流程，我特意购买了 Aliyun RDS 数据库，来给大家演示下购买流程，先打开 RDS <a href="https://cn.aliyun.com/product/rds/mysql" target="_blank" rel="noopener">阿里云首页</a>：</p>
<p>大家购买可以按量付费也可以按年付费，如果学习的话可以选择按量付费，如果商业用途个人建议是包年包月，如果按量付费的话，钱不够就会提醒感觉有点麻烦。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421142523.png" alt=""></p>
<p>然后在主界面，先给数据库增加 IP 白名单，只允许特定 IP 的内网机器访问，这样可以保障服务器的安全性：</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421142559.png" alt=""></p>
<p>然后来给数据库创建一个登录账号：</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421142618.png" alt=""></p>
<p>创建后，有账号也有白名单了，就可以通过它提供的连接地址，在项目中通过 SQL 的三方组件库连接开发业务了。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421142653.png" alt=""></p>
<h2 id="远程登录：ssh远程登录服务器"><a href="#远程登录：ssh远程登录服务器" class="headerlink" title="远程登录：ssh远程登录服务器"></a>远程登录：ssh远程登录服务器</h2><p><strong>第一次 ssh 远程登录服务器</strong><br>本篇我们来学习一个非常实用的技能——无密码登录服务器。原理很简单，就是让服务器存一份本地的公钥，借助本地和服务器之间的一个认证机制，可以不输入密码直接登录服务器。这在往服务器多次发布资源的时候非常实用，不然你每次往服务器上传资源或者通过服务器调用程序下载第三方资源，都要输入密码，太麻烦了，而且时间久了密码也容易忘记。 登录服务器，再也不用腰上挂一堆钥匙了，到家门口直接指纹开门。</p>
<p>拿到服务器的第一件事，当然就是得连上服务器，是通过 ssh 从本地连上我们的服务器，Windows 下可以用 <code>PuTTY</code>,<code>xshell</code>这样的工具，在 Windows 下其实有很多不错的工具，比如 wsl-terminal、babun 等，在 Mac 下我们用终端就可以。</p>
<p>登录服务器，需要你先拿到服务器的外网 IP，也就是阿里云控制台上的这个外网 IP：</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421142927.png" alt=""></p>
<p>服务器默认用户名通常是 root，我们按照阿里云的来，首次我们登录进去，一般都会用 root 来深入虎穴，利用终端的 ssh 命令 + 空格，跟上 用户名@ip 就像邮箱一样，直接回车就可以了：</p>
<blockquote>
<p>提示：其他的云服务商不一定是 root 账号，比如 UCloud 用的是 ubuntu 作为默认的登录账号。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh 命令 + 空格，跟上 用户名@ip</span><br><span class="line">ssh root@xx.xx.xx.xx</span><br></pre></td></tr></table></figure>

<p>这时候，你其实在要告诉它，hi， 那个 xx.xx.xx.xx 的 ip，我是 root 国王，快给我开城门，迎接我微服私访。</p>
<p>注意，在此时要登录的时候，如果遇到一个英文的提示，问你，是否同意授权，因为这是你本地的电脑，第一次连上远程的一个不认识的主机，它很紧张，屏幕上会出现一连串提示（如下面显示），意思是无法确认 host 主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？直接输入 yes 回车就可以了。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">The authenticity of host '123.123.123.123 (123.123.123.123)' can't be established.</span><br><span class="line">ECDSA key fingerprint is</span><br><span class="line">79:95:46:1a:ab:37:11:8e:86:54:36:38:bb:3c:fa:c0.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>
<p>但是一群小的们不甘心啊，你谁啊你，凭什么给你开啊，出示传国玉玺。对，就是要登录密码啊</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@47.110.39.55's password:</span><br><span class="line">Welcome to Ubuntu 16.04.3 LTS (GNU/Linux 4.4.0-93-generic x86_64)</span><br></pre></td></tr></table></figure>

<p>那我们就输入密码呗，也就是我们购买阿里云服务器时候配置的密码，输入密码的时候，密码是不显示的。</p>
<p><strong>无论是升级服务器后，还是第一次打开服务器，一定要先运行：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> update</span><br></pre></td></tr></table></figure>
<p>上面命令的作用是，先把服务器上所有的包和源都 check 和更新一遍，让服务器处在一个崭新的状态。</p>
<p>假如你预测某一天，你会使用到视频啊、图片合成啊，这些多媒体服务，可以把一些底层库先预装了，比如 node-canvas 依赖的库：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install build-essential libcairo2-dev libpango1.0-dev libjpeg-dev libgif-dev librsvg2-dev</span><br></pre></td></tr></table></figure>
<p>另外可以把一些常用的开发者套件也一并安装了，通过：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install -y software-properties-common</span><br></pre></td></tr></table></figure>
<p>这样安装后，如果我们想要安装比较新的 FFmpeg 处理视频图片的库，就可以这样来装了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo add-apt-repository ppa:jonathonf/ffmpeg<span class="number">-4</span></span><br><span class="line">sudo apt-<span class="keyword">get</span> update</span><br><span class="line">sudo apt-<span class="keyword">get</span> install ffmpeg</span><br><span class="line">ffmpeg -version</span><br><span class="line">// ffmpeg version 4.0.3-1~18.04.york0 Copyright (c) 2000-2018 the FFmpeg developers</span><br><span class="line">built with gcc 7 (Ubuntu 7.3.0-27ubuntu1~18.04)</span><br></pre></td></tr></table></figure>

<p><strong>考虑多购买一块数据盘</strong><br>另外有时候，我们选购服务器的时候，会多购买一块数据盘，这个数据盘就需要额外来挂载，记住，如果你没有购买多余的数据盘，这里是不需要额外挂载的哈。</p>
<p>购买服务器的时候，阿里云就默认给你挂载了一块硬盘，应该是 20GB 的大小，但是这个硬盘是用来安装操作系统的，什么意思呢？如果你把网站应用都跑在这个系统盘上也不是不可以，但是，一旦重装系统，所有的网站数据，比如用户资料都丢失了（因为操作系统和用户资料都放在了一张盘中），如果你是把数据资料挂载到数据盘上的，就能提高安全性。</p>
<p>查看是否有数据盘的命令是 <code>fdisk -l</code>，查看硬盘使用情况的命令是 <code>df -h</code>，我们先记住这一点知识就够用了，等到熟练掌握服务器的使用后，再来花时间研究如何挂载数据盘，其实就是格式化、分区这些更 Geek 一点的。</p>
<blockquote>
<p>补充：除了密码登录，我们还可以以私钥认证的方式登录，可以给不同的用户分配不同的私钥，每一个用户相当于是我们任命一个钦差大臣，由他干具体的活儿，有的活儿需要国王也就是 root 授权，有的可能不用，那么在启用新用户和配置私钥之前，我们先把 root 权限下把一些基础工作做掉，这个放到下一节来处理。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421143547.png" alt=""></p>
<h2 id="配置-root-权限账号与无密码登录"><a href="#配置-root-权限账号与无密码登录" class="headerlink" title="配置 root 权限账号与无密码登录"></a>配置 root 权限账号与无密码登录</h2><p>这一篇专栏主要为大家讲解服务器创建新账号、赋予账号权限，以及配置无密码本地登录这三部分内容。我会带领大家先创建一个新账号，然后给它分派一定的权限，最后再赋予它无密码登录的能力，这样这个新账号就不用每次登录服务器的时候都得输入一遍密码了</p>
<p>为什么要创建新的账号呢？root 权限是服务器这个大家庭里的 “一把手” 大 Boss，有至高无上的终极权限，因此我们不希望这个一把手老是抛头露面，而是找一个能干的人帮他做事，就像“冰与火之歌”里面的史塔克和龙妈身边的小恶魔，当国王外出的时候，他们做国王代理，管理天下大事。下面我们就创建这么一位代理。</p>
<h3 id="创建新账号"><a href="#创建新账号" class="headerlink" title="创建新账号"></a>创建新账号</h3><p>首先依然是在 root 登录的窗口下，执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">adduser rn_manager</span><br></pre></td></tr></table></figure>
<p>创建了一个 rn_manager 用户，在创建这个用户的时候，会提示你一堆信息，大体上就是给你创建个分组，给你造一个房子当新家，安上门牌号之类。</p>
<p>重点是要设置密码，千万要设置一个自己能记得住的，并且密码强度要大一些的，大小写数字特殊符号都用上，这样，就算别人知道了你的用户名，也很难破解你的密码。</p>
<p>至于信息可以省略不填，也可以填上，关系不大，如果输错密码了，可以选择 try again 重新填写，注意，输入字母 y 回车就行了，最后也是确认 y 并回车。</p>
<blockquote>
<p>提示：在输入之前一定要确保自己的输入法是英文状态，中文的话可能会把无关字符输进去。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Adding user <span class="string">`rn_deployer' ...</span></span><br><span class="line"><span class="string">Adding new group `</span>rn_deployer<span class="string">' (1000) ...</span></span><br><span class="line"><span class="string">Adding new user `rn_deployer'</span> (<span class="number">1000</span>) <span class="keyword">with</span> group <span class="string">`rn_deployer' ...</span></span><br><span class="line"><span class="string">Creating home directory `</span>/home/rn_deployer<span class="string">' ...</span></span><br><span class="line"><span class="string">Copying files from `/etc/skel'</span> ...</span><br><span class="line">Enter <span class="keyword">new</span> UNIX password:</span><br><span class="line">Retype <span class="keyword">new</span> UNIX password:</span><br><span class="line">Sorry, passwords <span class="keyword">do</span> not match</span><br><span class="line">passwd: Authentication token manipulation error</span><br><span class="line">passwd: password unchanged</span><br><span class="line">Try again? [y/N] y</span><br><span class="line">Enter <span class="keyword">new</span> UNIX password:</span><br><span class="line">Retype <span class="keyword">new</span> UNIX password:</span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information <span class="keyword">for</span> rn_deployer</span><br><span class="line">Enter the <span class="keyword">new</span> value, or press ENTER <span class="keyword">for</span> the <span class="keyword">default</span></span><br><span class="line">  Full Name []: Scott</span><br><span class="line">  Room <span class="built_in">Number</span> []: <span class="number">419</span></span><br><span class="line">  Work Phone []:</span><br><span class="line">  Home Phone []:</span><br><span class="line">  Other []:</span><br><span class="line">Is the information correct? [Y/n] y</span><br></pre></td></tr></table></figure>

<p>这里你在本地打开一个 txt 文件，或者找一张纸，找一只笔，把 rn_manager 这个账号及其密码记下来，一定要记下来啊，这个很容易忘记的，真的不骗你。</p>
<p>用户创建完以后，它只是一个普通的平民，手中的权力很小，我们需要对他进行授权，就是升官嘛，那怎么升呢？输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gpasswd -a rn_manager sudo</span><br></pre></td></tr></table></figure>
<p>上面通过 gpasswd 可以让 rn_manager 以 sudo 的方式调用系统命令。</p>
<h3 id="赋予账号更高权限"><a href="#赋予账号更高权限" class="headerlink" title="赋予账号更高权限"></a>赋予账号更高权限</h3><p>对于创建的这个用户，我们往往希望它的权限是蛮大的，可以像 root 一样能干。那么我们可以在 visudo 权限配置文件里面干脆配置一下，输入下面命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo visudo</span><br></pre></td></tr></table></figure>

<p>通过 sudo visudo 命令，来打开权限配置文件，往里面加入 <code>rn_manager ALL=(ALL:ALL) ALL</code> 这一行：</p>
<blockquote>
<p>补充：执行 sudo visudo 命令，默认是使用 nano 编辑器打开 visudo 文件。那么 nano 编辑器又是什么呢？使用 Linux 会经常和编辑器打交道，一般常用的是 vi 和 nano，虽然 vi 功能强大，但是相对新手来说稍微难上手，GNU nano 是一个体积小巧而功能强大的文本编辑器。</p>
</blockquote>
<p>使用 nano 编辑器，打开配置文件后，先忽略快捷键，可以通过上下键，上下移动光标，对代码进行编辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Defaults        env_reset</span><br><span class="line">Defaults        secure_path&#x3D;&quot;&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin&quot;</span><br><span class="line"></span><br><span class="line">root        ALL&#x3D;(ALL:ALL) ALL</span><br><span class="line">rn_manager    ALL&#x3D;(ALL:ALL) ALL   </span><br><span class="line"></span><br><span class="line">%admin      ALL&#x3D;(ALL) ALL</span><br><span class="line">%sudo       ALL&#x3D;(ALL:ALL) ALL</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">说明：这几行都是什么意思呢？</span><br><span class="line">第一行：重置终端环境，来移除一些用户信息。</span><br><span class="line">第二行：指定了一个路径，这个路径会被用来做 sudo 的操作。</span><br><span class="line">第四行：那么我们要增加的这一行，rn_manager 就是我们新加的用户名嘛，以下的规则就是对这个用户生效：</span><br><span class="line"></span><br><span class="line">第一个 ALL 是指定，这条规则对所有宿主生效</span><br><span class="line">第二个 ALL 是说，rn_manager 可以以任何用户来执行命令</span><br><span class="line">第三个是说，rn_manager 可以以任何组来执行命令</span><br><span class="line">最后一个ALL，是这个规则适用于所有命令</span><br><span class="line">上面说了这么多，总之， rn_manager 可以跟 root 一样，只要提供密码，就可以通过 sudo 运行任何命令。</span><br><span class="line"></span><br><span class="line">至于最后两行：</span><br><span class="line">%admin 和 %sudo 前面加个百分号，是指用户组的名字，可以发现 admin 用户组的用户可以在任何宿主环境内，执行任何命令，admin 的 sudo 都可以做到，权限它都有，并且可以执行任何用户组的操作。</span><br></pre></td></tr></table></figure>

<p>最后怎么保存呢，按下 ctrl+x，然后按下 shift+y，最后回车就好了。</p>
<p>大家对于这个权限组的概念可能一时半会搞不清楚，没关系，先这样用，等越来越熟悉了再去研究，这是一个渐进的学习过程。</p>
<p>那么我们来新开一个命令行窗口测试一下，记住，先不要关闭这个 root 窗口哈，我们还会用到的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ssh rn_manager@<span class="number">120.26</span><span class="number">.235</span><span class="number">.4</span></span><br></pre></td></tr></table></figure>

<p>测试输入密码（有可能是不能登录的，保险起见，我们切换到 root 登录的这个窗口下，来重启一下 ssh 服务的，代码如下）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">service ssh restart</span><br></pre></td></tr></table></figure>

<p>这时候可能会遇到这样的报错提示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br><span class="line">sudo: unable to resolve host iZbp162mggaelqtp8plk48Z</span><br></pre></td></tr></table></figure>
<p>host 无法解析了，这时候我们可以通过执行如下命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">echo $(hostname -I | cut -d\  -f1) $(hostname) | sudo tee -a /etc/hosts</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/hosts</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> localhost iZbp162mggaelqtp8plk48Z</span><br></pre></td></tr></table></figure>
<p>然后重新登录，同样 ssh 就是这种格式啊，用户名跟上 IP，输入密码登录，就 ok 了。</p>
<p>但是有没有发现，每次远程登录服务器，都要输入密码，好烦躁啊，能不能不输密码啊？当然可以了，接下来我们来配置无密码登录。</p>
<h3 id="配置无密码本地登录"><a href="#配置无密码本地登录" class="headerlink" title="配置无密码本地登录"></a>配置无密码本地登录</h3><p>关于无密码登录的原理限于时间，我就不展开也不解释了，总之是你本地电脑上一把钥匙，服务器上一把钥匙，每次登录之前，通过比对这两把钥匙，通过一些算法来判定，你是否是具有权限的那个用户。</p>
<p>那么，首先来本地电脑上配置这把钥匙，而且要生成两把钥匙，分别是私钥和公钥，我们将来会用到这把公钥。</p>
<blockquote>
<p>提示：如果你之前用过 GitHub 或者 GitLab 之类基于 Git 的仓库管理系统，那么你本地应该是配置过这个公钥和私钥的，这里要切记，不用再重复配置一遍了！不用重新配置一遍了！ 可能你会覆盖掉你本地用的钥匙，这样的话，你可能就连不上你之前有权限的 Git 仓库了，我会演示这一步。</p>
</blockquote>
<p>打开 Git Bash或者其它终端命令行工具<br>粘贴下面的文本（替换为您的 GitHub 电子邮件地址）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C "your_email@example.com"</span><br></pre></td></tr></table></figure>
<p>一路回车到底，对于新手这里就先不要设置密码了，不然就搞得太复杂了。执行完这一步命令之后，可以看到 .ssh 的目录下面生成了两个文件 id_rsa（私钥）和 id_rsa.pub（公钥），然后开起来 ssh 代理：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">"$(ssh-agent -s)"</span></span><br></pre></td></tr></table></figure>
<p>最后，把 ssh key 加入到 ssh 代理中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ssh-add ~<span class="regexp">/.ssh/i</span>d_rsa</span><br></pre></td></tr></table></figure>

<p>理论上走完这一步，你本地已经有了配置好的钥匙文件，强调一下，这里要切换到本地操作，不是服务器上，在本地的根目录的 ssh 文件夹下。</p>
<p>通过 cat 命令打印这个公钥文件内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cat .ssh/id_rsa.pub</span><br></pre></td></tr></table></figure>
<p>然后选中整段内容，复制一下，再来到服务器上。</p>
<p>然后，这一步很重要哈！这一步是为了，以后我们可以从 GitHub 或者 GitLab 之类的仓库获得仓库的权限，因此我们要把刚才生成私钥的过程重复一遍，这一步不做是不影响我们配置无密码登录的，再把刚才的流程走一遍，一模一样的步骤：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b <span class="number">4096</span> -C <span class="string">"your_email@example.com"</span></span><br><span class="line"><span class="built_in">eval</span> <span class="string">"$(ssh-agent -s)"</span></span><br><span class="line">ssh-add ~<span class="regexp">/.ssh/i</span>d_rsa</span><br></pre></td></tr></table></figure>

<p>然后，通过简单的 vim 命令，我们需要创建一个授权文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vi .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>会打开一个编辑页面，不要做任何输入，切记，不要做任何输入，同时要保证当前的输入法切换到英文输入状态，然后按下键盘上的 i 键后，command+v 把刚才复制的公钥拷贝进来，再按一下键盘上的 ESC 退出键确保回到编辑状态，然后同时按下 shift 和 冒号键，最后输入 wq! 回车，这个文件就自动创建了。这是简单的 vim 快捷键，大家还是要多少了解一点点的，才能方便在服务器上增改文件。</p>
<p>然后，我们之前不是复制过本地的公钥文件吗，这时候还在系统的剪贴板里面呢，我们这时候要注意，切换到 rn_manager 这个账号下面的终端里，不是切换到 root 账号的终端里面，我们在新的账号终端环境操作。再次通过</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vi .ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<p>或者按一下键盘上的上选择键，来调出历史中缓存的刚才所使用的一条命令来打开授权文件，然后记住输入法是英文状态下，按一下键盘上的 i 键，切记，是 uijk 的 i 键，然后 command+v 粘贴进去（如果是 Windows 系统，是 ctrl+v 粘贴）。</p>
<p>之后，按一下 ESC 退出键，再同时按下 shift+; 键，输入 wq! 回车即可。这个操作很容易由于不熟悉 Linux 下的 vim 编辑而出错，要多体会几遍，再动手做。</p>
<p>如果没有生效，可以对该文件进行一个 600 可读授权，再重启下 ssh 服务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">chmod <span class="number">600</span> ~<span class="regexp">/.ssh/</span>authorized_keys</span><br><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure>
<p>在重启这个 ssh 服务的时候，应该会提示你要输入密码，这时候要输入刚才创建 rn_manager 账户的密码，千万注意，这里输入的密码不是 root 账号的密码，而是新账号的密码。</p>
<p>最后，我们先不要关闭这个终端窗口，再另外开一个：</p>
<p>通过 ssh <a href="mailto:rn_manager@120.26.235.4">rn_manager@120.26.235.4</a> 就直接登录了，就不需要输入密码了，如果这一步没有成功，可以按照这之前的顺序，再仔细比对一遍，看有没有遗漏项。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421145151.png" alt=""></p>
<h2 id="修改服务器登录默认端口"><a href="#修改服务器登录默认端口" class="headerlink" title="修改服务器登录默认端口"></a>修改服务器登录默认端口</h2><p>这一篇我们主要讲解修改服务器登录。</p>
<p>为什么要修改服务器登录？我们现在登录是默认走的 22 端口，这个是 Linux 系统默认的端口，意味着这个端口其实是对所有人透明的，出于基本的安全考虑，也要修改下这个默认端口，怎么做呢？</p>
<p>这时候我们可以在 root 账号下操作，也可以在 rn_manager 账号下操作，我们就在 rn_manager 这个账号下操作好了，直接输入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure>
<p>在打开的文件里，找到如下这些配置项，修改成如下的样子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 不允许空密码</span><br><span class="line">PermitEmptyPasswords no</span><br><span class="line"># 关闭密码验证登录，前提是你已经使用了 ssh 密钥验证方式登录</span><br><span class="line">PasswordAuthentication no</span><br><span class="line"># 如果你在服务器上手动添加了用户并将用户分配到 root 用户组，可以考虑禁止root用户登录</span><br><span class="line">PermitRootLogin no</span><br><span class="line"></span><br><span class="line"># 允许 pubkey 登录</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"></span><br><span class="line"># Expect .ssh/authorized_keys2 to be disregarded by default in future.</span><br><span class="line">AuthorizedKeysFile      .ssh/authorized_keys .ssh/authorized_keys2</span><br><span class="line"></span><br><span class="line"># 登录的端口号</span><br><span class="line">Port <span class="number">39999</span></span><br><span class="line">UseDNS no</span><br><span class="line">AllowUsers rn_manager</span><br><span class="line"># 只允许 ip4</span><br><span class="line">AddressFamily inet</span><br></pre></td></tr></table></figure>
<blockquote>
<p>补充：单独聊一聊端口，这个很容易被人忽视，一般来说，0 ~ 65536 端口号都是可用范围内的数，但是 0 ~ 1024 最好不要使用，通常会被系统程序占用，必须以 root 身份才能启动，那么在 1024 以上到 65536 之间我们都可以选择性的使用。可以设置得稍微大一些，这样做不仅是禁用掉了 22 默认端口的登录途径，也缩小了被扫描和猜测到的概率，在安全层面我们是增加了一点点的安全防护，多多益善吧。</p>
</blockquote>
<p>配置完成后，再重启动 ssh 服务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo service ssh restart</span><br></pre></td></tr></table></figure>
<p>同样，有时候依然会遇到上一节遇到的报错信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/ssh/sshd_config</span><br><span class="line">sudo: unable to resolve host iZbp162mggaelqtp8plk48Z</span><br></pre></td></tr></table></figure>
<p>host 无法解析了，这时候我们可以通过执行如下命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">echo $(hostname -I | cut -d\  -f1) $(hostname) | sudo tee -a /etc/hosts</span><br></pre></td></tr></table></figure>
<p>或者，编辑下 hosts 文件，加入这一行就行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/hosts</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> localhost iZbp162mggaelqtp8plk48Z</span><br></pre></td></tr></table></figure>
<p>然后再新开一个终端窗口，登录就不能用之前的方式，需要加上端口号了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">ssh -p <span class="number">39999</span> rn_manager@<span class="number">120.26</span><span class="number">.235</span><span class="number">.4</span></span><br></pre></td></tr></table></figure>
<p>这样，我们就配置好了 39999 端口登录，服务器的基础配置就完成了。</p>
<blockquote>
<p>注意：阿里云web管理平台的网络和安全-&gt;安全组-&gt;管理规则-&gt;添加安全组规则 添加此端口的规则，否则会登录超时。</p>
</blockquote>
<p>我们这一小节重点讲了如何对新账号的登录方式，设置更严格的登录权限，比如修改登录端口甚至关闭掉密码登录的方式，来最大程度的守护服务器的账号安全，这是最基本的服务器防护方式。大家购买新服务器后，建议一律取消 22 端口，一律取消密码直登，一律更换服务器默认账号，无论它是 root 还是 admin，换成自己定义的账号。</p>
<h2 id="配置阿里云进出方向安全组"><a href="#配置阿里云进出方向安全组" class="headerlink" title="配置阿里云进出方向安全组"></a>配置阿里云进出方向安全组</h2><h3 id="常见常用的端口与规则"><a href="#常见常用的端口与规则" class="headerlink" title="常见常用的端口与规则"></a>常见常用的端口与规则</h3><p>阿里云的服务器，默认就提供了安全组这样的高级防火墙，供我们使用，它可以控制从外网能访问到服务器的哪些端口，从内网能访问到服务器的哪些端口，流量的进和出，对哪些 IP 段的服务器授权，非常强大。</p>
<p>根据实际使用情况，通常我们会选择开启下面这些端口：</p>
<table>
<thead>
<tr>
<th align="left">协议</th>
<th align="left">端口</th>
</tr>
</thead>
<tbody><tr>
<td align="left">SSH</td>
<td align="left">22</td>
</tr>
<tr>
<td align="left">telnet</td>
<td align="left">23</td>
</tr>
<tr>
<td align="left">HTTP</td>
<td align="left">80</td>
</tr>
<tr>
<td align="left">HTTPS</td>
<td align="left">443</td>
</tr>
<tr>
<td align="left">MS SQL</td>
<td align="left">1443</td>
</tr>
<tr>
<td align="left">Oracle</td>
<td align="left">1521</td>
</tr>
<tr>
<td align="left">MySQL</td>
<td align="left">3306</td>
</tr>
<tr>
<td align="left">RDP</td>
<td align="left">3389</td>
</tr>
<tr>
<td align="left">PostgreSQL</td>
<td align="left">5432</td>
</tr>
<tr>
<td align="left">Redis</td>
<td align="left">6379</td>
</tr>
</tbody></table>
<p>同时，它还可以非常精细的控制出入方向的规则，所谓出入，我引用下其他文档上的描述：</p>
<blockquote>
<p>出方向：是指 ECS 实例访问内网中其他 ECS 实例或者公网上的资源<br>入方向：是指内网中的其他 ECS 实例或公网上的资源访问 ECS 实例</p>
</blockquote>
<p>对于一个端口的访问，比如 80 端口，允许入方向也就意味着从互联网包括内网都可以放到这台服务器的 80 端口，这时候我们可以配置它的 IP 段为：<code>0.0.0.0/0</code>，如果是某个特定内网 IP 才能访问，我们可以这样写：<code>12.1.1.1</code>，或者使用 IP 段：<code>13.1.1.1/25</code>。</p>
<p>比如下图：<br><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421150630.png" alt=""></p>
<p>我们允许 12.1.1.1 ~ 12.1.1.27 这个 IP 段的和 13.1.1.1 ~ 13.1.1.25 IP 段的所有服务器，都能访问阿里云服务器的 1022 端口。</p>
<p>更详细的安全组使用攻略，建议大家参考 <a href="https://help.aliyun.com/document_detail/58746.html?spm=a2c4g.11186623.6.725.59132df3zhSwyx" target="_blank" rel="noopener">阿里云安全组文档</a>。</p>
<h2 id="搭建-Node-与阿里云Alinode环境"><a href="#搭建-Node-与阿里云Alinode环境" class="headerlink" title="搭建 Node 与阿里云Alinode环境"></a>搭建 Node 与阿里云Alinode环境</h2><p>搭建 Node.js 环境</p>
<h3 id="更新，安装基础包"><a href="#更新，安装基础包" class="headerlink" title="更新，安装基础包"></a>更新，安装基础包</h3><p>在安装以前，我们最好先更新一下系统，并安装可能用到的基础包。通过 sudo 命令来安装这些系统包：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> update</span><br><span class="line">sudo apt-<span class="keyword">get</span> install vim openssl build-essential libssl-dev wget curl git</span><br></pre></td></tr></table></figure>
<p>理论上后面我们用到 sudo 的地方，都需要输入密码，再强调一下，这个密码不是 root 账号的密码，而是当前登录账号下，也就是 rn_manager 新建的时候，你设置的新账号密码。安装时会遇到提示是否输入 Y 来往下进行，可以把输入法切换成英文输入法，然后按下 y 再回车就可以了。</p>
<p>安装 Git 是为了后面部署项目到生产环境用，这个一定要安装不能漏了。</p>
<h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>接下来，安装 Node.js，我们选用 nvm 这个工具，方便升级和管理 Node.js 版本。</p>
<p>首先拷贝下这句 curl 命令，再粘贴到命令行里面执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">curl -o- https:<span class="comment">//raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash</span></span><br></pre></td></tr></table></figure>
<p>安装完毕 nvm 以后，会有提示说，新打开一个命令行窗口操作，那么我们就老老实实把这个关掉，新开一个命令行窗口，然后重新登录进去。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">nvm install v10<span class="number">.14</span><span class="number">.2</span></span><br><span class="line">nvm use v10<span class="number">.14</span><span class="number">.2</span></span><br><span class="line">nvm alias <span class="keyword">default</span> v10<span class="number">.14</span><span class="number">.2</span></span><br><span class="line">node -v</span><br><span class="line">v10<span class="number">.14</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>

<h3 id="直接安装阿里云的-alinode"><a href="#直接安装阿里云的-alinode" class="headerlink" title="直接安装阿里云的 alinode"></a>直接安装阿里云的 alinode</h3><p>或者，你可以不安装官方原生的 Node.js，直接安装阿里云的 alinode，这也是我推荐给大家的 Node，因为它对 Node 做了必要的定制，可以无缝接入到 alinode 的监控中心，对于多机器多应用运维非常有用。大家可以参考 alinode <a href="https://help.aliyun.com/document_detail/60338.html" target="_blank" rel="noopener">安装文档</a>，实际安装命令如下，大家要参考文档，以文档为准：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"># 安装版本管理工具 tnvm，安装过程出错参考：https://github.com/aliyun-node/tnvm</span><br><span class="line">wget -O- https:<span class="comment">//raw.githubusercontent.com/aliyun-node/tnvm/master/install.sh | bash</span></span><br><span class="line">source ~<span class="regexp">/.bashrc</span></span><br><span class="line"><span class="regexp"># tnvm ls-remote alinode 查看需要的版本</span></span><br><span class="line"><span class="regexp">tnvm install alinode-v3.11.4 # 安装需要的版本</span></span><br><span class="line"><span class="regexp">tnvm use alinode-v3.11.4 # 使用需要的版本</span></span><br><span class="line">npm install @alicloud/agenthub -g # 安装 agenthub</span><br></pre></td></tr></table></figure>
<p>安装完 Node 之后，NPM 也就是 Node 的包管理工具也装好了。NPM 可以方便地安装第三方包模块，但是，我们的服务器在国内，有时候会连不上 npm 或者下载很慢，我们可以配置一个简单的 registry 参数来指定使用国内的 taobao 镜像来下载：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm --registry=https:<span class="comment">//registry.npm.taobao.org install -g npm</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>最后，别忘了执行这句命令，增加文件监控数目</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">echo fs.inotify.max_user_watches=<span class="number">524288</span> | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p</span><br></pre></td></tr></table></figure>

<p>还是之前安装 npm 时候的原因，为了保证更快、更稳定的安装速度，我们也可以采用 cnpm 来替代 npm 下载包信息：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm --registry=https:<span class="comment">//registry.npm.taobao.org install -g cnpm</span></span><br><span class="line">cnpm -v</span><br></pre></td></tr></table></figure>

<p>好了，Node.js 安装完了，我们再顺手把一些常用的全局工具包安装一下吧：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install pm2 -g</span><br></pre></td></tr></table></figure>
<p>至此 Node.js 的环境就安装好了</p>
<p>本节我们主要学习了在服务器上安装配置 Node.js 环境的基本步骤，特别是针对国内的同学，我们可以选择使用阿里云 alinode 的安装包，来方便后期接入到 alinode 的服务监控体系中，做更精细化的运维。</p>
<h2 id="利用-PM2-让-Node-js-服务常驻"><a href="#利用-PM2-让-Node-js-服务常驻" class="headerlink" title="利用 PM2 让 Node.js 服务常驻"></a>利用 PM2 让 Node.js 服务常驻</h2><h3 id="PM2-的安装提示处理"><a href="#PM2-的安装提示处理" class="headerlink" title="PM2 的安装提示处理"></a>PM2 的安装提示处理</h3><p>在本地安装 PM2 之后，可能会看到下面的这个提示，可以按照提示操作一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Since PM2’s deployment command runs on a non-interactive SSH connection, we need to resolve <span class="keyword">this</span> by commenting out a few lines <span class="keyword">from</span> the semaphoreci user’s ~<span class="regexp">/.bashrc file. We’re already logged in as this user on our droplet, so we simply need to open up this file and comment this out:</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Comment the following lines:</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">#If not running interactively, don't do anything</span></span><br><span class="line"><span class="regexp">#case $- in</span></span><br><span class="line"><span class="regexp">#    *i*) ;;</span></span><br><span class="line"><span class="regexp">#      * return;;</span></span><br><span class="line"><span class="regexp">#esac</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">and this in /</span>etc/bash.bashrc</span><br><span class="line"></span><br><span class="line"># If not running interactively, don't do anything</span><br><span class="line">[ -z <span class="string">"$PS1"</span> ] &amp;&amp; <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p>也就是把 If case 这几行注释掉就可以了。</p>
<h3 id="尝试-PM2-启动服务"><a href="#尝试-PM2-启动服务" class="headerlink" title="尝试 PM2 启动服务"></a>尝试 PM2 启动服务</h3><p>如果一个网站的服务，必须通过命令行 node server.js 来启动，启动后，退出命令行服务就终止，这显然不符合我们的预期。</p>
<p>而即便是服务能持续运行，一旦遇到异常情况服务即终止，也是不理想的，这时候就需要有一种能够守护进程的工具或者服务，来把已经挂起的服务再次重启，这就是服务常驻的基本需求了。</p>
<p>对于 Node.js 来说，有很多工具可以帮我们做到这一点，PM2 就是其中一个，之前我们写了这样一个静态站点代码 - app.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> homePage = <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">  &lt;html&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">      &lt;meta charset="utf-8"&gt;</span></span><br><span class="line"><span class="string">      &lt;title&gt;Node.js 部署上线示例&lt;/title&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;h1&gt;慕课网 Node.js 部署发布&lt;/h1&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">  &lt;/html&gt;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.statusCode = <span class="number">200</span></span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>)</span><br><span class="line">  res.end(homePage)</span><br><span class="line">&#125;).listen(<span class="number">4321</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server running at 4321'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>我们想要把一个静态站点开起来，需要满足 2 个条件:</p>
<p>第一，这个站点可以持续稳定地提供服务；<br>第二，这个站点可以从外网直接访问到，比如通过域名访问到。</p>
<p>现在，我们的端口是跑在 4321 的，这显然不满足第二个条件，我们需要从外网通过 80 端口来访问。</p>
<p>我们先解决第一个问题：让服务可以持续稳定地运行。（第二个问题留到下一个节来解决。）通过 node app.js 启动服务文件，服务就跑起来了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node app</span><br></pre></td></tr></table></figure>

<p>我们通过浏览器来访问，<code>http://120.26.235.4:4321/</code>就可以看到 Node.js 服务返回的页面内容了，但是一旦退出命令行，这个会话状态就会中断，随之 Node.js 服务也会终止。显然这不是我们想要的状态，我们希望服务不仅可以在后台运行，而且在出现异常的时候还可以自动重启。这时我们就可以用到 PM2 这个 Node.js 部署和进程管理工具，不作过多解释，直接来用。</p>
<p>不加任何参数的话，PM2 会自动初始化一些基础参数，来把服务跑起来。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm2 start app.js</span><br></pre></td></tr></table></figure>
<h3 id="补充：PM2-常用命令"><a href="#补充：PM2-常用命令" class="headerlink" title="补充：PM2 常用命令"></a>补充：PM2 常用命令</h3><p>通过 PM2 跑服务器的时候，是可以进行集群配置的，也就是指定在几个核上运行几个进程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm2 start app.js -i <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>-i 后面跟的 2 表示启动 2 个 server 实例，如果输入 0 的话，则按照当前服务器实际的 CPU 核数来启动多个 server，启动后，我们通过 <code>pm2 ls</code> 来看看已经启动的实例：</p>
<p><strong>PM2 实时扩容集群</strong><br>如果发现线上的服务响应比较吃力，而 CPU 核数没有吃满的话，我们可以实时扩容集群，通过 scale 命令来实现，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm2 scale app +<span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这里的 +1 就是扩容一个服务实例，其实就是增加一个 cluster 的 worker 子进程</p>
<p><strong>PM2 终止某个进程</strong></p>
<p>有时候如果某个进程明显卡住了，或者线上负载不大，可以杀掉部分进程，通过：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm2 stop <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可以看到进程 ID 为 1 的 worker 已经是 stopped 状态。</p>
<p><strong>PM2平滑重启进程</strong><br>有时候，如果想要某个比较吃内存的进程可以重启，或者想要所有的 worker 都重启，但是又不希望影响进程正常处理用户的请求，可以使用 PM2 的 gracefulReload 命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm2 reload app</span><br></pre></td></tr></table></figure>

<h2 id="配置-Nginx-反向代理-Node-js-端口"><a href="#配置-Nginx-反向代理-Node-js-端口" class="headerlink" title="配置 Nginx 反向代理 Node.js 端口"></a>配置 Nginx 反向代理 Node.js 端口</h2><p>当服务运行到线上后，我们通常通过域名而不是 IP + 端口来访问，并且一台服务器上可能有多个 Node 服务在运行，而且运行在不同的端口。如果它们都共用 80 端口显然是不行的，这时候就需要有一种机制，来把不同域名的请求，通过 80 端口进来后，分配给不同的端口服务。</p>
<p>基于这个背景，这一节我们要做的事很简单，先让 Web 服务通过 80 端口可被访问到，之后再考虑分配或者说代理如何实现。80 端口在访问的时候是可以省略的,怎么实现呢？这就需要大名鼎鼎的 Nginx 出场了。</p>
<h3 id="安装-Nginx-和关闭版本号露出"><a href="#安装-Nginx-和关闭版本号露出" class="headerlink" title="安装 Nginx 和关闭版本号露出"></a>安装 Nginx 和关闭版本号露出</h3><p>首先我们来安装 Nginx，但是，一般来说刚刚购买的阿里云服务器会预装 Apache，我们没有特别需要的话，是用不到的，可以把它删了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo service apache2 stop</span><br><span class="line">sudo update-rc.d -f apache2 remove</span><br><span class="line">sudo apt-<span class="keyword">get</span> remove apache2</span><br></pre></td></tr></table></figure>

<p>删完 Apache，用命令 <code>sudo apt-get update</code> 更新一下包列表，然后来安装 Nginx：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>

<p>安装完毕后，检查下 Nginx 的版本：nginx -v。这个版本号通常可以在 Web 端的 header 里看到。安全起见，可以通过配置隐藏掉，如下打开 nginx.conf 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p>把 nginx.conf 文件中的<code>server_tokens on</code> 改成 <code>server_tokens off</code> 就可以了。</p>
<p>现在我们来解决 4.2 节中的第二个问题：让 Web 服务可以通过 80 端口被外网访问到。</p>
<h3 id="配置-Nginx-反向代理-Node-js-端口-1"><a href="#配置-Nginx-反向代理-Node-js-端口-1" class="headerlink" title="配置 Nginx 反向代理 Node.js 端口"></a>配置 Nginx 反向代理 Node.js 端口</h3><p>在「利用 PM2 让 Node.js 服务常驻」一节，我们的网站静态服务是跑在 4321 端口上的，直接通过 80 端口无法启动，原因是我们 rn_manager 下的 Node 并不具备 root 的运行权限，不能监听 0 ~ 1024 之间的端口，当然也包括 80 端口。</p>
<p>通过 sudo 来强制启动 Node 服务也不是不可以，但是，这多少会带来一些额外的成本和风险：一是我们需要额外配置，二是需要放大 Node 程序的权限。</p>
<p>那么如果我们想先不通过域名访问，直接使用 IP 达到访问的效果，怎么做呢？</p>
<p>要解决这个问题，我们就需要引入 Nginx，用 root 级的权限来启动对 80 端口的监听，同时把来自 80 端口的流量分配给 Node 服务的另外一个端口，实现这种服务的代理。</p>
<blockquote>
<p>补充： 如果服务器只需放一个网站程序，那么解析网站到服务器网址，网站程序监听 80 端口即可。如果服务器有多个应用（你有多个网站），借助 Nginx 不仅可以实现端口代理，还可以实现负载均衡，由它来判断是来自哪个域名或 IP 的访问，从而根据配置的规则，将这个请求原封不动地转发给特定的端口或特定的某几台机器。在我们的这个案例中，就是把 80 端口的 IP 请求都转发到 Node.js 的 8081 端口。</p>
</blockquote>
<p>好了，原理我们知道了，下面第一步要在 /etc/nginx/conf.d 文件夹下面新增一个配置文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo vi  /etc/nginx/conf.d/imooc-com<span class="number">-4321.</span>conf</span><br></pre></td></tr></table></figure>

<p>我一般喜欢用这种命名方式，看一下配置文件，便知道是哪个域名对应到哪个端口。因为将来可能会有多个项目对应服务器后端的多个服务，所以要考虑这种负载均衡的这种场景。这时候通过以下配置来实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 通过 upstream 我们可以设定一个简单的负载均衡策略，以应对将来可能的升级</span><br><span class="line"># 首先定义一个 server 集群 gougou，里面可以加多个 server，每个 server 对应的值可以用域名，也可以直接用 IP，但我们通常不会用 IP 来访问，而是通过域名:</span><br><span class="line"></span><br><span class="line">upstream imooc &#123;</span><br><span class="line">    server <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">4321</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen <span class="number">80</span>;</span><br><span class="line">    server_name deploy-<span class="keyword">static</span>.iblack7.com;</span><br><span class="line"></span><br><span class="line">    # Gzip Compression</span><br><span class="line">    gzip on;</span><br><span class="line">    gzip_comp_level <span class="number">6</span>;</span><br><span class="line">    gzip_vary on;</span><br><span class="line">    gzip_min_length  <span class="number">1000</span>;</span><br><span class="line">    gzip_proxied any;</span><br><span class="line">    gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line">    gzip_buffers <span class="number">16</span> <span class="number">8</span>k;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">        # remote_addr 代表客户端的 IP</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        # proxy_add_x_forwarded_for 获取真实的 IP</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        # http_host 表示请求的 host 头</span><br><span class="line">        proxy_set_header Host $http_host;</span><br><span class="line">        proxy_set_header X-NginX-<span class="built_in">Proxy</span> <span class="literal">true</span>;</span><br><span class="line">      </span><br><span class="line">        # proxy_pass 指令实现代理。把域名代理到集群名上面</span><br><span class="line">        # proxy_pass http://imooc;</span><br><span class="line">        # proxy_redirect off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>保存后，通过 <code>sudo nginx -t</code> 来验证配置是否正确，有没有语法错误，然后我们把 Nginx 的服务重启一下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sudo service nginx restart</span><br></pre></td></tr></table></figure>
<p>再把 URL 中的端口号去掉即可</p>
<p>大功告成！</p>
<p>Nginx 与 Node.js 的配套使用是部署 Node 服务时非常关键的环节，其中 Nginx 往往扮演的是景区大导游的角色，任何人过来要工人干活，都要先经过他，他看看你是来自哪儿的，把你的信息记录下，然后看你是要去哪里，再把你分配给相应的对象接待，简单来说就是，Nginx 搞分配，Node 去干活。当然像日志、安全证书和静态资源代理这些事情，也都可以由 Nginx 前置完成，这样 Node 就可以专心负责业务的部分了。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421152707.png" alt=""></p>
<h2 id="安装与配置-MongoDB-数据库"><a href="#安装与配置-MongoDB-数据库" class="headerlink" title="安装与配置 MongoDB 数据库"></a>安装与配置 MongoDB 数据库</h2><p>在工作中，我们所要部署的项目肯定会有数据库，数据库中存放着各种数据：用户信息、商品信息、供货商信息等内容，因此部署数据库到服务器上肯定是本课程必学的一项。这一节我们就来学习一下 MongoDB 数据库的部署，学会了 MongoDB 数据库，其它数据库（如 MySQL）的部署方法就大同小异了，基础步骤都差不多，不同的就是命令的写法。</p>
<p><strong>安装免费的 MongoDB 数据库社区版</strong></p>
<p>安装之前先介绍一下阿里云的付费数据库：阿里云（Aliyun） 它自己有付费的 MongoDB 数据库，具备自动的主副节点和容灾备份机制。我觉得很好用，如果实在不想自己折腾的同学可以考虑购买，但是大部分同学现在还不想承担这么高的开发成本，我们就可以在服务器上搭建一个简易的 MongoDB 数据库，也不用做什么主副节点，能让它跑起来用就行。</p>
<blockquote>
<p>提示：但是这样就带来了一个缺点，那就是我们的”应用“跟”数据“必须放在同一台机器上了（如果我们分开的话，一台放”应用“，一台放”数据“更合理）。两个混在一起，一旦应用需要重大升级，可能会影响到数据库的运行环境，而且应用服务器和数据库服务器的配置敏感度也是不同的，有可能这个应用非常吃 CPU，而数据库可能非常吃内存，一旦二者重叠，就可能因为一个的不稳定影响到另外一个。当然对于一些小型应用，如果非要把数据库跟应用放到一个服务器上，或者像我们这样的专栏用来学习的话，也是可以的。如果条件允许，我也建议大家购买 Aliyun MongoDB 数据库，虽然贵一些，但是可以完全省下来配置运行维护的成本了。</p>
</blockquote>
<p>参考  <a href="https://www.runoob.com/mongodb/mongodb-linux-install.html" target="_blank" rel="noopener">Linux平台安装MongoDB</a></p>
<h2 id="私有仓库托管与-PM2-一键配置部署"><a href="#私有仓库托管与-PM2-一键配置部署" class="headerlink" title="私有仓库托管与 PM2 一键配置部署"></a>私有仓库托管与 PM2 一键配置部署</h2><p>这一节我们开始进入重头戏，我们在服务器上面已经安装了 Nginx 和 PM2，并且用 PM2 来管理 Node.js 开启的服务来提供稳定的 HTTP 服务。我们上传项目或者需要修改项目代码的话，总不能每一次都把本地的代码，给一个个字节上传到服务器上吧？这个时候我们就用到 Git 仓库了，大家对 Git 应该都不陌生吧。</p>
<p>Git 是一个分布式版本控制系统，说白了，就是能保存你的代码，并且能保存代码不同时期的版本，可以随时切换到某个时间点你所提交代码的状态。</p>
<p>如果你还没有的话，可以注册一个 GitHub 账号，用用看，同时，我们的本地一定要确保是安装过 Git 的，比如在 Mac 上面，通过 brew install git 来安装就行，在 Windows 上面的话，也有 Git 的客户端可以安装，大家搜索下文档自行解决本地 Git 安装和配置的问题。</p>
<h3 id="上传项目代码到线上私有仓库"><a href="#上传项目代码到线上私有仓库" class="headerlink" title="上传项目代码到线上私有仓库"></a>上传项目代码到线上私有仓库</h3><p>我们本地现在一共有 4 个项目，分别是静态网站、Vue 应用站点、React 应用站点和电影网站</p>
<p>我们现在把这4 个项目都通过 Git 上传到私有仓库里面。对于私有仓库，大家可以付费选择 GitHub 的私有仓库服务，也可以到开源中国使用免费的私有仓库（现在已经改名叫码云了），地址是 <a href="https://gitee.com。" target="_blank" rel="noopener">https://gitee.com。</a></p>
<p>目前还是免费的，如果收费了，大家也可以搜索一下其他提供免费私有仓库的代码托管平台，等到注册这个账号后，我们就可以到主面板来新建 4 个私有仓库来专门对应到本地的 4 个项目。</p>
<blockquote>
<p>注意：这里建议大家一定要把项目属性更改成私有的，不然你的代码就是公开的了，这样项目代码就可能被公开访问到，对于项目本身安全就容易出问题了，因为可能包含一些敏感代码甚至密码、密钥之类。</p>
</blockquote>
<p>我给这几个项目配置的名字分别是：</p>
<ul>
<li>node-deploy-static</li>
<li>node-deploy-vue</li>
<li>node-deploy-react</li>
<li>node-deploy-pug</li>
</ul>
<p>以下操作都是以静态网站 node-deploy-static 为例，先把项目关联到我们的本地项目中，每次创建项目后，它会有具体提示，来告诉我们如何通过命令来关联。</p>
<p>另外，一定要确保，本地的 id_rsa 的公钥已经被配置到了码云的个人后台里面，在本地 cat 一下 .ssh/id_rsa.pub 这公钥，全部选中，然后复制下来，来到 Git 的个人配置后台，找到 ssh key 设置，然后，粘贴进去，提交。可能要你输入密码，输入即可，然后我们可以按照它的提示，把本地的 git 全局设置配置一下。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"wolf18387"</span></span><br><span class="line">git config --global user.email <span class="string">"34xxx72@qq.com"</span></span><br></pre></td></tr></table></figure>

<p>然后关联本地的 Git 仓库，如果本地已经是 Git 仓库了，可以操作最下面的这个提示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cd existing_git_repo</span><br><span class="line">git remote add origin git@git.oschina.net:wolf18387/node-deploy-vue.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>如果本来就是一个干净的项目文件夹，没有 git 历史，那么就先初始化，再提交：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 初始化本地的项目仓库</span><br><span class="line">git init</span><br><span class="line"># 把文件加入本地暂存区</span><br><span class="line">git add README.md</span><br><span class="line"># 为本次改动增加提交的改动描述</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line"># 为仓库关联远端的云仓库地址</span><br><span class="line">git remote add origin git@git.oschina.net:wolf18387/node-deploy-vue.git</span><br><span class="line"># 把代码推送到云端仓库</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>这样我们就可以从本地上传新的代码到私有仓库了。</p>
<p>那么我们怎么让服务器也有权限可以下载到这个仓库呢？很简单，我们可以把服务器的 key 也拿过来配置到码云的后台，刚好，我们在配置无密码 ssh 登录服务器的那一节中，已经在服务器上配置过了这个 key。</p>
<p>在服务器上， cat 一下 <code>.ssh/id_rsa.pub</code> 这公钥，全部选中，然后复制下来，来到 git 的个人配置后台，找到 ssh key 设置，然后粘贴进去，提交，可能要你输入密码，没关系输入即可。最后我们一定要确保服务器上，已经安装了 git，如果没有的话，通过 <code>sudo apt-get install git</code> 安装。</p>
<p>安装完成 git 并且将服务器上的 <code>.ssh/id_rsa.pub</code> 配置到码云的后台之后，我们在服务器上新建一个文件夹temp/， 并且 cd 进去然后执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># git clone 你的线上私有仓库的地址</span><br><span class="line">git clone git@git.oschina.net:wolf18387/node-deploy-vue.git</span><br></pre></td></tr></table></figure>

<p>中间会询问你是否要继续，输入 yes 继续即可，这样我们就把从本地上传到线上仓库的代码给 clone 到了服务器。</p>
]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title>零基础学透TypeScript</title>
    <url>/2020/04/21/%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E9%80%8FTypeScript/</url>
    <content><![CDATA[<h2 id="开篇词：Hello-TypeScript"><a href="#开篇词：Hello-TypeScript" class="headerlink" title="开篇词：Hello~TypeScript"></a>开篇词：Hello~TypeScript</h2><p>同学你好，我是 TypeScript，如果你觉得我是 JavaScript 的孪生兄弟，或者觉得我是前端圈新扶持起来的太子，那你可能对我是有点误解了。其实我并不是一个新的语言，用大家公认的说法，我是JavaScript的超集，你可以理解为，我是加了一身装备铭文的进化版 JavaScript。JavaScript 有的，我都有，而且做得更好。JavaScript 没有的，我也有，而且我是在很长一段时间内不会被 JavaScript 赶上的。</p>
<p>虽然我作为超集，但是我始终紧跟 ECMAScript 标准，所以 ES6/7/8/9 等新语法标准我都是支持的，而且我还在语言层面上，对一些语法进行拓展。比如新增了枚举(Enum)这种在一些语言中常见的数据类型，对类(Class)实现了一些ES6标准中没有确定的语法标准等等。</p>
<a id="more"></a>

<p>如果你是一个追赶技术潮流的开发者，那你应该已经将 ES6/7/8/9 语法用于开发中了。但是要想让具有新特性的代码顺利运行在非现代浏览器，需要借助Babel这种编译工具，将代码转为ES3/5版本。而我，可以完全不用 Babel，就能将你的代码编译为指定版本标准的代码。这一点，我可以说和 JavaScript 打了个平手。</p>
<p>另外我的优势，想必你也略有耳闻了那就是我强大的类型系统。这也是为什么造世主给我起名TypeScript。如果你是一名前端开发者，或者使用过 JavaScript 进行开发，那么你应该知道，JavaScript 是在运行的时候，才能发现一些错误的，比如：</p>
<ul>
<li>访问了一个对象没有的属性；</li>
<li>调用一个函数却少传了参数；</li>
<li>函数的返回值是个字符串你却把它当数值用了；</li>
<li>…</li>
</ul>
<p>这些问题在我这里都不算事。我强大的类型系统可以在你编写代码的时候，就检测出你的这些小粗心。先来简单看下我工作的样子：</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421170808.png" alt=""></p>
<p>interface 定义的叫接口，它定义的是对结构的描述。下面的 info 使用 ES6 的新关键字 const 定义，通过 info: Info 指定 info 要实现 Info 这个结构，那 info 必须要包含 name 和 age 这两个字段。实际代码中却只有 name 字段，所以你可以看到 info 下面被红色波浪线标记了，说明它有问题。当你把鼠标放在 info 上时，VSCode 编辑器会做出如下提示：</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421170855.png" alt=""></p>
<p>如果上面这个小例子中你有很多概念都不了解，没关系，在后面的章节都会讲到。</p>
<p>配合VSCode这类编辑器，你可以借助编辑器的提示愉快地使用 TypeScript。另外值得一提的是，深受前端开发者喜爱的 VSCode 也是使用 TypeScript 开发的哦。</p>
<p>我们都知道 TypeScript 最主要的亮点是它的类型系统，这使得在编写代码的时候就能够检测到一些错误。而 JavaScript 是一门动态脚本语言，它不需要编译成二进制代码运行。Node 服务端代码也不需编译即可在服务器起一个服务，你甚至可以直接在服务器修改你的服务代码然后重启就可以，不需要编译等操作。这一切特点使得 JavaScript 的所有调试都需要在运行时才能进行，在编写代码的时候很多问题是无法提前知晓的，而且就JavaScript目前的使用场景来看，它在至少很长一段时间内会保持这样的特点。</p>
<p>而 TypeScript 和 JavaScript 不同的就是，它可以在你编写代码的时候，就对一些错误进行提示，还能在你使用某个数据的时候，为你列出这个数据可以访问的属性和方法。在 TypeScript 的自我介绍中我们已经看过几个简单的例子，想必你也知道它实现这些的效果了。当我们的项目较为庞大，需要由多人合作开发时，多人协作是需要沟通成本和 review 成本的。一些接口的定义，一些方法的使用，都可能因为个人习惯或沟通不畅导致逻辑实现的差异。而如果引入TypeScript，则会对一些实现进行强校验。如果不按接口实现，编译就没法通过，如果对代码质量要求较高，可以将严格检查全部打开，效果更好。</p>
<p>那么哪些项目适合用 TypeScript 开发呢，我总结了几类：</p>
<ul>
<li>需要多人合作开发的项目</li>
<li>开源项目，尤其是工具函数或组件库</li>
<li>对代码质量有很高要求的项目</li>
</ul>
<p>来看几个广为人知的使用 TypeScript 开发的经典项目：</p>
<ul>
<li>VSCode：开源的高质量代码编辑器VSCode使用TypeScript开发，所以它天生就支持 TypeScript；</li>
<li>Angular &amp; React &amp; Vue3.0：现在三足鼎立的三个前端框架，Angular 和 React 已经使用 TypeScript编写，而在我编写专栏的同时，Vue3.0 将使用 TypeScript 进行重构，届时三个前端框架都使用TypeScript编写，如果使用TypeScript开发将会得到很好的类型支持。也可以看出，TypeScript 已经被广为接受。当然了，你依然可以使用JavaScript来开发前端项目，但是相信随着 Vue3.0 发布，TypeScript将会被越来越多的开发者所接受；</li>
<li>Ant Design：使用 React 开发项目的开发者大多应该都知道蚂蚁金服开源UI组件库Ant Design，同样使用TypeScript进行编写。保证了代码质量的同时，也能很好地支持开发者使用TypeScript进行React项目的开发。如果你使用 Vue 进行开发，Ant Design 也提供了Vue 版的组件库，风格和功能和 React 版的保持一致，共享单元测试和设计资源，对TypeScript的支持也一样很好。</li>
</ul>
<h2 id="VSCode揭秘和搭建开发环境"><a href="#VSCode揭秘和搭建开发环境" class="headerlink" title="VSCode揭秘和搭建开发环境"></a>VSCode揭秘和搭建开发环境</h2><p>如何借助VSCode愉快高效地开发TypeScript项目，我们来一步一步让VSCode对TypeScript的支持更强大</p>
<h3 id="安装和基本配置"><a href="#安装和基本配置" class="headerlink" title="安装和基本配置"></a>安装和基本配置</h3><p>如果你还没有使用过<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">VSCode</a>，当然先要去官网下载了，下载安装我就不多说了，安装好之后，我们先来配置几个基本的插件。</p>
<h3 id="汉化"><a href="#汉化" class="headerlink" title="汉化"></a>汉化</h3><p>如果你英语不是很好，配置中文版界面是很有必要的，安装个插件就可以了。打开VSCode之后在编辑器左侧找到这个拓展按钮，点击，然后在搜索框内搜索关键字”Chinese”，这里图中第一个插件就是。直接点击install安装，安装完成后重启VSCode即可。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421173826.png" alt=""></p>
<h3 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h3><p>接下来我们开始从零搭建一个开发环境，也就是一个基础前端项目。后面课程中讲到的语法知识，你都可以在这个项目中去尝试，接下来我们就一步一步来搭建我们的开发环境啦。</p>
<p>在开始之前，你要确定你的电脑有node的环境，如果你没有安装过node，先去Node.js下载地址下载对应你系统的node.js安装包，下载下来进行安装。</p>
<p>node安装好之后，可以在命令行运行node -v来查看node的版本号。如果正确打印出版本号说明安装成功。npm是node自带的包管理工具，会在安装node的时候自动进行安装，可以使用npm -v来查看npm的版本，检验是否安装成功。</p>
<h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><p>新建一个文件夹“client-side”，作为项目根目录，进入这个文件夹：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mkdir client-side</span><br><span class="line">cd client-side</span><br></pre></td></tr></table></figure>

<p>我们先使用 npm 初始化这个项目：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用npm默认package.json配置</span></span><br><span class="line">npm init -y</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用交互式自行配置，遇到选项如果直接敲回车即使用括号内的值</span></span><br><span class="line">npm init</span><br><span class="line">package name: (client-side) # 可敲回车即使用client-side这个名字，也可输入其他项目名</span><br><span class="line">version: (1.0.0) # 版本号，默认1.0.0</span><br><span class="line">description: # 项目描述，默认为空</span><br><span class="line">entry point: (index.js) # 入口文件，我们这里改为./src/index.ts</span><br><span class="line">test command: # 测试指令，默认为空</span><br><span class="line">git repository: # git仓库地址，默认为空</span><br><span class="line">keywords: # 项目关键词，多个关键词用逗号隔开，我们这里写typescript,client,lison</span><br><span class="line">author: # 项目作者，这里写lison&lt;lison16new@163.com&gt;</span><br><span class="line">license: (ISC) # 项目使用的协议，默认是ISC，我这里使用MIT协议</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后会列出所有配置的项以及值，如果没问题，敲回车即可。</span></span><br></pre></td></tr></table></figure>

<p>这时我们看到了在根目录下已经创建了一个 package.json 文件，接下来我们创建几个文件夹：</p>
<ul>
<li>src：用来存放项目的开发资源，在 src 下创建如下文件夹：<ul>
<li>utils：和业务相关的可复用方法</li>
<li>tools：和业务无关的纯工具函数</li>
<li>assets：图片字体等静态资源</li>
<li>api：可复用的接口请求方法</li>
<li>config：配置文件</li>
</ul>
</li>
<li>typings：模块声明文件</li>
<li>build：webpack 构建配置</li>
</ul>
<p>接下来我们在全局安装typescript，全局安装后，你就可以在任意文件夹使用tsc命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install typescript -g</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果全局安装失败，多数都是权限问题，要以管理员权限运行。</p>
</blockquote>
<p>安装成功后我们进入项目根目录，使用typescript进行初始化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：运行的指令是tsc，不是typescript。</p>
</blockquote>
<p>这时你会发现在项目根目录多了一个 tsconfig.json 文件，里面有很多内容。</p>
<p>tsconfig.json 里默认有 4 项没有注释的配置，有一个需要提前讲下，就是”lib”这个配置项，他是一个数组，他用来配置需要引入的声明库文件，我们后面会用到ES6语法，和DOM相关内容，所以我们需要引入两个声明库文件，需要在这个数组中添加”es6”和”dom”，也就是修改数组为[“dom”, “es6”]，其他暂时不用修改</p>
<p>然后我们还需要在项目里安装一下typescript，因为我们要搭配使用webpack进行编译和本地开发，不是使用tsc指令，所以要在项目安装一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install typescript</span><br></pre></td></tr></table></figure>

<h4 id="配置webpack"><a href="#配置webpack" class="headerlink" title="配置webpack"></a>配置webpack</h4><p>接下来我们要搭配使用 webpack 进行项目的开发和打包，先来安装 webpack、webpack-cli 和 webpack-dev-server：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install webpack webpack-cli webpack-dev-server -D</span><br></pre></td></tr></table></figure>
<p>我们将它们安装在项目中，并且作为开发依赖(-D)安装。接下来添加一个 webpack 配置文件，放在 build 文件夹下，我们给这个文件起名 webpack.config.js，然后在 package.json 里指定启动命令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"cross-env NODE_ENV=development webpack-dev-server --mode=development --config build/webpack.config.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们用到一个插件”cross-env”，并且后面跟着一个参数 NODE_ENV=development，这个用来在 webpack.config.js 里通过 process.env.NODE_ENV 来获取当前是开发还是生产环境，这个插件要安装：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm install cross-env</span><br></pre></td></tr></table></figure>

<p>紧接着我们要在 webpack.config.js 中书写配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; CleanWebpackPlugin &#125; = <span class="built_in">require</span>(<span class="string">"clean-webpack-plugin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 指定入口文件</span></span><br><span class="line">  <span class="comment">// 这里我们在src文件夹下创建一个index.ts</span></span><br><span class="line">  entry: <span class="string">"./src/index.ts"</span>,</span><br><span class="line">  <span class="comment">// 指定输出文件名</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">"main.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    <span class="comment">// 自动解析一下拓展，当我们要引入src/index.ts的时候，只需要写src/index即可</span></span><br><span class="line">    <span class="comment">// 后面我们讲TS模块解析的时候，写src也可以</span></span><br><span class="line">    extensions: [<span class="string">".tsx"</span>, <span class="string">".ts"</span>, <span class="string">".js"</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 配置以.ts/.tsx结尾的文件都用ts-loader解析</span></span><br><span class="line">    <span class="comment">// 这里我们用到ts-loader，所以要安装一下</span></span><br><span class="line">    <span class="comment">// npm install ts-loader -D</span></span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">        use: <span class="string">"ts-loader"</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 指定编译后是否生成source-map，这里判断如果是生产打包环境则不生产source-map</span></span><br><span class="line">  devtool: process.env.NODE_ENV === <span class="string">"production"</span> ? <span class="literal">false</span> : <span class="string">"inline-source-map"</span>,</span><br><span class="line">  <span class="comment">// 这里使用webpack-dev-server，进行本地开发调试</span></span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">"./dist"</span>,</span><br><span class="line">    stats: <span class="string">"errors-only"</span>,</span><br><span class="line">    compress: <span class="literal">false</span>,</span><br><span class="line">    host: <span class="string">"localhost"</span>,</span><br><span class="line">    port: <span class="number">8089</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里用到两个插件，所以首先我们要记着安装</span></span><br><span class="line">  <span class="comment">// npm install html-webpack-plugin clean-webpack-plugin -D</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 这里在编译之前先删除dist文件夹</span></span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns: [<span class="string">"./dist"</span>]</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 这里我们指定编译需要用模板，模板文件是./src/template/index.html，所以接下来我们要创建一个index.html文件</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">"./src/template/index.html"</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里我们用到了两个webpack插件，第一个clean-webpack-plugin插件用于删除某个文件夹，我们编译项目的时候需要重新清掉上次打包生成的dist文件夹，然后进行重新编译，所以需要用到这个插件将上次打包的dist文件夹清掉。<br>第二个html-webpack-plugin插件用于指定编译的模板，这里我们指定模板为”./src/template/index.html”文件，打包时会根据此html文件生成页面入口文件。</p>
<p>接下来我们创建这个 index.html 模板：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">"en"</span>&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span> /&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span> /&gt;</span><br><span class="line">    &lt;title&gt;TS-Learning&lt;<span class="regexp">/title&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>head&gt;</span><br><span class="line"></span><br><span class="line">  &lt;body&gt;&lt;<span class="regexp">/body&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>html&gt;</span><br></pre></td></tr></table></figure>

<p>现在我们运行如下命令来启动本地服务：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure>

<p>我们看到启动成功了，接下来我们在 index.ts 文件里写一点逻辑：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.ts</span></span><br><span class="line"><span class="keyword">let</span> a: number = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> h1 = <span class="built_in">document</span>.createElement(<span class="string">"h1"</span>);</span><br><span class="line">h1.innerHTML = <span class="string">"Hello, I am Lison"</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(h1);</span><br></pre></td></tr></table></figure>

<p>当我们保存代码的时候，开发服务器重新编译了代码，并且我们的浏览器也更新了。</p>
<p>我们再来配置一下打包命令，在 package.json 的 scripts 里增加 build 指令：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"cross-env NODE_ENV=development webpack-dev-server --mode=development --config ./build/webpack.config.js"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"cross-env NODE_ENV=production webpack --mode=production --config ./build/webpack.config.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样通过<code>cross-env NODE_ENV=production</code>传入参数。现在我们运行如下命令即可执行打包：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>现在我们前端项目的搭建就大功告成了，我们后面的课程都会在这个基础上进行示例</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421180038.png" alt=""></p>
<h2 id="八个JS中你见过的类型"><a href="#八个JS中你见过的类型" class="headerlink" title="八个JS中你见过的类型"></a>八个JS中你见过的类型</h2><p>这节课我们将学习在 JavaScript 中现有的八个数据类型，当然这并不是 JavaScript 中的所有数据类型，而是现在版本的 TypeScript 支持的基本类型，在学习基础类型之前，我们先来看下如何为一个变量指定类型：</p>
<p>为一个变量指定类型的语法是使用”变量: 类型”的形式，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: number = <span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>如果你没有为这个变量指定类型，编译器会自动根据你赋给这个变量的值来推断这个变量的类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">123</span></span><br><span class="line">num = <span class="string">'abc'</span> <span class="comment">// error 不能将类型“"123"”分配给类型“number”</span></span><br></pre></td></tr></table></figure>

<p>当我们给num赋值为123但没有指定类型时，编译器推断出了num的类型为number数值类型，所以当给num再赋值为字符串”abc”时，就会报错。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421182433.png" alt=""></p>
<p>这里还有一点要注意，就是number和Number的区别：TS中指定类型的时候要用number，这个是TypeScript的类型关键字。而Number为JavaScript的原生构造函数，用它来创建数值类型的值，它俩是不一样的。包括你后面见到的string、boolean等都是TypeScript的类型关键字，不是JavaScript语法，这点要区分开。</p>
<h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>类型为布尔类型的变量的值只能是 true 或 false，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bool: boolean = <span class="literal">false</span>;</span><br><span class="line">bool = <span class="literal">true</span>;</span><br><span class="line">bool = <span class="number">123</span>; <span class="comment">// error 不能将类型"123"分配给类型"boolean"</span></span><br></pre></td></tr></table></figure>

<p>当然了，赋给 bool 的值也可以是一个计算之后结果是布尔值的表达式，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bool: boolean = !!<span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(bool) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>TypeScript 和 JavaScript 一样，所有数字都是浮点数，所以只有一个number类型，而没有int或者float类型。而且 TypeScript 还支持 ES6 中新增的二进制和八进制数字字面量，所以 TypeScript 中共支持二、八、十和十六四种进制的数值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: number;</span><br><span class="line">num = <span class="number">123</span>;</span><br><span class="line">num = <span class="string">"123"</span>; <span class="comment">// error 不能将类型"123"分配给类型"number"</span></span><br><span class="line">num = <span class="number">0b1111011</span>; <span class="comment">//  二进制的123</span></span><br><span class="line">num = <span class="number">0o173</span>; <span class="comment">// 八进制的123</span></span><br><span class="line">num = <span class="number">0x7b</span>; <span class="comment">// 十六进制的123</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串类型中你可以使用单引号和双引号包裹内容,你还可以使用 ES6 语法——模板字符串，拼接变量和字符串更为方便。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str: string = <span class="string">"Lison"</span>;</span><br><span class="line">str = <span class="string">"Li"</span>;</span><br><span class="line"><span class="keyword">const</span> first = <span class="string">"Lison"</span>;</span><br><span class="line"><span class="keyword">const</span> last = <span class="string">"Li"</span>;</span><br><span class="line">str = <span class="string">`<span class="subst">$&#123;first&#125;</span> <span class="subst">$&#123;last&#125;</span>`</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str) <span class="comment">// 打印结果为:Lison Li</span></span><br></pre></td></tr></table></figure>
<p>另外还有个和字符串相关的类型：字符串字面量类型。即把一个字符串字面量作为一种类型，比如上面的字符串”Lison”，当你把一个变量指定为这个字符串类型的时候，就不能再赋值为其他字符串值了，如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str: <span class="string">'Lison'</span></span><br><span class="line">str = <span class="string">'haha'</span> <span class="comment">// error 不能将类型“"haha"”分配给类型“"Lison"”</span></span><br></pre></td></tr></table></figure>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在 TypeScript 中有两种定义数组的方式：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list1: number[] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> list2: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<p>第一种形式通过<code>number[]</code>的形式来指定这个类型元素均为number类型的数组类型，这种写法是推荐的写法</p>
<p>当然你也可以使用第二种写法。注意，这两种写法中的<code>number</code>指定的是数组元素的类型，你也可以在这里将数组的元素指定为任意类型。</p>
<p>如果你要指定一个数组里的元素既可以是数值也可以是字符串，那么你可以使用这种方式：<code>number|string[]</code>，这种方式我们在后面学习联合类型的时候会讲到。</p>
<h3 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h3><p>null 和 undefined 有一些共同特点，所以我们放在一起讲。说它们有共同特点，是因为在 JavaScript 中，undefined 和 null 是两个基本数据类型。在 TypeScript 中，这两者都有各自的类型即 undefined 和 null，也就是说它们既是实际的值，也是类型，来看实际例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> n: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况下 undefined 和 null 可以赋值给任意类型的值，也就是说你可以把 undefined 赋值给 void 类型，也可以赋值给 number 类型。当你在 tsconfig.json 的”compilerOptions”里设置了<code>&quot;strictNullChecks&quot;: true</code>时，那必须严格对待。undefined 和 null 将只能赋值给它们自身和 void 类型，void类型我们后面会学习。</p>
<h3 id="object"><a href="#object" class="headerlink" title="object"></a>object</h3><p>object 在 JS 中是引用类型，它和 JS 中的其他基本类型不一样，像 number、string、boolean、undefined、null 这些都是基本类型，这些类型的变量存的是他们的值，而 object 类型的变量存的是引用，看个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strInit = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">let</span> strClone = strInit;</span><br><span class="line">strClone = <span class="string">"efg"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(strInit); <span class="comment">// 'abc'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> objInit = &#123; <span class="attr">a</span>: <span class="string">"aa"</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> objClone = objInit;</span><br><span class="line"><span class="built_in">console</span>.log(objClone) <span class="comment">// &#123;a:"aa"&#125;</span></span><br><span class="line">objInit.a = <span class="string">"bb"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(objClone); <span class="comment">// &#123; a: 'bb' &#125;</span></span><br></pre></td></tr></table></figure>

<p>通过例子可以看出，我们修改 objInit 时，objClone 也被修改了，是因为 objClone 保存的是 objInit 的引用，实际上 objInit 和 objClone 是同一个对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: object</span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">'Lison'</span> &#125;</span><br><span class="line">obj = <span class="number">123</span> <span class="comment">// error 不能将类型“123”分配给类型“object”</span></span><br></pre></td></tr></table></figure>

<p>这里有一点要注意了，你可能会想到给 obj 指定类型为 object 对象类型，然后给它赋值一个对象，后面通过属性访问操作符访问这个对象的某个属性，实际操作一下你就会发现会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj: object</span><br><span class="line">obj = &#123; <span class="attr">name</span>: <span class="string">'Lison'</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name) <span class="comment">// error 类型“object”上不存在属性“name”</span></span><br></pre></td></tr></table></figure>

<p>这里报错说类型 object 上没有 name 这个属性。如果你想要达到这种需求你应该使用我们后面章节要讲到的接口，那 object 类型适合什么时候使用呢？我们前面说了，当你希望一个值必须是对象而不是数值等类型时，比如我们定义一个函数，参数必须是对象，这个时候就用到object类型了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKeys</span> (<span class="params">obj: object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.keys(obj) <span class="comment">// 会以列表的形式返回obj中的值</span></span><br><span class="line">&#125;</span><br><span class="line">getKeys(&#123; <span class="attr">a</span>: <span class="string">'a'</span> &#125;) <span class="comment">// ['a']</span></span><br><span class="line">getKeys(<span class="number">123</span>) <span class="comment">// error 类型“123”的参数不能赋给类型“object”的参数</span></span><br></pre></td></tr></table></figure>
<p>这里涉及到的函数的相关知识，我们会在后面章节介绍的，你只要在这里明白object类型的使用就可以了。</p>
<h3 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h3><p>Symbol 是 ES6 加入的新的基础数据类型</p>
<h3 id="本节小结"><a href="#本节小结" class="headerlink" title="本节小结"></a>本节小结</h3><p>本小节我们学习了八个在JavaScript中我们就见过的数据类型，它们是：布尔类型、数值类型、字符串、数组、null、undefined、object以及ES6中新增的symbol。在TypeScript中它们都有对应的-类型关键字，对应关系为：</p>
<ul>
<li>布尔类型：boolean</li>
<li>数值类型：number</li>
<li>字符串类型：string</li>
<li>数组：Array<type>或type[]</li>
<li>对象类型：object</li>
<li>Symbol类型：symbol</li>
<li>null和undefined：null 和 undefined，这个比较特殊，它们自身即是类型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421184718.png" alt=""></p>
<h2 id="TS中补充的六个类型"><a href="#TS中补充的六个类型" class="headerlink" title="TS中补充的六个类型"></a>TS中补充的六个类型</h2><p>上个小节我们学习了八个JavaScript中常见的数据类型，你也学会了如何给一个变量指定类型。本小节我们将接触几个TypeScript中引入的新类型，这里面可能有你在其他强类型语言中见过的概念，接下来让我们一起来学习。</p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><p>元组可以看做是数组的拓展，它表示已知元素数量和类型的数组。确切地说，是已知数组中每一个位置上的元素的类型，来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple: [string, number, boolean];</span><br><span class="line">tuple = [<span class="string">"a"</span>, <span class="number">2</span>, <span class="literal">false</span>];</span><br><span class="line">tuple = [<span class="number">2</span>, <span class="string">"a"</span>, <span class="literal">false</span>]; <span class="comment">// error 不能将类型“number”分配给类型“string”。 不能将类型“string”分配给类型“number”。</span></span><br><span class="line">tuple = [<span class="string">"a"</span>, <span class="number">2</span>]; <span class="comment">// error Property '2' is missing in type '[string, number]' but required in type '[string, number, boolean]'</span></span><br></pre></td></tr></table></figure>

<p>可以看到，上面我们定义了一个元组 tuple，它包含三个元素，且每个元素的类型是固定的。当我们为 tuple 赋值时：<strong>各个位置上的元素类型都要对应，元素个数也要一致</strong>。</p>
<p>我们还可以给单个元素赋值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tuple[<span class="number">1</span>] = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p>这里我们给元组 tuple 的索引为 1 即第二个元素赋值为 3，第二个元素类型为 number，我们赋值给 3，所以没有问题。</p>
<p>当我们访问元组中元素时，TypeScript 会对我们在元素上做的操作进行检查：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tuple[<span class="number">0</span>].split(<span class="string">":"</span>); <span class="comment">// right 类型"string"拥有属性"split"</span></span><br><span class="line">tuple[<span class="number">1</span>].split(<span class="string">":"</span>); <span class="comment">// error 类型“number”上不存在属性“split”</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，我们访问的 tuple 的第二个元素的元素类型为 number，而数值没有 split 方法，所以会报错。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p><code>enum</code>类型在 C++这些语言中比较常见，TypeScript 在 ES 原有类型基础上加入枚举类型，使我们在 TypeScript 中也可以给一组数值赋予名字，这样对开发者来说较为友好。比如我们要定义一组角色，每一个角色用一个数字代表，就可以使用枚举类型来定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum Roles &#123;</span><br><span class="line">  SUPER_ADMIN,</span><br><span class="line">  ADMIN,</span><br><span class="line">  USER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义的枚举类型 Roles 里面有三个值，TypeScript 会为它们每个值分配编号，默认从 0 开始，依次排列，所以它们对应的值是：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum Roles &#123;</span><br><span class="line">  SUPER_ADMIN = <span class="number">0</span>,</span><br><span class="line">  ADMIN = <span class="number">1</span>,</span><br><span class="line">  USER = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们使用的时候，就可以使用名字而不需要记数字和名称的对照关系了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> superAdmin = Roles.SUPER_ADMIN;</span><br><span class="line"><span class="built_in">console</span>.log(superAdmin); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>你也可以修改这个数值，比如你想让这个编码从 1 开始而不是 0，可以如下定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum Roles &#123;</span><br><span class="line">  SUPER_ADMIN = <span class="number">1</span>,</span><br><span class="line">  ADMIN,</span><br><span class="line">  USER</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样当你访问<code>Roles.ADMIN</code>时，它的值就是 2 了。</p>
<p>你也可以为每个值都赋予不同的、不按顺序排列的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum Roles &#123;</span><br><span class="line">  SUPER_ADMIN = <span class="number">1</span>,</span><br><span class="line">  ADMIN = <span class="number">3</span>,</span><br><span class="line">  USER = <span class="number">7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过名字 Roles.SUPER_ADMIN 可以获取到它对应的值 1，同时你也可以通过值获取到它的名字，以上面任意数值这个例子为前提：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Roles[<span class="number">3</span>]); <span class="comment">// 'ADMIN'</span></span><br></pre></td></tr></table></figure>
<p>更多枚举的知识我们会在后面专门的一节讲解，在这里我们只是先有个初步的认识即可。</p>
<h3 id="Any"><a href="#Any" class="headerlink" title="Any"></a>Any</h3><p>JavaScript 的类型是灵活的，程序有时也是多变的。有时，我们在编写代码的时候，并不能清楚地知道一个值到底是什么类型，这时就需要用到 any 类型，即任意类型。我们来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value: any;</span><br><span class="line">value = <span class="number">123</span>;</span><br><span class="line">value = <span class="string">"abc"</span>;</span><br><span class="line">value = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>你可以看到，我们定义变量 value，指定它的类型为 any，接下来赋予任何类型的值都是可以的。</p>
<p>我们还可以在定义数组类型时使用 any 来指定数组中的元素类型为任意类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array: any[] = [<span class="number">1</span>, <span class="string">"a"</span>, <span class="literal">true</span>];</span><br></pre></td></tr></table></figure>

<p><strong>但是请注意，不要滥用 any，如果任何值都指定为 any 类型，那么 TypeScript 将失去它的意义</strong></p>
<p>所以如果类型是未知的，更安全的做法是使用unknown类型，我们本小节后面会讲到。</p>
<h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>void 和 any 相反，any 是表示任意类型，而 void 是表示没有任意类型，就是什么类型都不是，这在我们定义函数，函数没有返回值时会用到：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> consoleText = (text: string): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(text);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个函数没有返回任何的值，所以它的返回类型为 void。现在你只需知道 void 表达的含义即可，后面我们会用专门的一节来学习函数。</p>
<p><code>void</code> 类型的变量只能赋值为 <code>undefined</code> 和 <code>null</code>，其他类型不能赋值给 void 类型的变量。</p>
<h3 id="never"><a href="#never" class="headerlink" title="never"></a>never</h3><p>never 类型指那些永不存在的值的类型，它是那些总会抛出异常或根本不会有返回值的函数表达式的返回值类型，当变量被永不为真的类型保护（后面章节会详细介绍）所约束时，该变量也是 never 类型。</p>
<p>这个类型比较难理解，我们先来看几个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> errorFunc = (message: string): <span class="function"><span class="params">never</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个 errorFunc 函数总是会抛出异常，所以它的返回值类型是 never，用来表明它的返回值是永不存在的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> infiniteFunc = (): <span class="function"><span class="params">never</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>nfiniteFunc也是根本不会有返回值的函数，它和之前讲 void 类型时的consoleText函数不同，consoleText函数没有返回值，是我们在定义函数的时候没有给它返回值，而infiniteFunc是死循环是根本不会返回值的，所以它们二者还是有区别的。</p>
<p>never 类型是任何类型的子类型，所以它可以赋值给任何类型；而没有类型是 never 的子类型，所以除了它自身没有任何类型可以赋值给 never 类型，any 类型也不能赋值给 never 类型。我们来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> neverVariable = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">neverVariable = <span class="number">123</span>; <span class="comment">// error 不能将类型"number"分配给类型"never"</span></span><br></pre></td></tr></table></figure>

<p>上面例子我们定义了一个立即执行函数，也就是”let neverVariable = “右边的内容。右边的函数体内是一个死循环，所以这个函数调用后的返回值类型为 never，所以赋值之后 neverVariable 的类型是 never 类型，当我们给 neverVariable 赋值 123 时，就会报错，因为除它自身外任何类型都不能赋值给 never 类型。</p>
<h3 id="unknown"><a href="#unknown" class="headerlink" title="unknown"></a>unknown</h3><p><code>unknown</code>类型是TypeScript在3.0版本新增的类型，它表示未知的类型，这样看来它貌似和any很像，但是还是有区别的，也就是所谓的<strong>unknown相对于any是安全的</strong>。怎么理解呢？我们知道当一个值我们不能确定它的类型的时候，可以指定它是any类型；但是当指定了any类型之后，这个值基本上是“废”了，你可以随意对它进行属性方法的访问，不管有的还是没有的，可以把它当做任意类型的值来使用，这往往会产生问题，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> value: any</span><br><span class="line"><span class="built_in">console</span>.log(value.name)</span><br><span class="line"><span class="built_in">console</span>.log(value.toFixed())</span><br><span class="line"><span class="built_in">console</span>.log(value.length)</span><br></pre></td></tr></table></figure>

<p>上面这些语句都不会报错，因为value是any类型，所以后面三个操作都有合法的情况，当value是一个对象时，访问name属性是没问题的；当value是数值类型的时候，调用它的toFixed方法没问题；当value是字符串或数组时获取它的length属性是没问题的。</p>
<p>而当你指定值为unknown类型的时候，如果没有通过基于控制流的类型断言来缩小范围的话，是不能对它进行任何操作的，关于类型断言，我们后面小节会讲到。总之这里你知道了，unknown类型的值不是可以随便操作的。</p>
<p>我们这里只是先来了解unknown和any的区别，unknown还有很多复杂的规则，但是涉及到很多后面才学到的知识，所以需要我们学习了高级类型之后才能再讲解。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421190553.png" alt=""></p>
<h2 id="深入学习枚举"><a href="#深入学习枚举" class="headerlink" title="深入学习枚举"></a>深入学习枚举</h2><p>枚举是 TypeScript 新增加的一种数据类型，这在其他很多语言中很常见，但是 JavaScript 却没有。使用枚举，我们可以给一些难以理解的常量赋予一组具有意义的直观的名字，使其更为直观，你可以理解枚举就是一个字典。枚举使用 <code>enum</code> 关键字定义，TypeScript 支持数字和字符串的枚举。</p>
<h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><p>我们先来通过数字枚举的简单例子，来看下枚举是做什么的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">  Uploading,</span><br><span class="line">  Success,</span><br><span class="line">  Failed</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Status.Uploading); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(Status[<span class="string">"Success"</span>]); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(Status.Failed); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>我们使用enum关键字定义了一个枚举值 Status，它包含三个字段，每个字段间用逗号隔开。我们使用枚举值的元素值时，就像访问对象的属性一样，你可以使用’.‘操作符和’[]’两种形式访问里面的值，这和对象一样。</p>
<p>再来看输出的结果，<code>Status.Uploading</code> 是 0，<code>Status[&#39;Success&#39;]</code>是 1，<code>Status.Failed</code> 是 2，我们在定义枚举 Status 的时候，并没有指定索引号，是因为这是默认的编号，我们也可以自己指定：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改起始编号</span></span><br><span class="line">enum Color &#123;</span><br><span class="line">  Red = <span class="number">2</span>,</span><br><span class="line">  Blue,</span><br><span class="line">  Yellow</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Color.Red, Color.Blue, Color.Yellow); <span class="comment">// 2 3 4</span></span><br><span class="line"><span class="comment">// 指定任意字段的索引值</span></span><br><span class="line">enum Status &#123;</span><br><span class="line">  Success = <span class="number">200</span>,</span><br><span class="line">  NotFound = <span class="number">404</span>,</span><br><span class="line">  <span class="built_in">Error</span> = <span class="number">500</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Status.Success, Status.NotFound, Status.Error); <span class="comment">// 200 404 500</span></span><br><span class="line"><span class="comment">// 指定部分字段，其他使用默认递增索引</span></span><br><span class="line">enum Status &#123;</span><br><span class="line">  Ok = <span class="number">200</span>,</span><br><span class="line">  Created,</span><br><span class="line">  Accepted,</span><br><span class="line">  BadRequest = <span class="number">400</span>,</span><br><span class="line">  Unauthorized</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Status.Created, Status.Accepted, Status.Unauthorized); <span class="comment">// 201 202 401</span></span><br></pre></td></tr></table></figure>
<p><strong>数字枚举</strong>在定义值的时候，可以使用计算值和常量。但是要注意，如果某个字段使用了计算值或常量，那么该字段后面紧接着的字段必须设置初始值，这里不能使用默认的递增值了，来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getValue = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">enum ErrorIndex &#123;</span><br><span class="line">  a = getValue(),</span><br><span class="line">  b, <span class="comment">// error 枚举成员必须具有初始化的值</span></span><br><span class="line">  c</span><br><span class="line">&#125;</span><br><span class="line">enum RightIndex &#123;</span><br><span class="line">  a = getValue(),</span><br><span class="line">  b = <span class="number">1</span>,</span><br><span class="line">  c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Start = <span class="number">1</span>;</span><br><span class="line">enum Index &#123;</span><br><span class="line">  a = Start,</span><br><span class="line">  b, <span class="comment">// error 枚举成员必须具有初始化的值</span></span><br><span class="line">  c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h3><p>我们定义一个枚举值的时候，可以通过 Enum[‘key’]或者 Enum.key 的形式获取到对应的值 value。TypeScript 还支持反向映射，但是反向映射只支持数字枚举，我们后面要讲的字符串枚举是不支持的。来看下反向映射的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">  Success = <span class="number">200</span>,</span><br><span class="line">  NotFound = <span class="number">404</span>,</span><br><span class="line">  <span class="built_in">Error</span> = <span class="number">500</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Status[<span class="string">"Success"</span>]); <span class="comment">// 200</span></span><br><span class="line"><span class="built_in">console</span>.log(Status[<span class="number">200</span>]); <span class="comment">// 'Success'</span></span><br><span class="line"><span class="built_in">console</span>.log(Status[Status[<span class="string">"Success"</span>]]); <span class="comment">// 'Success'</span></span><br></pre></td></tr></table></figure>

<p>TypeScript 中定义的枚举，编译之后其实是对象，我们来看下上面这个例子中的枚举值 Status 编译后的样子：</p>
<blockquote>
<p>我们可以直接使用tsc指定某个文件或者不指定文件直接编译整个目录，运行后就会产生相应的编译后的JavaScript文件，你也可以到TypeScript官方文档提供的<a href="http://www.typescriptlang.org/play/index.html" target="_blank" rel="noopener">在线练习场</a>，在这里你可以编写TypeScript代码，它会同步进行编译。实时编译为JavaScript代码，是你了解编译后结果的好方式。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">200</span>: <span class="string">"Success"</span>,</span><br><span class="line">    <span class="number">404</span>: <span class="string">"NotFound"</span>,</span><br><span class="line">    <span class="number">500</span>: <span class="string">"Error"</span>,</span><br><span class="line">    <span class="built_in">Error</span>: <span class="number">500</span>,</span><br><span class="line">    NotFound: <span class="number">404</span>,</span><br><span class="line">    Success: <span class="number">200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，TypeScript 会把我们定义的枚举值的字段名分别作为对象的属性名和值，把枚举值的字段值分别作为对象的值和属性名，同时添加到对象中。这样我们既可以通过枚举值的字段名得到值，也可以通过枚举值的值得到字段名。</p>
<h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><p>TypeScript2.4 版本新增了字符串枚举，字符串枚举值要求每个字段的值都必须是字符串字面量，或者是该枚举值中另一个字符串枚举成员，先来看个简单例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">  <span class="built_in">Error</span> = <span class="string">"Sorry, error"</span>,</span><br><span class="line">  Success = <span class="string">"Hoho, success"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Message.Error); <span class="comment">// 'Sorry, error'</span></span><br></pre></td></tr></table></figure>

<p>再来看我们使用枚举值中其他枚举成员的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum Message &#123;</span><br><span class="line">  <span class="built_in">Error</span> = <span class="string">"error message"</span>,</span><br><span class="line">  ServerError = <span class="built_in">Error</span>,</span><br><span class="line">  ClientError = <span class="built_in">Error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Message.Error); <span class="comment">// 'error message'</span></span><br><span class="line"><span class="built_in">console</span>.log(Message.ServerError); <span class="comment">// 'error message'</span></span><br></pre></td></tr></table></figure>
<p>注意，这里的其他枚举成员指的是同一个枚举值中的枚举成员，因为字符串枚举不能使用常量或者计算值，所以也不能使用其他枚举值中的成员。</p>
<h3 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h3><p>简单来说异构枚举就是枚举值中成员值既有数字类型又有字符串类型，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum Result &#123;</span><br><span class="line">  Faild = <span class="number">0</span>,</span><br><span class="line">  Success = <span class="string">"Success"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="枚举成员类型和联合枚举类型"><a href="#枚举成员类型和联合枚举类型" class="headerlink" title="枚举成员类型和联合枚举类型"></a>枚举成员类型和联合枚举类型</h3><p>如果枚举值里所有成员的值都是字面量类型的值，那么这个枚举的每个成员和枚举值本身都可以作为类型来使用，先来看下满足条件的枚举成员的值有哪些：</p>
<ul>
<li>不带初始值的枚举成员，例如<code>enum E { A }</code></li>
<li>值为字符串字面量，例如<code>enum E { A = ‘a’ }</code></li>
<li>值为数值字面量，或者带有-符号的数值字面量，例如<code>enum E { A = 1 }、enum E { A = -1 }</code></li>
</ul>
<p>当我们的枚举值的所有成员的值都是上面这三种情况的时候，枚举值和成员就可以作为类型来用：</p>
<p><strong>枚举成员类型</strong><br>我们可以把符合条件的枚举值的成员作为类型来使用，来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum Animal &#123;</span><br><span class="line">  Dog = <span class="number">1</span>,</span><br><span class="line">  Cat = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">interface Dog &#123;</span><br><span class="line">  type: Animal.Dog; <span class="comment">// 这里使用Animal.Dog作为类型，指定接口Dog的必须有一个type字段，且类型为Animal.Dog</span></span><br><span class="line">&#125;</span><br><span class="line">interface Cat &#123;</span><br><span class="line">  type: Animal.Cat; <span class="comment">// 这里同上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cat1: Cat = &#123;</span><br><span class="line">  type: Animal.Dog <span class="comment">// error [ts] 不能将类型“Animal.Dog”分配给类型“Animal.Cat”</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> dog: Dog = &#123;</span><br><span class="line">  type: Animal.Dog</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>联合枚举类型</strong></p>
<p>当我们的枚举值符合条件时，这个枚举值就可以看做是一个包含所有成员的联合类型，先来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">  Off,</span><br><span class="line">  On</span><br><span class="line">&#125;</span><br><span class="line">interface Light &#123;</span><br><span class="line">  status: Status;</span><br><span class="line">&#125;</span><br><span class="line">enum Animal &#123;</span><br><span class="line">  Dog = <span class="number">1</span>,</span><br><span class="line">  Cat = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> light1: Light = &#123;</span><br><span class="line">  status: Animal.Dog <span class="comment">// error 不能将类型“Animal.Dog”分配给类型“Status”</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> light2: Light = &#123;</span><br><span class="line">  status: Status.Off</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> light3: Light = &#123;</span><br><span class="line">  status: Status.On</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="运行时的枚举"><a href="#运行时的枚举" class="headerlink" title="运行时的枚举"></a>运行时的枚举</h3><p>枚举在编译成 JavaScript 之后实际是一个对象。这个我们前面讲过了，既然是对象，那么就可以当成对象来使用，我们来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum E &#123;</span><br><span class="line">  A,</span><br><span class="line">  B</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getIndex = (enumObj: &#123; <span class="attr">A</span>: number &#125;): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> enumObj.A;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(getIndex(E)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子要求 getIndex 的参数为一个对象，且必须包含一个属性名为’A’的属性，其值为数值类型，只要有这个属性即可。当我们调用这个函数，把枚举值 E 作为实参传入是可以的，因为它在运行的时候是一个对象，包含’A’这个属性，因为它在运行的时候相当于下面这个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">0</span>: <span class="string">"A"</span>,</span><br><span class="line">    <span class="number">1</span>: <span class="string">"B"</span>,</span><br><span class="line">    A: <span class="number">0</span>,</span><br><span class="line">    B: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="const-enum"><a href="#const-enum" class="headerlink" title="const enum"></a>const enum</h3><p>我们定义了枚举值之后，编译成 JavaScript 的代码会创建一个对应的对象，这个对象我们可以在程序运行的时候使用。但是如果我们使用枚举只是为了让程序可读性好，并不需要编译后的对象呢？这样会增加一些编译后的代码量。所以 TypeScript 在 1.4 新增 const enum<em>(完全嵌入的枚举)</em>，在之前讲的定义枚举的语句之前加上const关键字，这样编译后的代码不会创建这个对象，只是会从枚举里拿到相应的值进行替换，来看我们下面的定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">  Off,</span><br><span class="line">  On</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> enum Animal &#123;</span><br><span class="line">  Dog,</span><br><span class="line">  Cat</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> status = Status.On;</span><br><span class="line"><span class="keyword">const</span> animal = Animal.Dog;</span><br></pre></td></tr></table></figure>

<p>上面的例子编译成 JavaScript 之后是这样的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Status;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">Status</span>) </span>&#123;</span><br><span class="line">  Status[(Status[<span class="string">"Off"</span>] = <span class="number">0</span>)] = <span class="string">"Off"</span>;</span><br><span class="line">  Status[(Status[<span class="string">"On"</span>] = <span class="number">1</span>)] = <span class="string">"On"</span>;</span><br><span class="line">&#125;)(Status || (Status = &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> status = Status.On;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="number">0</span>; <span class="comment">/* Dog */</span></span><br></pre></td></tr></table></figure>

<p>我们来看下 Status 的处理，先是定义一个变量 Status，然后定义一个立即执行函数，在函数内给 Status 添加对应属性，首先<code>Status[“Off”] = 0</code>是给Status对象设置Off属性，并且值设为 0，这个赋值表达式的返回值是等号右边的值，也就是 0，所以<code>Status[Status[“Off”] = 0] = &quot;Off&quot;</code>相当于<code>Status[0] = “Off”</code>。创建了这个对象之后，将 Status 的 On 属性值赋值给 status；再来看下 animal 的处理，我们看到编译后的代码并没有像Status创建一个Animal对象，而是直接把Animal.Dog的值0替换到了<code>const animal = Animal.Dog</code>表达式的Animal.Dog位置，这就是<strong>const enum</strong>的用法了。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本小节我们学习了两种基本的枚举：数字枚举和字符串枚举，它俩的最主要的区别就是枚举成员值的类型了，数字枚举成员的值必须都是数值类型，而字符串枚举成员的值必须都是字符串。枚举还有一个概念叫反向映射，就是当我们定义了枚举值后，不仅定义了字段到值的映射，同时编译器根据反向映射定义了值到字段的映射。我们还学习了数字枚举和字符串枚举的杂交体——异构枚举，但是很少用，原因也解释过了；枚举值和枚举成员在作为值使用的同时，还可以作为类型使用，但是有三个条件，可以回顾下；最后我们还学习了枚举值在编译后是一个对象，可以在运行时使用，如果我们在运行时用不到，可以在定义枚举时在前面加上const来选择不生成对象，而是直接将值替换到响应位置。</p>
<h2 id="使用类型断言达到预期"><a href="#使用类型断言达到预期" class="headerlink" title="使用类型断言达到预期"></a>使用类型断言达到预期</h2><p>虽然 TypeScript 很强大，但有时它还是不如我们了解一个值的类型，这时候我们更希望 TypeScript 不要帮我们进行类型检查，而是交给我们自己来，所以就用到了类型断言。类型断言有点像是一种类型转换，它把某个值强行指定为特定类型，我们先看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getLength = <span class="function"><span class="params">target</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (target.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> target.length;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target.toString().length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个函数能够接收一个参数，并返回它的长度，我们可以传入字符串、数组或数值等类型的值。如果有 length 属性，说明参数是数组或字符串类型，如果是数值类型是没有 length 属性的，所以需要把数值类型转为字符串然后再获取 length 值。现在我们限定传入的值只能是字符串或数值类型的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getLength = (target: string | number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (target.length) &#123; <span class="comment">// error 报错信息看下方</span></span><br><span class="line">    <span class="keyword">return</span> target.length; <span class="comment">// error 报错信息看下方</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> target.toString().length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法，所以现在加了对参数target和返回值的类型定义之后就会报错</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型"string | number"上不存在属性"length"</span></span><br><span class="line"><span class="comment">// 类型"number"上不存在属性"length"</span></span><br></pre></td></tr></table></figure>

<p>很显然，我们是要做判断的，我们判断如果 target.length 不为 undefined， 说明它是有 length 属性的，但我们的参数是string | number联合类型，所以在我们开始做判断的时候就会报错。这个时候就要用类型断言，将tagrget的类型断言成string类型。它有两种写法:<br>一种是<code>&lt;type&gt;value</code>，一种是<code>value as type</code>，下面例子中我们用两种形式都写出来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getStrLength = (target: string | number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="xml"><span class="tag">&lt;<span class="name">string</span>&gt;</span>target).length) &#123; // 这种形式在JSX代码中不可以使用，而且也是TSLint不建议的写法</span></span><br><span class="line"><span class="xml">    return (target as string).length; // 这种形式是没有任何问题的写法，所以建议大家始终使用这种形式</span></span><br><span class="line"><span class="xml">  &#125; else &#123;</span></span><br><span class="line"><span class="xml">    return target.toString().length;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>例子的函数体用到了三次target，前两次都是访问了 target.length 属性，所以都要用类型断言来表明这个地方是 string 类型；而最后的 target 调用了 toString方法，因为 number 和 string 类型的值都有 toString 方法，所以没有报错。</p>
<p>这样虽然没问题了，但是每一处不同值会有不同情况的地方都需要用类型断言，后面讲到高级类型的时候会讲如何使用自定义类型保护来简化这里。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>本小节我们学习了类型断言的使用。使用类型断言，我们可以告诉编译器某个值确实是我们所认为的值，从而让编译器进行正确的类型推断，让类型检查符合我们的预期。下个小节我们将学习接口，学习了接口后，我们就可以定义几乎所有的数据结构了。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421200149.png" alt=""></p>
<h2 id="使用接口定义几乎任意结构"><a href="#使用接口定义几乎任意结构" class="headerlink" title="使用接口定义几乎任意结构"></a>使用接口定义几乎任意结构</h2><p>使用接口定义几乎任意结构</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>我们需要定义这样一个函数，参数是一个对象，里面包含两个字段：firstName 和 lastName，也就是英文的名和姓，然后返回一个拼接后的完整名字。来看下函数的定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注：这段代码为纯JavaScript代码，请在JavaScript开发环境编写下面代码，在TypeScript环境会报一些类型错误</span></span><br><span class="line"><span class="keyword">const</span> getFullName = <span class="function">(<span class="params">&#123; firstName, lastName &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用时传入参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getFullName(&#123;</span><br><span class="line">  firstName: <span class="string">"Lison"</span>,</span><br><span class="line">  lastName: <span class="string">"Li"</span></span><br><span class="line">&#125;); <span class="comment">// =&gt; 'Lison Li'</span></span><br></pre></td></tr></table></figure>
<p>没有问题，我们得到了拼接后的完整名字，但是使用这个函数的人如果传入一些不是很理想的参数时，就会导致各种结果：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getFullName(); <span class="comment">// Uncaught TypeError: Cannot destructure property `a` of 'undefined' or 'null'.</span></span><br><span class="line">getFullName(&#123; <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">phone</span>: <span class="string">"13312345678"</span> &#125;); <span class="comment">// 'undefined undefined'</span></span><br><span class="line">getFullName(&#123; <span class="attr">firstName</span>: <span class="string">"Lison"</span> &#125;); <span class="comment">// 'Lison undefined'</span></span><br></pre></td></tr></table></figure>

<p>这些都是我们不想要的，在开发时难免会传入错误的参数，所以 TypeScript 能够帮我们在编译阶段就检测到这些错误。我们来完善下这个函数的定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getFullName = (&#123;</span><br><span class="line">  firstName,</span><br><span class="line">  lastName,</span><br><span class="line">&#125;: &#123; <span class="comment">// 指定这个参数的类型，因为他是一个对象，所以这里来指定对象中每个字段的类型</span></span><br><span class="line">  firstName: string; <span class="comment">// 指定属性名为firstName和lastName的字段的属性值必须为string类型</span></span><br><span class="line">  lastName: string;</span><br><span class="line">&#125;) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们通过对象字面量的形式去限定我们传入的这个对象的结构，现在再来看下之前的调用会出现什么提示：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getFullName(); <span class="comment">// 应有1个参数，但获得0个</span></span><br><span class="line">getFullName(&#123; <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">phone</span>: <span class="number">123456789</span> &#125;); <span class="comment">// 类型“&#123; age: number; phone: number; &#125;”的参数不能赋给类型“&#123; firstName: string; lastName: string; &#125;”的参数。</span></span><br><span class="line">getFullName(&#123; <span class="attr">firstName</span>: <span class="string">"Lison"</span> &#125;); <span class="comment">// 缺少必要属性lastName</span></span><br></pre></td></tr></table></figure>

<p>这些都是在我们编写代码的时候 TypeScript 提示给我们的错误信息，这样就避免了在使用函数的时候传入不正确的参数。接下来我们用这节课要讲的接口来书写上面的规则，我们使用interface来定义接口：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Info &#123;</span><br><span class="line">  firstName: string;</span><br><span class="line">  lastName: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getFullName = <span class="function">(<span class="params">&#123; firstName, lastName &#125;: Info</span>) =&gt;</span></span><br><span class="line">  <span class="string">`<span class="subst">$&#123;firstName&#125;</span> <span class="subst">$&#123;lastName&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<p>注意在定义接口的时候，你不要把它理解为是在定义一个对象，而要理解为{}括号包裹的是一个代码块，里面是一条条声明语句，只不过声明的不是变量的值而是类型。声明也不用等号赋值，而是冒号指定类型。每条声明之前用换行分隔即可，或者也可以使用分号或者逗号，都是可以的。</p>
<h3 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h3><p>当我们定义一些结构的时候，一些结构对于某些字段的要求是可选的，有这个字段就做处理，没有就忽略，所以针对这种情况，typescript为我们提供了可选属性。</p>
<p>我们先定义一个描述传入蔬菜信息的句子的函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getVegetables = <span class="function">(<span class="params">&#123; color, type &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`A <span class="subst">$&#123;color ? color + <span class="string">" "</span> : <span class="string">""</span>&#125;</span><span class="subst">$&#123;type&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看到这个函数中根据传入对象中的 color 和 type 来进行描述返回一句话，color 是可选的，所以我们可以给接口设置可选属性，在属性名后面加个?即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Vegetables &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  type: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多余属性检查"><a href="#多余属性检查" class="headerlink" title="多余属性检查"></a>多余属性检查</h3><p>接上面例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getVegetables(&#123;</span><br><span class="line">  type: <span class="string">"tomato"</span>,</span><br><span class="line">  size: <span class="string">"big"</span> <span class="comment">// 'size'不在类型'Vegetables'中</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们看到，传入的参数没有 color 属性，但也没有错误，因为它是可选属性。但是我们多传入了一个 size 属性，这同样会报错，TypeScript 会告诉你，接口上不存在你多余的这个属性。只要接口中没有定义这个属性，就会报错，但如果你定义了可选属性 size，那么上面的例子就不会报错。</p>
<h3 id="绕开多余属性检查"><a href="#绕开多余属性检查" class="headerlink" title="绕开多余属性检查"></a>绕开多余属性检查</h3><p>有时我们并不希望 TypeScript 这么严格地对我们的数据进行检查，比如我们只需要保证传入<code>getVegetables</code>的对象有<code>type</code>属性就可以了，至于实际使用的时候传入对象有没有多余的属性，多余属性的属性值是什么类型，这些都无所谓，那就需要绕开多余属性检查，有如下三个方法：</p>
<p><strong>使用类型断言</strong><br>我们在基础类型中讲过，类型断言就是用来明确告诉 TypeScript，我们已经自行进行了检查，确保这个类型没有问题，希望 TypeScript 对此不进行检查，所以最简单的方式就是使用类型断言：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Vegetables &#123;</span><br><span class="line">  color?: string;</span><br><span class="line">  type: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getVegetables = <span class="function">(<span class="params">&#123; color, type &#125;: Vegetables</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`A <span class="subst">$&#123;color ? color + <span class="string">" "</span> : <span class="string">""</span>&#125;</span><span class="subst">$&#123;type&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line">getVegetables(&#123;</span><br><span class="line">  type: <span class="string">"tomato"</span>,</span><br><span class="line">  size: <span class="number">12</span>,</span><br><span class="line">  price: <span class="number">1.2</span></span><br><span class="line">&#125; <span class="keyword">as</span> Vegetables);</span><br></pre></td></tr></table></figure>
<p><strong>添加索引签名</strong><br>更好的方式是添加字符串索引签名，索引签名我们会在后面讲解，先来看怎么实现：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Vegetables &#123;</span><br><span class="line">  color: string;</span><br><span class="line">  type: string;</span><br><span class="line">  [prop: string]: any;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getVegetables = <span class="function">(<span class="params">&#123; color, type &#125;: Vegetables</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`A <span class="subst">$&#123;color ? color + <span class="string">" "</span> : <span class="string">""</span>&#125;</span><span class="subst">$&#123;type&#125;</span>`</span>;</span><br><span class="line">&#125;;</span><br><span class="line">getVegetables(&#123;</span><br><span class="line">  color: <span class="string">"red"</span>,</span><br><span class="line">  type: <span class="string">"tomato"</span>,</span><br><span class="line">  size: <span class="number">12</span>,</span><br><span class="line">  price: <span class="number">1.2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h3><p>接口也可以设置只读属性，如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Role &#123;</span><br><span class="line">  readonly <span class="number">0</span>: string;</span><br><span class="line">  readonly <span class="number">1</span>: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们定义了一个角色字典，有 0 和 1 两种角色 id。下面我们定义一个实际的角色  数据，然后来试图修改一下它的值：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> role: Role = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"super_admin"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"admin"</span></span><br><span class="line">&#125;;</span><br><span class="line">role[<span class="number">1</span>] = <span class="string">"super_admin"</span>; <span class="comment">// Cannot assign to '0' because it is a read-only property</span></span><br></pre></td></tr></table></figure>

<p>我们看到 TypeScript 告诉我们不能分配给索引0，因为它是只读属性。设置一个值只读，我们是否想到ES6里定义常量的关键字<code>const</code>？使用<code>const</code>定义的常量定义之后不能再修改，这有点只读的意思。那<code>readonly</code>和<code>const</code>在使用时该如何选择呢？这主要看你这个值的用途，如果是定义一个常量，那用<code>const</code>，如果这个值是作为对象的属性，那请用<code>readonly</code>。我们来看下面的代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> NAME: string = <span class="string">"Lison"</span>;</span><br><span class="line">NAME = <span class="string">"Haha"</span>; <span class="comment">// Uncaught TypeError: Assignment to constant variable</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name: <span class="string">"lison"</span></span><br><span class="line">&#125;;</span><br><span class="line">obj.name = <span class="string">"Haha"</span>;</span><br><span class="line"></span><br><span class="line">interface Info &#123;</span><br><span class="line">  readonly name: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> info: Info = &#123;</span><br><span class="line">  name: <span class="string">"Lison"</span></span><br><span class="line">&#125;;</span><br><span class="line">info[<span class="string">"name"</span>] = <span class="string">"Haha"</span>; <span class="comment">// Cannot assign to 'name' because it is a read-only property</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到上面使用const定义的常量NAME定义之后再修改会报错，但是如果使用const定义一个对象，然后修改对象里属性的值是不会报错的。所以如果我们要保证对象的属性值不可修改，需要使用readonly。</p>
<h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><p>接口可以描述普通对象，还可以描述函数类型，我们先看写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface AddFunc &#123;</span><br><span class="line">  (num1: number, <span class="attr">num2</span>: number): number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们定义了一个AddFunc结构，这个结构要求实现这个结构的值，必须包含一个和结构里定义的函数一样参数、一样返回值的方法，或者这个值就是符合这个函数要求的函数。我们管花括号里包着的内容为调用签名，它由带有参数类型的参数列表和返回值类型组成。后面学到类型别名一节时我们还会学习其他写法。来看下如何使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add: AddFunc = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> n1 + n2;</span><br><span class="line"><span class="keyword">const</span> join: AddFunc = <span class="function">(<span class="params">n1, n2</span>) =&gt;</span> <span class="string">`<span class="subst">$&#123;n1&#125;</span> <span class="subst">$&#123;n2&#125;</span>`</span>; <span class="comment">// 不能将类型'string'分配给类型'number'</span></span><br><span class="line">add(<span class="string">"a"</span>, <span class="number">2</span>); <span class="comment">// 类型'string'的参数不能赋给类型'number'的参数</span></span><br></pre></td></tr></table></figure>

<p>上面我们定义的add函数接收两个数值类型的参数，返回的结果也是数值类型，所以没有问题。而join函数参数类型没错，但是返回的是字符串，所以会报错。而当我们调用add函数时，传入的参数如果和接口定义的类型不一致，也会报错。</p>
<p>你应该注意到了，实际定义函数的时候，名字是无需和接口中参数名相同的，只需要位置对应即可。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>本小节我们学习了接口的一些基本定义和用法，通过使用接口，我们可以定义绝大部分的数据结构，从而限定值的结构。我们可以通过修饰符来指定结构中某个字段的可选性和只读性，以及默认情况下必选性。而接口的校验是严格的，在定义一个实现某个接口的值的时候，对于接口中没有定义的字段是不允许出现的，我们称这个为多余属性检查；同时我们讲了三种绕过多余属性检查的方法，来满足程序的灵活性。最后我们学习了如何通过接口，来定义函数类型，当然我们后面还会学习其他定义函数类型的方法。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421202053.png" alt=""></p>
<h2 id="接口的高阶用法"><a href="#接口的高阶用法" class="headerlink" title="接口的高阶用法"></a>接口的高阶用法</h2><p>学习了上个小节接口的基础用法后，相信你已经能够使用接口来描述一些结构了。本小节我们来继续学习接口，学习接口的高阶用法。接口有一小部分知识与类的知识相关，所以我们放在讲解类的小节后面补充讲解，我们先来学习除了这一小部分之外剩下的接口的知识。</p>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>我们可以使用接口描述索引的类型和通过索引得到的值的类型，比如一个数组<code>[‘a’, ‘b’]</code>，数字索引<code>0</code>对应的通过索引得到的值为<code>’a’</code>。我们可以同时给索引和值都设置类型，看下面的示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface RoleDic &#123;</span><br><span class="line">  [id: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> role1: RoleDic = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"super_admin"</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">"admin"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> role2: RoleDic = &#123;</span><br><span class="line">  s: <span class="string">"super_admin"</span>,  <span class="comment">// error 不能将类型"&#123; s: string; a: string; &#125;"分配给类型"RoleDic"。</span></span><br><span class="line">  a: <span class="string">"admin"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> role3: RoleDic = [<span class="string">"super_admin"</span>, <span class="string">"admin"</span>];</span><br></pre></td></tr></table></figure>

<p>上面的例子中 role3 定义了一个数组，索引为数值类型，值为字符串类型。</p>
<p>你也可以给索引设置<code>readonly</code>，从而防止索引返回值被修改。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface RoleDic &#123;</span><br><span class="line">  readonly [id: number]: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> role: RoleDic = &#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">"super_admin"</span></span><br><span class="line">&#125;;</span><br><span class="line">role[<span class="number">0</span>] = <span class="string">"admin"</span>; <span class="comment">// error 类型"RoleDic"中的索引签名仅允许读取</span></span><br></pre></td></tr></table></figure>

<p>这里有的点需要注意，你可以设置索引类型为 number。但是这样如果你将属性名设置为字符串类型，则会报错；但是如果你设置索引类型为字符串类型，那么即便你的属性名设置的是数值类型，也没问题。因为 JS 在访问属性值的时候，如果属性名是数值类型，会先将数值类型转为字符串，然后再去访问。你可以看下这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="number">123</span>: <span class="string">"a"</span>, <span class="comment">// 这里定义一个数值类型的123这个属性</span></span><br><span class="line">  <span class="string">"123"</span>: <span class="string">"b"</span> <span class="comment">// 这里在定义一个字符串类型的123这个属性，这里会报错：标识符“"123"”重复。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; '123': 'b' &#125;</span></span><br></pre></td></tr></table></figure>
<p>如果数值类型的属性名不会转为字符串类型，那么这里数值123和字符串123是不同的两个值，则最后对象obj应该同时有这两个属性；但是实际打印出来的obj只有一个属性，属性名为字符串”123”，而且值为”b”，说明数值类型属性名123被覆盖掉了，就是因为它被转为了字符串类型属性名”123”；又因为一个对象中多个相同属性名的属性，定义在后面的会覆盖前面的，所以结果就是obj只保留了后面定义的属性值。</p>
<h3 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h3><p>接口可以继承，这和类(类的相关知识，我们会在后面全面详细的学习)一样，这提高了接口的可复用性。来看一个场景：</p>
<p>我们定义一个<code>Vegetables</code>接口，它会对<code>color</code>属性进行限制。再定义两个接口，一个为<code>Tomato</code>，一个为<code>Carrot</code>，这两个类都需要对<code>color</code>进行限制，而各自又有各自独有的属性限制，我们可以这样定义：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Vegetables &#123;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line">interface Tomato &#123;</span><br><span class="line">  color: string;</span><br><span class="line">  radius: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Carrot &#123;</span><br><span class="line">  color: string;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>三个接口中都有对<code>color</code>的定义，但是这样写很繁琐，所以我们可以用继承来改写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Vegetables &#123;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line">interface Tomato extends Vegetables &#123;</span><br><span class="line">  radius: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Carrot extends Vegetables &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> tomato: Tomato = &#123;</span><br><span class="line">  radius: <span class="number">1.2</span> <span class="comment">// error  Property 'color' is missing in type '&#123; radius: number; &#125;'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> carrot: Carrot = &#123;</span><br><span class="line">  color: <span class="string">"orange"</span>,</span><br><span class="line">  length: <span class="number">20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面定义的 <code>tomato</code>变量因为缺少了从<code>Vegetables</code>接口继承来的 <code>color</code> 属性，从而报错。</p>
<p>一个接口可以被多个接口继承，同样，一个接口也可以继承多个接口，多个接口用逗号隔开。比如我们再定义一个<code>Food</code>接口，<code>Tomato</code> 也可以继承<code>Food</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Vegetables &#123;</span><br><span class="line">  color: string;</span><br><span class="line">&#125;</span><br><span class="line">interface Food &#123;</span><br><span class="line">  type: string;</span><br><span class="line">&#125;</span><br><span class="line">interface Tomato extends Food, Vegetables &#123;</span><br><span class="line">  radius: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tomato: Tomato = &#123;</span><br><span class="line">  type: <span class="string">"vegetables"</span>,</span><br><span class="line">  color: <span class="string">"red"</span>,</span><br><span class="line">  radius: <span class="number">1.2</span></span><br><span class="line">&#125;;  <span class="comment">// 在定义tomato变量时将继承过来的color和type属性同时声明</span></span><br></pre></td></tr></table></figure>

<h3 id="混合类型接口"><a href="#混合类型接口" class="headerlink" title="混合类型接口"></a>混合类型接口</h3><p>JS 的类型是灵活的。在 JS 中，函数是对象类型。对象可以有属性，所以有时我们的一个对象，它既是一个函数，也包含一些属性。比如我们要实现一个计数器函数，比较直接的做法是定义一个函数和一个全局变量：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> countUp = <span class="function"><span class="params">()</span> =&gt;</span> count++;</span><br></pre></td></tr></table></figure>
<p>但是这种方法需要在函数外面定义一个变量，更优一点的方法是使用闭包：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">const</span> countUp = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ++count;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(countUp()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(countUp()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>在 TypeScript3.1 版本之前，我们需要借助命名空间来实现。但是在 3.1 版本，TypeScript 支持直接给函数添加属性，虽然这在 JS 中早就支持了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">let</span> countUp = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> ++countUp.count;</span><br><span class="line">&#125;;</span><br><span class="line">countUp.count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(countUp()); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(countUp()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>


<p>我们可以看到，我们把一个函数赋值给<code>countUp</code>，又给它绑定了一个属性<code>count</code>，我们的计数保存在这个 <code>count</code> 属性中。</p>
<p>我们可以使用混合类型接口来指定上面例子中 <code>countUp</code> 的类型</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Counter &#123;</span><br><span class="line">  (): <span class="keyword">void</span>; <span class="comment">// 这里定义Counter这个结构必须包含一个函数，函数的要求是无参数，返回值为void，即无返回值</span></span><br><span class="line">  count: number; <span class="comment">// 而且这个结构还必须包含一个名为count、值的类型为number类型的属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getCounter = (): <span class="function"><span class="params">Counter</span> =&gt;</span> &#123; <span class="comment">// 这里定义一个函数用来返回这个计数器</span></span><br><span class="line">  <span class="keyword">const</span> c = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 定义一个函数，逻辑和前面例子的一样</span></span><br><span class="line">    c.count++;</span><br><span class="line">  &#125;;</span><br><span class="line">  c.count = <span class="number">0</span>; <span class="comment">// 再给这个函数添加一个count属性初始值为0</span></span><br><span class="line">  <span class="keyword">return</span> c; <span class="comment">// 最后返回这个函数对象</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> counter: Counter = getCounter(); <span class="comment">// 通过getCounter函数得到这个计数器</span></span><br><span class="line">counter();</span><br><span class="line"><span class="built_in">console</span>.log(counter.count); <span class="comment">// 1</span></span><br><span class="line">counter();</span><br><span class="line"><span class="built_in">console</span>.log(counter.count); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>getCounter</code>函数返回值类型为<code>Counter</code>，它是一个函数，无返回值，即返回值类型为<code>void</code>，它还包含一个属性<code>count</code>，属性返回值类型为<code>number</code>。</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>本小节我们在接口基础知识的基础上，学习了接口的高阶用法。我们学习了如何限定索引的类型，即使用[]将索引名括起来，然后使用: type来指定索引的类型；还学习了一种复用现有接口的接口定义方式，即继承，使用extends关键字实现继承；最后我们通过计数器的例子，学习了如何使用混合类型接口实现更复杂的数据结构。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421210245.png" alt=""></p>
<h2 id="为函数和函数参数定义类型"><a href="#为函数和函数参数定义类型" class="headerlink" title="为函数和函数参数定义类型"></a>为函数和函数参数定义类型</h2><p>本小节我们来学习函数类型的定义，以及对函数参数的详细介绍。前面我们在讲object例子的时候见过简单的函数定义，在那个例子中我们学习了如何简单地为一个参数指定类型。在本小节你将学习三种定义函数类型的方式，以及关于参数的三个知识——即可选参数、默认参数和剩余参数。</p>
<h3 id="函数类型-1"><a href="#函数类型-1" class="headerlink" title="函数类型"></a>函数类型</h3><h4 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h4><p>我们可以给函数定义类型，这个定义包括对参数和返回值的类型定义，我们先来看简单的定义写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">arg1: number, arg2: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> add = (arg1: number, <span class="attr">arg2</span>: number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中我们用function和箭头函数两种形式定义了add函数，以展示如何定义函数类型。这里参数 arg1 和 arg2 都是数值类型，最后通过相加得到的结果也是数值类型。</p>
<p>如果在这里省略参数的类型，TypeScript 会默认这个参数是 any 类型；如果省略返回值的类型，如果函数无返回值，那么 TypeScript 会默认函数返回值是 void 类型；如果函数有返回值，那么 TypeScript 会根据我们定义的逻辑推断出返回类型。</p>
<h4 id="完整的函数类型"><a href="#完整的函数类型" class="headerlink" title="完整的函数类型"></a>完整的函数类型</h4><p>一个函数的定义包括函数名、参数、逻辑和返回值。我们为一个函数定义类型时，完整的定义应该包括参数类型和返回值类型。上面的例子中，我们都是在定义函数的指定参数类型和返回值类型。接下来我们看下，如何定义一个完整的函数类型，以及用这个函数类型来规定一个函数定义时参数和返回值需要符合的类型。先来看例子然后再进行解释：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> add: <span class="function">(<span class="params">x: number, y: number</span>) =&gt;</span> number;</span><br><span class="line">add = (arg1: number, <span class="attr">arg2</span>: number): <span class="function"><span class="params">number</span> =&gt;</span> arg1 + arg2;</span><br><span class="line">add = (arg1: string, <span class="attr">arg2</span>: string): <span class="function"><span class="params">string</span> =&gt;</span> arg1 + arg2; <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>上面这个例子中，我们首先定义了一个变量 <code>add</code>，给它指定了函数类型，也就是<code>(x: number, y: number) =&gt; number</code>，这个函数类型包含参数和返回值的类型。然后我们给 add 赋了一个实际的函数，这个函数参数类型和返回类型都和函数类型中定义的一致，所以可以赋值。后面我们又给它赋了一个新函数，而这个函数的参数类型和返回值类型都是 string 类型，这时就会报如下错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">不能将类型<span class="string">"(arg1: string, arg2: string) =&gt; string"</span>分配给类型<span class="string">"(x: number, y: number) =&gt; number"</span>。</span><br><span class="line">  参数<span class="string">"arg1"</span>和<span class="string">"x"</span> 的类型不兼容。</span><br><span class="line">    不能将类型<span class="string">"number"</span>分配给类型<span class="string">"string"</span>。</span><br></pre></td></tr></table></figure>

<h4 id="使用接口定义函数类型"><a href="#使用接口定义函数类型" class="headerlink" title="使用接口定义函数类型"></a>使用接口定义函数类型</h4><p>我们在前面的小节中已经学习了接口，使用接口可以清晰地定义函数类型。还拿上面的 add 函数为例，我们为它使用接口定义函数类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Add &#123;</span><br><span class="line">  (x: number, <span class="attr">y</span>: number): number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> add: Add = <span class="function">(<span class="params">arg1: string, arg2: string</span>): <span class="params">string</span> =&gt;</span> arg1 + arg2; <span class="comment">// error 不能将类型“(arg1: string, arg2: string) =&gt; string”分配给类型“Add”</span></span><br></pre></td></tr></table></figure>

<p>这里我们通过接口的形式定义函数类型，这个接口<code>Add</code>定义了这个结构是一个函数，两个参数类型都是<code>number</code>类型，返回值也是<code>number</code>类型。然后我们指定变量<code>add</code>类型为<code>Add</code>时，再要给<code>add</code>赋值，就必须是一个函数，且参数类型和返回值类型都要满足接口<code>Add</code>，显然例子中这个函数并不满足条件，所以报错了。</p>
<h4 id="使用类型别名"><a href="#使用类型别名" class="headerlink" title="使用类型别名"></a>使用类型别名</h4><p>我们可以使用类型别名来定义函数类型，类型别名我们在后面讲到高级类型的时候还会讲到。使用类型别名定义函数类型更直观易读，我们来看一下具体的写法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type Add = <span class="function">(<span class="params">x: number, y: number</span>) =&gt;</span> number;</span><br><span class="line"><span class="keyword">let</span> add: Add = <span class="function">(<span class="params">arg1: string, arg2: string</span>): <span class="params">string</span> =&gt;</span> arg1 + arg2; <span class="comment">// error 不能将类型“(arg1: string, arg2: string) =&gt; string”分配给类型“Add”</span></span><br></pre></td></tr></table></figure>
<p>使用<code>type</code>关键字可以为原始值、联合类型、元组以及任何我们定义的类型起一个别名。上面定义了 Add 这个别名后，<code>Add</code>就成为了一个和<code>(x: number, y: number) =&gt; number</code>一致的类型定义。例子中定义了<code>Add</code>类型，指定<code>add</code>类型为<code>Add</code>，但是给<code>add</code>赋的值并不满足<code>Add</code>类型要求，所以报错了。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><p>TypeScript 会帮我们在编写代码的时候就检查出调用函数时参数中存在的一些错误，先看下面例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type Add = <span class="function">(<span class="params">x: number, y: number</span>) =&gt;</span> number;</span><br><span class="line"><span class="keyword">let</span> add: Add = (arg1: string, <span class="attr">arg2</span>: string): <span class="function"><span class="params">string</span> =&gt;</span> arg1 + arg2;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// right</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// error 应有 2 个参数，但获得 3 个</span></span><br><span class="line">add(<span class="number">1</span>); <span class="comment">// error 应有 2 个参数，但获得 1 个</span></span><br></pre></td></tr></table></figure>

<p>在 JS 中，上面例子中最后两个函数调用都不会报错, 只不过<code>add(1, 2, 3)</code>可以返回正确结果3，<code>add(1)</code>会返回<code>NaN</code>。</p>
<p>但有时候，我们的函数有些参数不是必须的，是可选的。在学习接口的时候我们学习过，可选参数只需在参数名后跟随一个?即可。但是接口形式的定义和今天学到的函数类型定义有一点区别，那就是参数位置的要求：</p>
<blockquote>
<p>接口形式定义的函数类型必选参数和可选参数的位置前后是无所谓的，但是今天学到的定义形式，可选参数必须放在必选参数后面，这和在 JS 中定义函数是一致的。</p>
</blockquote>
<p>来看下面的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">type Add = <span class="function">(<span class="params">x?: number, y: number</span>) =&gt;</span> number; <span class="comment">// error 必选参数不能位于可选参数后。</span></span><br></pre></td></tr></table></figure>
<p>在TypeScript中，可选参数放到最后才行，上面例子中把可选参数x放到了必选参数y前面，所以报错了；但是在 JavaScript 中，其实是没有可选参数这个概念的，只不过是我们在写逻辑的时候，我们可能会判断某个参数是否为<code>undefined</code>，如果是则说明调用该函数的时候没有传这个参数，要做下兼容处理；而如果几个参数中，前面的参数是可不传的，后面的参数是需要传的，就需要在该可不传的参数位置传入一个 <code>undefined</code> 占位才行。</p>
<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>在 ES6 标准出来之前，我们的默认参数实现起来比较繁琐：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countUp</span>(<span class="params">step</span>) </span>&#123;</span><br><span class="line">  step = step || <span class="number">1</span>;</span><br><span class="line">  count += step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面我们定义了一个计数器增值函数，这个函数有一个参数 <code>step</code>，即每次增加的步长，如果不传入参数，那么 <code>step</code> 接受到的就是 <code>undefined</code>，<code>undefined</code> 转换为布尔值是 <code>false</code>，所以<code>step || 1</code>这里取了 1，从而达到了不传参数默认 <code>step === 1</code> 的效果。</p>
<p>在 ES6 中，我们定义函数时给参数设默认值就很方便了，直接在参数后面使用等号连接默认值即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">const</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> countUp = <span class="function">(<span class="params">step = <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">  count += step;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>你会发现，可选参数和带默认值的参数在函数调用时都是可以不传实参的，但是区别在于定义函数的时候，可选参数必须放在必选参数后面，而带默认值的参数则可放在必须参数前后都可。</p>
<p>当我们为参数指定了默认参数的时候，TypeScript 会识别默认参数的类型；当我们在调用函数时，如果给这个带默认值的参数传了别的类型的参数则会报错：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x: number, y = <span class="number">2</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line">add(<span class="number">1</span>, <span class="string">"a"</span>); <span class="comment">// error 类型"string"的参数不能赋给类型"number"的参数</span></span><br></pre></td></tr></table></figure>

<p>当然了，你也可以显式地给 y 设置类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x: number, y: number = <span class="number">2</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>在 JS 中，如果我们定义一个函数，这个函数可以输入任意个数的参数，那么我们就无法在定义参数列表的时候挨个定义。在 ES6 发布之前，我们需要用到 arguments 来获取参数列表。arguments 是每一个函数都包含的一个类数组对象，它包含在函数调用时传入函数的所有实际参数（简称实参），它还包含一个 length 属性，记录参数个数。来看下面的例子，我们来模拟实现函数的重载：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleData</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>] * <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">arguments</span>[<span class="number">0</span>] * <span class="built_in">arguments</span>[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.apply(<span class="built_in">arguments</span>).join(<span class="string">"_"</span>);</span><br><span class="line">&#125;</span><br><span class="line">handleData(<span class="number">2</span>); <span class="comment">// 4</span></span><br><span class="line">handleData(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 6</span></span><br><span class="line">handleData(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// '1_2_3_4_5'</span></span><br><span class="line"><span class="comment">// 这段代码如果在TypeScript环境中，三个对handleData函数的调用都会报错，因为handleData函数定义的时候没有参数。</span></span><br></pre></td></tr></table></figure>

<p>上面这个函数通过判断传入实参的个数，做出不同的处理并返回结果。else 后面的逻辑是如果实参个数不为 1 和 2，那么将这些参数拼接成以”_”连接的字符串。</p>
<blockquote>
<p>你应该注意到了我们使用Array.prototype.slice.apply(arguments)对 arguments 做了处理，前面我们讲过 arguments 不是数组，而是类数组对象，如果直接在 arguments 调用 join 方法，它是没有这个方法的。所以我们通过这个处理得到一个包含 arguments 中所有元素的真实数组。</p>
</blockquote>
<p>在 ES6 中，加入了<code>…</code>拓展运算符，它可以将一个函数或对象进行拆解。它还支持用在函数的参数列表中，用来处理任意数量的参数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleData = <span class="function">(<span class="params">arg1, ...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这里省略逻辑</span></span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;;</span><br><span class="line">handleData(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// [ 2, 3, 4, 5 ]</span></span><br></pre></td></tr></table></figure>

<p>可以看到，args 是除了 arg1 之外的所有实参的集合，它是一个数组。</p>
<p>在 TypeScript 中你可以为剩余参数指定类型，先来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleData = <span class="function">(<span class="params">arg1: number, ...args: number[]</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">&#125;;</span><br><span class="line">handleData(<span class="number">1</span>, <span class="string">"a"</span>); <span class="comment">// error 类型"string"的参数不能赋给类型"number"的参数</span></span><br></pre></td></tr></table></figure>

<h3 id="函数重载，此重载vs彼重载"><a href="#函数重载，此重载vs彼重载" class="headerlink" title="函数重载，此重载vs彼重载"></a>函数重载，此重载vs彼重载</h3><p>在其他一些强类型语言中，函数重载是指定义几个函数名相同，但参数个数或类型不同的函数，在调用时传入不同的参数，编译器会自动调用适合的函数。但是 JavaScript 作为一个动态语言是没有函数重载的，只能我们自己在函数体内通过判断参数的个数、类型来指定不同的处理逻辑。来看个简单的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handleData = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">"string"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value.split(<span class="string">""</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">      .toString()</span><br><span class="line">      .split(<span class="string">""</span>)</span><br><span class="line">      .join(<span class="string">"_"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个例子中，当传入的参数为字符串时，将它进行切割，比如传入的是<code>’abc’</code>，返回的将是数组<code>[‘a’, ‘b’, ‘c’]</code>；如果传入的是一个数值类型，则将数字转为字符串然后切割成单个数字然后拼接成字符串，比如传入的是<code>123</code>，则返回的是<code>’1_2_3’</code>。你可以看到传入的参数类型不同，返回的值的类型是不同的，</p>
<p>在 TypeScript 中有函数重载的概念，但并不是定义几个同名实体函数，然后根据不同的参数个数或类型来自动调用相应的函数。TypeScript的函数重载是在类型系统层面的，是为了更好地进行类型推断。TypeScript的函数重载通过为一个函数指定多个函数类型定义，从而对函数调用的返回值进行检查。来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">function handleData(x: string): string[]; // 这个是重载的一部分，指定当参数类型为string时，返回值为string类型的元素构成的数组</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleData</span>(<span class="params">x: number</span>): <span class="title">string</span>; // 这个也是重载的一部分，指定当参数类型为<span class="title">number</span>时，返回值类型为<span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="title">function</span> <span class="title">handleData</span>(<span class="params">x: any</span>): <span class="title">any</span> </span>&#123; <span class="comment">// 这个就是重载的内容了，他是实体函数，不算做重载的部分</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">"string"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> x.split(<span class="string">""</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">      .toString()</span><br><span class="line">      .split(<span class="string">""</span>)</span><br><span class="line">      .join(<span class="string">"_"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">handleData(<span class="string">"abc"</span>).join(<span class="string">"_"</span>);</span><br><span class="line">handleData(<span class="number">123</span>).join(<span class="string">"_"</span>); <span class="comment">// error 类型"string"上不存在属性"join"</span></span><br><span class="line">handleData(<span class="literal">false</span>); <span class="comment">// error 类型"boolean"的参数不能赋给类型"number"的参数。</span></span><br></pre></td></tr></table></figure>


<p>首先我们使用function关键字定义了两个同名的函数，但不同的是，函数没有实际的函数体逻辑，而是只定义函数名、参数及参数类型以及函数的返回值类型；而第三个使用function定义的同名函数，是一个完整的实体函数，包含函数名、参数及参数类型、返回值类型和函数体；这三个定义组成了一个函数——完整的带有类型定义的函数，前两个function定义的就称为函数重载，而第三个function并不算重载；</p>
<p>然后我们来看下匹配规则，当调用这个函数并且传入参数的时候，会从上而下在函数重载里匹配和这个参数个数和类型匹配的重载。如例子中第一个调用，传入了一个字符串”abc”，它符合第一个重载，所以它的返回值应该是一个字符串组成的数组，数组是可以调用join方法的，所以这里没问题；</p>
<p>第二个调用传入的是一个数值类型的123，从上到下匹配重载是符合第二个的，返回值应该是字符串类型。但这里拿到返回值后调用了数组方法join，这肯定会报错了，因为字符串无法调用这个方法；</p>
<p>最后调用时传入了一个布尔类型值false，匹配不到重载，所以会报错；</p>
<p>最后还有一点要注意的是，这里重载只能用 function 来定义，不能使用接口、类型别名等。</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>本小节我们学习了函数类型的三种定义方式：</p>
<ul>
<li>基本方式：直接在定义函数实体语句中，指定参数和返回值类型；</li>
<li>接口形式：这种方式我们在讲接口的时候已经学习过了；</li>
<li>类型别名：这种方式是比较推荐的写法，比较简洁清晰。</li>
</ul>
<p>我们还详细学习了函数参数的三个知识点：</p>
<ul>
<li>可选参数：可选参数在JavaScript中可以实现，TypeScript中需要在该参数后面加个?，且可选参数必须位于必选参数后面；；</li>
<li>默认参数：这是在ES6标准中添加的语法，为函数参数指定默认参数，写法就是在参数名后面使用=连接默认参数</li>
<li>剩余参数：这也是在ES6中添加的语法，可以使用<code>...</code>参数名来获取剩余任意多个参数，获取的是一个数组。</li>
</ul>
<p>最后我们学习了函数重载。着重强调的是，这里的函数重载区别于其他语言中的重载，TypeScript中的重载是为了针对不同参数个数和类型，推断返回值类型。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421212332.png" alt=""></p>
<h2 id="使用泛型拯救你的any"><a href="#使用泛型拯救你的any" class="headerlink" title="使用泛型拯救你的any"></a>使用泛型拯救你的any</h2><p>在前面的小节中我们学习了any类型，当我们要表示一个值可以为任意类型的时候，则指定它的类型为any，比如下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getArray = (value: any, <span class="attr">times</span>: number = <span class="number">5</span>): any[] =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(times).fill(value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个函数接受两个参数。第一个参数为任意类型的值，第二个参数为数值类型的值，默认为 5。函数的功能是返回一个以 times 为元素个数，每个元素都是 value 的数组。这个函数我们从逻辑上可以知道，传入的 value 是什么类型，那么返回的数组的每个元素也应该是什么类型。</p>
<p>接下来我们实际用一下这个函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getArray([<span class="number">1</span>], <span class="number">2</span>).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item.length);</span><br><span class="line">&#125;);</span><br><span class="line">getArray(<span class="number">2</span>, <span class="number">3</span>).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item.length);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们调用了两次这个方法，使用 forEach 方法遍历得到的数组，在传入 forEach 的函数中获取当前遍历到的数组元素的 length 属性。第一次调用这个方法是没问题的，因为我们第一次传入的值为数组，得到的会是一个二维数组[ [1], [1] ]。每次遍历的元素为[1]，它也是数组，所以打印它的 length 属性是可以的。而我们第二次传入的是一个数字 2，生成的数组是[2, 2, 2]，访问 2 的 length 属性是没有的，所以应该报错，但是这里却不会报错，因为我们在定义getArray函数的时候，指定了返回值是any类型的元素组成的数组，所以这里遍历其返回值中每一个元素的时候，类型都是any，所以不管做任何操作都是可以的，因此，上面例子中第二次调用getArray的返回值每个元素应该是数值类型，遍历这个数组时我们获取数值类型的length属性也没报错，因为这里item的类型是any。</p>
<p>所以要解决这种情况，泛型就可以搞定，接下来我们来学习泛型。</p>
<h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>要解决上面这个场景的问题，就需要使用泛型了。泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。</p>
<p>还拿上面这个例子中的逻辑来举例，我们既要允许传入任意类型的值，又要正确指定返回值类型，就要使用泛型。我们先来看怎么改写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getArray = <span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(value: T, times: number = 5): T[] =&gt; &#123;</span></span><br><span class="line"><span class="xml">  return new Array(times).fill(value);</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>我们在定义函数之前，使用&lt;&gt;符号定义了一个泛型变量 <code>T</code>，这个 <code>T</code> 在这次函数定义中就代表某一种类型，它可以是基础类型，也可以是联合类型等高级类型。定义了泛型变量之后，你在函数中任何需要指定类型的地方使用 T 都代表这一种类型。比如当我们传入 <code>value</code> 的类型为数值类型，那么返回的数组类型<code>T[]就表示number[]</code>。现在我们再来调用一下这个 <code>getArray</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getArray&lt;number[]&gt;([<span class="number">1</span>, <span class="number">2</span>], <span class="number">3</span>).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item.length);</span><br><span class="line">&#125;);</span><br><span class="line">getArray&lt;number&gt;(<span class="number">2</span>, <span class="number">3</span>).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item.length); <span class="comment">// 类型“number”上不存在属性“length”</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们在调用<code>getArray</code>的时候，在方法名后面使用&lt;&gt;传入了我们的泛型变量 T 的类型number[]，那么在定义 <code>getArray</code>函数时使用 <code>T</code> 指定类型的地方，都会使用<code>number[]</code>指定。但是你也可以省略这个<code>&lt;number[]&gt;</code>，TypeScript 会根据你传入函数的 value 值的类型进行推断：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getArray(<span class="number">2</span>, <span class="number">3</span>).forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item.length); <span class="comment">// 类型“number”上不存在属性“length”</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="泛型变量"><a href="#泛型变量" class="headerlink" title="泛型变量"></a>泛型变量</h3><p>当我们使用泛型的时候，你必须在处理类型涉及到泛型的数据的时候，把这个数据当做任意类型来处理。这就意味着不是所有类型都能做的操作不能做，不是所有类型都能调用的方法不能调用。可能会有点绕口，我们来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getLength = <span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(param: T): number =&gt; &#123;</span></span><br><span class="line"><span class="xml">  return param.length; // error 类型“T”上不存在属性“length”</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>

<p>当我们获取一个类型为泛型的变量 param 的 length 属性值时，如果 param 的类型为数组 Array 或字符串 string 类型是没问题的，它们有 length 属性。但是如果此时传入的 param 是数值 number 类型，那这里就会有问题了。</p>
<p>这里的T并不是固定的，你可以写为<code>A</code>、<code>B</code>或者其他名字，而且还可以在一个函数中定义多个泛型变量。我们来看个复杂点的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getArray = <span class="xml"><span class="tag">&lt;<span class="name">T,</span> <span class="attr">U</span>&gt;</span>(param1: T, param2: U, times: number): [T, U][] =&gt; &#123;</span></span><br><span class="line"><span class="xml">  return new Array(times).fill([param1, param2]);</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml">getArray(1, "a", 3).forEach(item =&gt; &#123;</span></span><br><span class="line"><span class="xml">  console.log(item[0].length); // error 类型“number”上不存在属性“length”</span></span><br><span class="line"><span class="xml">  console.log(item[1].toFixed(2)); // error 属性“toFixed”在类型“string”上不存在</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure>

<p>这个例子中，我们定义了两个泛型变量T和U。第一个参数的类型为 <code>T</code>，第二个参数的类型为 <code>U</code>，最后函数返回一个二维数组，函数返回类型我们指定是一个元素类型为<code>[T, U]</code>的数组。所以当我们调用函数，最后遍历结果时，遍历到的每个元素都是一个第一个元素是数值类型、第二个元素是字符串类型的数组。</p>
<h3 id="泛型函数类型"><a href="#泛型函数类型" class="headerlink" title="泛型函数类型"></a>泛型函数类型</h3><p>我们可以定义一个泛型函数类型，还记得我们之前学习函数一节时，给一个函数定义函数类型，现在我们可以使用泛型定义函数类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/ ex1: 简单定义</span><br><span class="line"><span class="keyword">const</span> getArray: <span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(arg: T, times: number) =&gt; T[] = (arg, times) =&gt; &#123;</span></span><br><span class="line"><span class="xml">  return new Array(times).fill(arg);</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml">// ex2: 使用类型别名</span></span><br><span class="line">type GetArray = &lt;T&gt;(arg: T, times: number) =&gt; T[];</span><br><span class="line">const getArray: GetArray = &lt;T&gt;(arg: T, times: number): T[] =&gt; &#123;</span><br><span class="line">  return new Array(times).fill(arg);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>当然了，我们也可以使用接口的形式来定义泛型函数类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface GetArray &#123;</span><br><span class="line">  &lt;T&gt;(arg: T, <span class="attr">times</span>: number): T[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getArray: GetArray = <span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(arg: T, times: number): T[] =&gt; &#123;</span></span><br><span class="line"><span class="xml">  return new Array(times).fill(arg);</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>当我们使用了泛型时，就意味着这个这个类型是任意类型。但在大多数情况下，我们的逻辑是对特定类型处理的。还记得我们前面讲泛型变量时举的那个例子——当访问一个泛型类型的参数的 length 属性时，会报错”类型<code>“T”</code>上不存在属性“length””，是因为并不是所有类型都有 length 属性。</p>
<p>所以我们在这里应该对 T 有要求，那就是类型为 T 的值应该包含 length 属性。说到这个需求，你应该能想到接口的使用，我们可以使用接口定义一个对象必须有哪些属性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface ValueWithLength &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> v: ValueWithLength = &#123;&#125;; <span class="comment">// error Property 'length' is missing in type '&#123;&#125;' but required in type 'ValueWithLength'</span></span><br></pre></td></tr></table></figure>
<p>泛型约束就是使用一个类型和<code>extends</code>对泛型进行约束，之前的例子就可以改为下面这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface ValueWithLength &#123;</span><br><span class="line">  length: number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> getLength = <span class="xml"><span class="tag">&lt;<span class="name">T</span> <span class="attr">extends</span> <span class="attr">ValueWithLength</span>&gt;</span>(param: T): number =&gt; &#123;</span></span><br><span class="line"><span class="xml">  return param.length;</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml">getLength("abc"); // 3</span></span><br><span class="line"><span class="xml">getLength([1, 2, 3]); // 3</span></span><br><span class="line"><span class="xml">getLength(&#123; length: 3 &#125;); // 3</span></span><br><span class="line"><span class="xml">getLength(123); // error 类型“123”的参数不能赋给类型“ValueWithLength”的参数</span></span><br></pre></td></tr></table></figure>

<p>这个例子中，泛型变量T受到约束。它必须满足接口ValueWithLength，也就是不管它是什么类型，但必须有一个length属性，且类型为数值类型。例子中后面四次调用getLength方法，传入了不同的值，传入字符串<code>&quot;abc&quot;</code>、数组<code>[1, 2, 3]</code>和一个包含length属性的对象<code>{ length: 3 }</code>都是可以的，但是传入数值<code>123</code>不行，因为它没有length属性。</p>
<h3 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a>在泛型约束中使用类型参数</h3><p>当我们定义一个对象，想要对只能访问对象上存在的属性做要求时，该怎么办？先来看下这个需求是什么样子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getProps = <span class="function">(<span class="params">object, propName</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> object[propName];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: <span class="string">"aa"</span>, <span class="attr">b</span>: <span class="string">"bb"</span> &#125;;</span><br><span class="line">getProps(obj, <span class="string">"c"</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>当我们访问这个对象的’c’属性时，这个属性是没有的。这里我们需要用到索引类型keyof结合泛型来实现对这个问题的检查。索引类型在高级类型一节会详细讲解，这里你只要知道这个例子就可以了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> getProp = <span class="xml"><span class="tag">&lt;<span class="name">T,</span> <span class="attr">K</span> <span class="attr">extends</span> <span class="attr">keyof</span> <span class="attr">T</span>&gt;</span>(object: T, propName: K) =&gt; &#123;</span></span><br><span class="line"><span class="xml">  return object[propName];</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml">const obj = &#123; a: "aa", b: "bb" &#125;;</span></span><br><span class="line"><span class="xml">getProp(obj, "c"); // 类型“"c"”的参数不能赋给类型“"a" | "b"”的参数</span></span><br></pre></td></tr></table></figure>

<p>这里我们使用让<code>K</code>来继承索引类型<code>keyof T</code>，你可以理解为<code>keyof T</code>相当于一个由泛型变量T的属性名构成的联合类型，在这里 K 就被约束为了只能是”a”或”b”，所以当我们传入字符串”c”想要获取对象obj的属性”c”时就会报错。</p>
<h3 id="小结-5"><a href="#小结-5" class="headerlink" title="小结"></a>小结</h3><p>本小节我们学习了泛型的相关知识；学习了使用泛型来弥补使用any造成的类型信息缺失；当我们的类型是灵活任意的，又要准确使用类型信息时，就需要使用泛型来关联类型信息，其中离不开的是泛型变量；泛型变量可以是多个，且命名随意；如果需要对泛型变量的类型做进一步的限制，则需要用到我们最后讲的泛型约束；使用泛型约束通过<code>extends</code>关键字指定要符合的类型，从而满足更多场景的需求。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200421220305.png" alt=""></p>
<h2 id="TS中的类"><a href="#TS中的类" class="headerlink" title="TS中的类"></a>TS中的类</h2><p>虽然说类是 ES6 中新增的概念，但是在这里讲 TS 中的类，是因为在语法的实现上 TS 和 ES6 规范的，还是有点区别。</p>
<p>在学习本节课之前，你要确定你已经详细学习了ES6标准的类的全部知识，如果没有学习，建议你先学习下阮一峰的<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">《ECMAScript 6 入门》</a>，学习完后再来学习本节课你会发现，一些同样的功能写法上却不同。</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>我们先来看下在 TS 中定义类的一个简单例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  x: number;</span><br><span class="line">  y: number;</span><br><span class="line">  <span class="keyword">constructor</span>(x: number, y: number) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  getPosition() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> point = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>我们首先在定义类的代码块的顶部定义两个实例属性，并且指定类型为 number 类型。构造函数 constructor 需要传入两个参数，都是 number 类型，并且把这两个参数分别赋值给两个实例属性。最后定义了一个定义在类的原型对象上的方法 getPosition。</p>
<p>同样你也可以使用继承来复用一些特性：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些和 ES6 标准中的类没什么区别，如果大家不了解ES6标准中类关于这块的内容，建议大家先去学习ES6类的知识。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>在 ES6 标准类的定义中，默认情况下，定义在实例的属性和方法会在创建实例后添加到实例上；而如果是定义在类里没有定义在 this 上的方法，实例可以继承这个方法；而如果使用 static 修饰符定义的属性和方法，是静态属性和静态方法，实例是没法访问和继承到的；我们还通过一些手段，实现了私有方法，但是私有属性的实现还不好实现。</p>
<p>接下来我们来看下 TS 中的公共、私有和受保护的修饰符：</p>
<h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><p><code>public</code>表示公共的，用来指定在创建实例后可以通过实例访问的，也就是类定义的外部可以访问的属性和方法。默认是 <code>public</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  public x: number;</span><br><span class="line">  public y: number;</span><br><span class="line">  <span class="keyword">constructor</span>(x: number, y: number) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">  &#125;</span><br><span class="line">  public getPosition() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`(<span class="subst">$&#123;<span class="keyword">this</span>.x&#125;</span>, <span class="subst">$&#123;<span class="keyword">this</span>.y&#125;</span>)`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p><code>private</code>修饰符表示私有的，它修饰的属性在类的定义外面是没法访问的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  private age: number;</span><br><span class="line">  <span class="keyword">constructor</span>(age: number) &#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Parent(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123; age: 18 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(p.age); <span class="comment">// error 属性“age”为私有属性，只能在类“Parent”中访问</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.age); <span class="comment">// error 类型“typeof ParentA”上不存在属性“age”</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age: number) &#123;</span><br><span class="line">    <span class="keyword">super</span>(age);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.age); <span class="comment">// error 通过 "super" 关键字只能访问基类的公共方法和受保护方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里你可以看到，age 属性使用 private 修饰符修饰，说明他是私有属性，我们打印创建的实例对象 p，发现他是有属性 age 的，但是当试图访问 p 的 age 属性时，编译器会报错，告诉我们私有属性只能在类 Parent 中访问。</p>
<p>这里我们需要特别说下 super.age 这里的报错，我们在之前学习 ES6 的类的时候，讲过在不同类型的方法里 super 作为对象代表着不同的含义，这里在 constructor 中访问 super，这的 super 相当于父类本身，这里我们看到使用 private 修饰的属性，在子类中是没法访问的。</p>
<h4 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h4><p><code>protected</code>修饰符是受保护修饰符，和<code>private</code>有些相似，但有一点不同，<code>protected</code>修饰的成员在继承该类的子类中可以访问，我们再来看下上面那个例子，把父类 Parent 的 age 属性的修饰符 private 替换为 protected：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  protected age: number;</span><br><span class="line">  <span class="keyword">constructor</span>(age: number) &#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  protected getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Parent(<span class="number">18</span>);</span><br><span class="line"><span class="built_in">console</span>.log(p.age); <span class="comment">// error 属性“age”为私有属性，只能在类“ParentA”中访问</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.age); <span class="comment">// error 类型“typeof ParentA”上不存在属性“age”</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age: number) &#123;</span><br><span class="line">    <span class="keyword">super</span>(age);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.age); <span class="comment">// undefined</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">super</span>.getAge());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Child(<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<p>protected还能用来修饰 constructor 构造函数，加了protected修饰符之后，这个类就不能再用来创建实例，只能被子类继承，这个需求我们在讲 ES6 的类的时候讲过，需要用new.target来自行判断，而 TS 则只需用 protected 修饰符即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  protected <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Parent(); <span class="comment">// error 类“Parent”的构造函数是受保护的，仅可在类声明中访问</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Child();</span><br></pre></td></tr></table></figure>

<h4 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h4><p>在类里可以使用<code>readonly</code>关键字将属性设置为只读。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">  readonly name: string;</span><br><span class="line">  <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> UserInfo(<span class="string">"Lison"</span>);</span><br><span class="line">user.name = <span class="string">"haha"</span>; <span class="comment">// error Cannot assign to 'name' because it is a read-only property</span></span><br></pre></td></tr></table></figure>
<p>设置为只读的属性，实例只能读取这个属性值，但不能修改。</p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p>和 ES6 的类一样，在 TS 中一样使用static关键字来指定属性或方法是静态的，实例将不会添加这个静态属性，也不会继承这个静态方法，你可以使用修饰符和 static 关键字来指定一个属性或方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  public <span class="keyword">static</span> age: number = <span class="number">18</span>;</span><br><span class="line">  public <span class="keyword">static</span> getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> Parent.age;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="built_in">console</span>.log(p.age); <span class="comment">// error Property 'age' is a static member of type 'Parent'</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.age); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure>
<p>如果使用了 private 修饰道理和之前的一样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  public <span class="keyword">static</span> getAge() &#123;</span><br><span class="line">    <span class="keyword">return</span> Parent.age;</span><br><span class="line">  &#125;</span><br><span class="line">  private <span class="keyword">static</span> age: number = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Parent();</span><br><span class="line"><span class="built_in">console</span>.log(p.age); <span class="comment">// error Property 'age' is a static member of type 'Parent'</span></span><br><span class="line"><span class="built_in">console</span>.log(Parent.age); <span class="comment">// error 属性“age”为私有属性，只能在类“Parent”中访问。</span></span><br></pre></td></tr></table></figure>


<h3 id="参数属性"><a href="#参数属性" class="headerlink" title="参数属性"></a>参数属性</h3><p>之前的例子中，我们都是在类的定义的顶部初始化实例属性，在 constructor 里接收参数然后对实力属性进行赋值，我们可以使用参数属性来简化这个过程。参数属性简单来说就是在 constructor 构造函数的参数前面加上访问限定符，也就是前面讲的 public、private、protected 和 readonly 中的任意一个，我们来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name: string) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> A(<span class="string">"aaa"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.name); <span class="comment">// error 类型“A”上不存在属性“name”</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(public name: string) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">new</span> B(<span class="string">"bbb"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(b.name); <span class="comment">// "bbb"</span></span><br></pre></td></tr></table></figure>
<p>可以看到，在定义类 B 时，构造函数有一个参数 name，这个 name 使用访问修饰符 public 修饰，此时即为 name 声明了参数属性，也就无需再显示地在类中初始化这个属性了。</p>
<h3 id="可选类属性"><a href="#可选类属性" class="headerlink" title="可选类属性"></a>可选类属性</h3><p>TS 在 2.0 版本，支持可选类属性，也是使用?符号来标记，来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age?: number;</span><br><span class="line">  <span class="keyword">constructor</span>(name: string, age?: number, public sex?: string) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> info1 = <span class="keyword">new</span> Info(<span class="string">"lison"</span>);</span><br><span class="line"><span class="keyword">const</span> info2 = <span class="keyword">new</span> Info(<span class="string">"lison"</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">const</span> info3 = <span class="keyword">new</span> Info(<span class="string">"lison"</span>, <span class="number">18</span>, <span class="string">"man"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>这个也就 ES6 标准中的存值函数和取值函数，也就是在设置属性值的时候调用的函数，和在访问属性值的时候调用的函数，用法和写法和 ES6 的没有区别：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span>&#123;</span><br><span class="line">  private _fullName: string;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">  <span class="keyword">get</span> fullName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._fullName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> fullName(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`setter: <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>._fullName = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> UserInfo();</span><br><span class="line">user.fullName = <span class="string">"Lison Li"</span>; <span class="comment">// "setter: Lison Li"</span></span><br><span class="line"><span class="built_in">console</span>.log(user.fullName); <span class="comment">// "Lison Li"</span></span><br></pre></td></tr></table></figure>

<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>抽象类一般用来被其他类继承，而不直接用它创建实例。抽象类和类内部定义抽象方法，使用<code>abstract</code>关键字，我们先来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(public name: string) &#123;&#125;</span><br><span class="line">  abstract printName(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  printName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> Man(); <span class="comment">// error 应有 1 个参数，但获得 0 个</span></span><br><span class="line"><span class="keyword">const</span> man = <span class="keyword">new</span> Man(<span class="string">"lison"</span>);</span><br><span class="line">man.printName(); <span class="comment">// 'lison'</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> People(<span class="string">"lison"</span>); <span class="comment">// error 无法创建抽象类的实例</span></span><br></pre></td></tr></table></figure>

<p>上面例子中我们定义了一个抽象类 People，在抽象类里我们定义 constructor 方法必须传入一个字符串类型参数，并把这个 name 参数值绑定在创建的实例上；使用abstract关键字定义一个抽象方法 printName，这个定义可以指定参数，指定参数类型，指定返回类型。当我们直接使用抽象类 People 实例化的时候，就会报错，我们只能创建一个继承抽象类的子类，使用子类来实例化。</p>
<p>我们再来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(public name: string) &#123;&#125;</span><br><span class="line">  abstract printName(): <span class="keyword">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="comment">// error 非抽象类“Man”不会实现继承自“People”类的抽象成员"printName"</span></span><br><span class="line">  <span class="keyword">constructor</span>(name: string) &#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> Man(<span class="string">"lison"</span>);</span><br><span class="line">m.printName(); <span class="comment">// error m.printName is not a function</span></span><br></pre></td></tr></table></figure>

<p>通过上面的例子我们可以看到，在抽象类里定义的抽象方法，在子类中是不会继承的，所以在子类中必须实现该方法的定义。</p>
<p>2.0 版本开始，<code>abstract</code>关键字不仅可以标记类和类里面的方法，还可以标记类中定义的属性和存取器：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  abstract _name: string;</span><br><span class="line">  abstract <span class="keyword">get</span> insideName(): string;</span><br><span class="line">  abstract <span class="keyword">set</span> insideName(value: string);</span><br><span class="line">&#125;</span><br><span class="line">class Pp extends People &#123;</span><br><span class="line">  _name: string;</span><br><span class="line">  insideName: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>但是要记住，抽象方法和抽象存取器都不能包含实际的代码块。</p>
</blockquote>
<h3 id="实例类型"><a href="#实例类型" class="headerlink" title="实例类型"></a>实例类型</h3><p>当我们定义一个类，并创建实例后，这个实例的类型就是创建他的类：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(public name: string) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p: People = <span class="keyword">new</span> People(<span class="string">"lison"</span>);</span><br></pre></td></tr></table></figure>

<p>当然了，创建实例的时候这指定 p 的类型为 People 并不是必须的，TS 会推断出他的类型。虽然指定了类型，但是当我们再定义一个和 People 类同样实现的类 Animal，并且创建实例赋值给 p 的时候，是没有问题的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(public name: string) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Animal(<span class="string">"lark"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="类类型接口"><a href="#类类型接口" class="headerlink" title="类类型接口"></a>类类型接口</h3><p>使用接口可以强制一个类的定义必须包含某些内容，先来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface FoodInterface &#123;</span><br><span class="line">  type: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoodClass</span> <span class="title">implements</span> <span class="title">FoodInterface</span> </span>&#123;</span><br><span class="line">  <span class="comment">// error Property 'type' is missing in type 'FoodClass' but required in type 'FoodInterface'</span></span><br><span class="line">  <span class="keyword">static</span> type: string;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面接口 <code>FoodInterface</code> 要求使用该接口的值必须有一个 type 属性，定义的类 FoodClass 要使用接口，需要使用关键字<code>implements</code>。<code>implements</code>关键字用来指定一个类要继承的接口，如果是接口和接口、类和类直接的继承，使用<code>extends</code>，如果是类继承接口，则用<code>implements</code>。</p>
<p>有一点需要注意，接口检测的是使用该接口定义的类创建的实例，所以上面例子中虽然定义了静态属性 type，但静态属性不会添加到实例上，所以还是报错，所以我们可以这样改：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface FoodInterface &#123;</span><br><span class="line">  type: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FoodClass</span> <span class="title">implements</span> <span class="title">FoodInterface</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(public type: string) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h3><p>接口可以继承一个类，当接口继承了该类后，会继承类的成员，但是不包括其实现，也就是只继承成员以及成员类型。接口还会继承类的<code>private</code>和<code>protected</code>修饰的成员，当接口继承的这个类中包含这两个修饰符修饰的成员时，这个接口只可被这个类或他的子类实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  protected name: string;</span><br><span class="line">&#125;</span><br><span class="line">interface I extends A &#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">implements</span> <span class="title">I</span> </span>&#123;&#125; <span class="comment">// error Property 'name' is missing in type 'B' but required in type 'I'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="title">implements</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">  <span class="comment">// error 属性“name”受保护，但类型“C”并不是从“A”派生的类</span></span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">A</span> <span class="title">implements</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">  getName() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在泛型中使用类类型"><a href="#在泛型中使用类类型" class="headerlink" title="在泛型中使用类类型"></a>在泛型中使用类类型</h3><p>这里我们先来看个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> create = <span class="xml"><span class="tag">&lt;<span class="name">T</span>&gt;</span>(c: &#123; new (): T &#125;): T =&gt; &#123;</span></span><br><span class="line"><span class="xml">  return new c();</span></span><br><span class="line"><span class="xml">&#125;;</span></span><br><span class="line"><span class="xml">class Info &#123;</span></span><br><span class="line"><span class="xml">  age: number;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">create(Info).age;</span></span><br><span class="line"><span class="xml">create(Info).name; // error 类型“Info”上不存在属性“name”</span></span><br></pre></td></tr></table></figure>
<p>在这个例子里，我们创建了一个一个 create 函数，传入的参数是一个类，返回的是一个类创建的实例，这里有几个点要讲：</p>
<ul>
<li>参数 c 的类型定义中，new()代表调用类的构造函数，他的类型也就是类创建实例后的实例的类型。</li>
<li>return new c()这里使用传进来的类 c 创建一个实例并返回，返回的实例类型也就是函数的返回值类型。</li>
</ul>
<p>所以通过这个定义，TS 就知道，调用 create 函数，传入的和返回的值都应该是同一个类类型。</p>
<h2 id="类型推论，看TS有多懂你"><a href="#类型推论，看TS有多懂你" class="headerlink" title="类型推论，看TS有多懂你"></a>类型推论，看TS有多懂你</h2><p>我们讲过，在一些定义中如果你没有明确指定类型，编译器会自动推断出适合的类型；比如下面的这个简单例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">"lison"</span>;</span><br><span class="line">name = <span class="number">123</span>; <span class="comment">// error 不能将类型“123”分配给类型“string”</span></span><br></pre></td></tr></table></figure>
<p>我们看到，在定义变量 name 的时候我们并没有指定 name 的类型，而是直接给它赋一个字符串。当我们再给 name 赋一个数值的时候，就会报错。在这里，TypeScript 根据我们赋给 name 的值的类型，推断出我们的 name 的类型，这里是 string 类型，当我们再给 string 类型的 name 赋其他类型值的时候就会报错。</p>
<p>这个是最基本的类型推论，根据右侧的值推断左侧变量的类型，接下来我们看两个更复杂的推论。</p>
<h3 id="多类型联合"><a href="#多类型联合" class="headerlink" title="多类型联合"></a>多类型联合</h3><p>当我们定义一个数组或元组这种包含多个元素的值的时候，多个元素可以有不同的类型，这种时候 TypeScript 会将多个类型合并起来，组成一个联合类型，来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="string">"a"</span>];</span><br><span class="line">arr = [<span class="string">"b"</span>, <span class="number">2</span>, <span class="literal">false</span>]; <span class="comment">// error 不能将类型“false”分配给类型“string | number”</span></span><br></pre></td></tr></table></figure>

<h3 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h3><p>我们上面讲的两个例子都是根据=符号右边值的类型，推断左侧值的类型。现在要讲的上下文类型则相反，它是根据左侧的类型推断右侧的一些类型，先来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onmousedown = <span class="function"><span class="keyword">function</span>(<span class="params">mouseEvent</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mouseEvent.a); <span class="comment">// error 类型“MouseEvent”上不存在属性“a”</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看到，表达式左侧是 window.onmousedown(鼠标按下时发生事件)，因此 TypeScript 会推断赋值表达式右侧函数的参数是事件对象，因为左侧是 mousedown 事件，所以 TypeScript 推断 mouseEvent 的类型是 MouseEvent。在回调函数中使用 mouseEvent 的时候，你可以访问鼠标事件对象的所有属性和方法，当访问不存在属性的时候，就会报错。</p>
<p>在我们日常开发中，必写的类型还是要明确指定的，这样我们才能更准确地得到类型信息和开发辅助。</p>
<p><img src="https://raw.githubusercontent.com/RocWangPeng/king-static/master/20200422104829.png" alt=""></p>
<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>我们可以把单例类型、联合类型、类型保护和类型别名这几种类型进行合并，来创建一个叫做可辨识联合的高级类型，它也可称作标签联合或代数数据类型。</p>
<p>可辨识联合要求具有两个要素：</p>
<ul>
<li>具有普通的单例类型属性（这个要作为辨识的特征，也是重要因素）。</li>
<li>一个类型别名，包含了那些类型的联合（即把几个类型封装为联合类型，并起一个别名）。</li>
</ul>
<p>来看例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">interface Square &#123;</span><br><span class="line">  kind: <span class="string">"square"</span>; <span class="comment">// 这个就是具有辨识性的属性</span></span><br><span class="line">  size: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Rectangle &#123;</span><br><span class="line">  kind: <span class="string">"rectangle"</span>; <span class="comment">// 这个就是具有辨识性的属性</span></span><br><span class="line">  height: number;</span><br><span class="line">  width: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Circle &#123;</span><br><span class="line">  kind: <span class="string">"circle"</span>; <span class="comment">// 这个就是具有辨识性的属性</span></span><br><span class="line">  radius: number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertNever</span>(<span class="params">value: never</span>): <span class="title">never</span> </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Unexpected object: "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Shape = Square | Rectangle | Circle; <span class="comment">// 这里使用三个接口组成一个联合类型，并赋给一个别名Shape，组成了一个可辨识联合。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArea</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"square"</span>:</span><br><span class="line">      <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"rectangle"</span>:</span><br><span class="line">      <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"circle"</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> assertNever(s); </span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子中，我们的 Shape 即可辨识联合，它是三个接口的联合，而这三个接口都有一个 kind 属性，且每个接口的 kind 属性值都不相同，能够起到标识作用。</p>
<blockquote>
<p>这里有个 ES7 的新特性：** 运算符，两个<em>符号组成的这个运算符就是求幂运算符，2 *</em> 3 ==&gt; 8</p>
</blockquote>
<h2 id="使用模块封装代码"><a href="#使用模块封装代码" class="headerlink" title="使用模块封装代码"></a>使用模块封装代码</h2><p>TypeScript 在 1.5 版本之前，有内部模块和外部模块的概念，从 1.5 版本开始，内部模块改称作命名空间（我们下个小节会讲），外部模块改称为模块。如果你对模块的知识一无所知，建议你先重点学习一下 CommonJS 模块系统和 ES6模块系统，TypeScript 中的模块系统是遵循 ES6 标准的，所以你需要重点学习 ES6 标准中的模块知识，这里推荐大家几个链接，大家可以在这里去学习一下：</p>
<ul>
<li><a href="http://www.mamicode.com/info-detail-1935796.html" target="_blank" rel="noopener">CommonJS/AMD/CMD/ES6规范</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">ECMAScript6入门 - Module 的语法</a></li>
</ul>
<p>TypeScript 和 ES6 保持一致，包含顶级 import 或 export 的文件都被当成一个模块，则里面定义的内容仅模块内可见，而不是全局可见。TypeScript 的模块除了遵循 ES6 标准的模块语法外，还有一些特定语法，用于类型系统兼容多个模块格式，下面我们来开始学习 TypeScript 模块。</p>
<h3 id="export"><a href="#export" class="headerlink" title="export"></a>export</h3><p>TypeScript 中，仍然使用 export 来导出声明，而且能够导出的不仅有变量、函数、类，还包括 TypeScript 特有的类型别名和接口。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// funcInterface.ts</span></span><br><span class="line"><span class="keyword">export</span> interface Func &#123;</span><br><span class="line">  (arg: number): string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; B &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; B <span class="keyword">as</span> ClassB &#125;;</span><br></pre></td></tr></table></figure>

<p>上面例子中，你可以使用 <code>export</code>直接导出一个声明，也可以先声明一个类或者其它内容，然后使用 <code>export {}</code>的形式导出，也可以使用 <code>as</code> 来为导出的接口换个名字再导出一次。</p>
<h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>接下来我们来看导出的模块怎么引入，依然是使用 import：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">"./moduleB"</span>;</span><br><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> info <span class="keyword">from</span> <span class="string">"./moduleB"</span>;</span><br><span class="line"><span class="comment">//main.ts</span></span><br><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> nameProp &#125; <span class="keyword">from</span> <span class="string">"./moduleB"</span>;</span><br></pre></td></tr></table></figure>

<p>同样，可以使用 import 直接接模块名或文件路径，进行具有副作用的导入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"./set-title.ts"</span>;</span><br></pre></td></tr></table></figure>

<h3 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h3><p>同样在 TypeScript 中使用 export default 默认导出，这个和 ES6 一样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// moduleB.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="string">"lison"</span>;</span><br><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> name <span class="keyword">from</span> <span class="string">"./moduleB.ts"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 'lison'</span></span><br></pre></td></tr></table></figure>

<h3 id="export-和-import-require"><a href="#export-和-import-require" class="headerlink" title="export = 和 import = require()"></a>export = 和 import = require()</h3><p>TypeScript可以将代码编译为CommonJS、AMD或其它模块系统代码，同时会生成对应的声明文件。我们知道CommonJS和AMD两种模块系统语法是不兼容的，所以TypeScript为了兼容这两种语法，使得我们编译后的声明文件同时支持这两种模块系统，增加了<code>export =</code>和<code>import xx = require()</code>两个语句。<br>当我们想要导出一个模块时，可以使用<code>export =</code>来导出：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// moduleC.ts</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> = C;</span><br></pre></td></tr></table></figure>

<p>然后使用这个形式导出的模块，必须使用import xx = require()来引入：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.ts</span></span><br><span class="line"><span class="keyword">import</span> ClassC = <span class="built_in">require</span>(<span class="string">"./moduleC"</span>);</span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> ClassC();</span><br></pre></td></tr></table></figure>

<p>如果你的模块不需要同时支持这两种模块系统，可以不使用<code>export =</code>来导出内容。</p>
<h2 id="使用命名空间封装代码"><a href="#使用命名空间封装代码" class="headerlink" title="使用命名空间封装代码"></a>使用命名空间封装代码</h2><p>命名空间在 1.5 之前的版本中，是叫做“内部模块”。在 1.5 版本之前，ES6 模块还没正式成为标准，所以 TS 对于模块的实现，是将模块分为“内部模块”和“外部模块”两种。内部模块使用<code>module</code>来定义，而外部模块使用<code>export</code>来指定哪个内容对外部可见。</p>
<p>1.5 版本开始，使用“命名空间”代替“内部模块”说法，并且使用 <code>namespace</code>代替原有的 <code>module</code>关键字，而“外部 模块”则改为“模块”。</p>
<p>命名空间的作用与使用场景和模块还是有区别的：</p>
<ul>
<li>当我们是在程序内部用于防止全局污染，想把相关的内容都放在一起的时候，使用命名空间；</li>
<li>当我们封装了一个工具或者库，要适用于模块系统中引入使用时，适合使用模块。</li>
</ul>
<h3 id="定义和使用"><a href="#定义和使用" class="headerlink" title="定义和使用"></a>定义和使用</h3><p>命名空间的定义实际相当于定义了一个大的对象，里面可以定义变量、接口、类、方法等等，但是如果不使用<code>export</code> 关键字指定此内容要对外可见的话，外部是没法访问到的。来看下怎么写，我们想要把所有涉及到内容验证的方法都放到一起，文件名叫 validation.ts：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">namespace Validation &#123;</span><br><span class="line">  <span class="keyword">const</span> isLetterReg = <span class="regexp">/^[A-Za-z]+$/</span>; <span class="comment">// 这里定义一个正则</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> isNumberReg = <span class="regexp">/^[0-9]+$/</span>; <span class="comment">// 这里再定义一个正则，与isLetterReg的区别在于他使用export导出了</span></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> checkLetter = <span class="function">(<span class="params">text: any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isLetterReg.test(text);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们创建了一个命名空间叫做 Validation，它里面定义了三个内容，两个正则表达式，但是区别在于 isLetterReg 没有使用 export 修饰，而 isNumberReg 使用了 export 修饰。最后一个函数，也是用了 export 修饰。</p>
<p>这里要说明一点的是，命名空间在引入的时候，如果是使用 tsc 命令行编译文件，比如是在index.ts文件使用这个命名空间，先直接像下面这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// &lt;reference path="validation.ts"/&gt;</span></span><br><span class="line"><span class="keyword">let</span> isLetter = Validation.checkLetter(<span class="string">"sdfsd"</span>);</span><br><span class="line"><span class="keyword">const</span> reg = Validation.isNumberReg;</span><br><span class="line"><span class="built_in">console</span>.log(isLetter);</span><br><span class="line"><span class="built_in">console</span>.log(reg);</span><br></pre></td></tr></table></figure>

<p>来解释下，命名空间如果不是使用 webpack 等工具编译，而是使用 tsc 编译，那只需要在使用外部命名空间的地方使用<code>/// &lt;reference path=“namespace.ts”/&gt;</code>来引入，注意三斜线 <code>”///“</code> 开头，然后在 path 属性指定相对于当前文件，这个命名空间文件的路径。然后编译时，需要指定一个参数outFile，这个参数来制定输出的文件名：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">tsc --outFile src/index.js src/index.ts</span><br></pre></td></tr></table></figure>

<p><code>–outFile</code> 用来指定输出的文件路径和文件名，最后指定要编译的文件。还有一点要注意，使用 <code>outFile</code> 只支持amd和system两种模块标准，所以需要在<code>tsconfig.json</code>里，设置 <code>module</code> 编译选项。</p>
<p>来看下编译后的文件 index.js：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Validation;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">Validation</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> isLetterReg = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line">  Validation.isNumberReg = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line">  Validation.checkLetter = <span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isLetterReg.test(text);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)(Validation || (Validation = &#123;&#125;));</span><br><span class="line"><span class="comment">/// &lt;reference path="namespace.ts"/&gt;</span></span><br><span class="line"><span class="keyword">var</span> isLetter = Validation.checkLetter(<span class="string">"sdfsd"</span>);</span><br><span class="line"><span class="keyword">var</span> reg = Validation.isNumberReg;</span><br><span class="line"><span class="built_in">console</span>.log(isLetter);</span><br><span class="line"><span class="built_in">console</span>.log(reg);</span><br></pre></td></tr></table></figure>

<p>可以看到，编译后的 JS 文件将命名空间定义的文件 <code>Validation.ts</code> 文件的内容和 index.ts 的内容合并到了最后输出的文件。</p>
<p>如果我们要在 webpack 等工具中开发项目，并时时运行，如果只通过<code>/// &lt;reference path=“Validation.ts”/&gt;</code>来引入命名空间，你会发现运行起来之后，浏览器控制台会报 Validation is not defined 的错误。所以如果是要在项目中时时使用，需要使用 <code>export</code> 将命名空间导出，其实就是作为模块导出，然后在 index.ts 中引入，先来看 Validation.ts 文件：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> namespace Validation &#123;</span><br><span class="line">  <span class="keyword">const</span> isLetterReg = <span class="regexp">/^[A-Za-z]+$/</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> isNumberReg = <span class="regexp">/^[0-9]+$/</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">const</span> checkLetter = <span class="function">(<span class="params">text: any</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isLetterReg.test(text);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 index.ts 文件中引入并使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Validation &#125; <span class="keyword">from</span> <span class="string">"./Validation.ts"</span>;</span><br><span class="line"><span class="keyword">let</span> isLetter = Validation.checkLetter(<span class="string">"sdfsd"</span>);</span><br><span class="line"><span class="keyword">const</span> reg = Validation.isNumberReg;</span><br><span class="line"><span class="built_in">console</span>.log(isLetter); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(reg); <span class="comment">// /^[0-9]+$/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里要提醒大家的是，命名空间本来就是防止变量污染，但是模块也能起到这个作用，而且使用模块还可以自己定义引入之后的名字。所以，并不建议导出一个命名空间，这种情况你应该是用模块。</p>
</blockquote>
<h2 id="逐条来看tsconfig-json配置"><a href="#逐条来看tsconfig-json配置" class="headerlink" title="逐条来看tsconfig.json配置"></a>逐条来看tsconfig.json配置</h2><p><code>tsconfig.json</code> 是放在项目根目录，用来配置一些编译选项等。当我们使用 tsc 命令编译项目，且没有指定输入文件时，编译器就会去查找 <code>tsconfig.json</code> 文件。如果在当前目录没找到，就会逐级向父文件夹查找。我们也可以通过在 <code>tsc</code> 命令中加上<code>–project</code> 参数，来指定一个包含 <code>tsconfig.json</code> 文件的目录。如果命令行上指定了输入文件时，<code>tsconfig.json</code> 的配置会被忽略。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"># 直接在项目根目录下执行tsc命令，会自动根据tsconfig.json配置项编译</span><br><span class="line">tsc</span><br><span class="line"># 指定要编译的项目，即tsconfig.json所在文件目录</span><br><span class="line">tsc --project ./dir/project</span><br><span class="line"># 指定要编译的文件，忽略tsconfig.json文件配置</span><br><span class="line">tsc ./src/main.ts</span><br></pre></td></tr></table></figure>
<p>接下来我们看一下 tsconfig.json 里都有哪些可配置项。tsconfig.json 文件里有几个主要的配置项：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"compileOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"files"</span>: [],</span><br><span class="line">  <span class="string">"include"</span>: [],</span><br><span class="line">  <span class="string">"exclude"</span>: [],</span><br><span class="line">  <span class="string">"extends"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="string">"compilerOptions"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们来逐个学习它们的作用，以及可配置的值：</p>
<h3 id="compileOnSave"><a href="#compileOnSave" class="headerlink" title="compileOnSave"></a>compileOnSave</h3><p>compileOnSave 的值是 true 或 false。如果设为 true，在我们编辑了项目中文件保存的时候，编辑器会根据 tsconfig.json 的配置重新生成文件，不过这个要编辑器支持。</p>
<h3 id="files"><a href="#files" class="headerlink" title="files"></a>files</h3><p>files 可以配置一个数组列表，里面包含指定文件的相对或绝对路径。编译器在编译的时候只会编译包含在 <code>files</code>中列出的文件。如果不指定，则取决于有没有设置 <code>include</code> 选项；如果没有 <code>include</code> 选项，则默认会编译根目录以及所有子目录中的文件。这里列出的路径必须是指定文件，而不是某个文件夹，而且不能使用<code>*、?、**/</code>等通配符。</p>
<h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><p>include 也可以指定要编译的路径列表，但和 files 的区别在于，这里的路径可以是文件夹，也可以是文件，可以使用相对和绝对路径，而且可以使用通配符。比如<code>&quot;./src&quot;</code>即表示要编译 src 文件夹下的所有文件以及子文件夹的文件。</p>
<h3 id="exclude"><a href="#exclude" class="headerlink" title="exclude"></a>exclude</h3><p>exclude 表示要排除的、不编译的文件，它也可以指定一个列表，规则和 include 一样，可以是文件可以是文件夹，可以是相对路径或绝对路径，可以使用通配符。</p>
<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><p>extends 可以通过指定一个其它的 tsconfig.json 文件路径，来继承这个配置文件里的配置，继承来的文件配置会覆盖当前文件定义的配置。TS 在 3.2 版本开始，支持继承一个来自 Node.js 包的 tsconfig.json 配置文件。</p>
<h3 id="compilerOptions"><a href="#compilerOptions" class="headerlink" title="compilerOptions"></a>compilerOptions</h3><p>最后要讲的这个 compilerOptions 是重点了，它用来设置编译选项。因为它包含很多的可配置项，下面我们来看下 compilerOptions 里的所有可配项：</p>
<p>我们先来看第一类，一些比较基本的配置：</p>
<h4 id="target"><a href="#target" class="headerlink" title="target"></a>target</h4><p>target 用于指定编译之后的版本目标，可选值有：<code>ES3(默认值)、ES5、ES2015、ES2016、ES2017、ESNEXT</code>。如果不配置 target 项，默认是讲代码转译为 ES3 的版本，如果设为 ESNEXT，则为最新 ES 规范版本。</p>
<h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><p>module 用来指定要使用的模块标准，可选值有<code>commonjs、amd、system、umd、es2015(或写 es6)</code>。如果不设置 module 选项，则如果 target 设为 <code>ES6</code>，那么 module 默认值为 <code>ES6</code>，否则是 <code>commonjs</code>。</p>
<h4 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h4><p>lib 用于指定要包含在编译中的库文件。如果你要使用一些 ES6 的新语法，你需要引入 ES6 这个库，或者也可以写 ES2015。如果没有指定 lib 配置，默认会加载一些库，而加载什么库是受 target 影响的。如果 target 为 ES5，默认包含的库有DOM、ES5和ScriptHost；如果 target 是 ES6，默认引入的库有DOM、ES6、DOM.Iterable和ScriptHost。</p>
<h4 id="allowJs"><a href="#allowJs" class="headerlink" title="allowJs"></a>allowJs</h4><p>allowJs 设置的值为 true 或 false，用来指定是否允许编译 JS 文件，默认是 false，即不编译 JS 文件。</p>
<h4 id="checkJs"><a href="#checkJs" class="headerlink" title="checkJs"></a>checkJs</h4><p>checkJs 的值为 true 或 false，用来指定是否检查和报告 JS 文件中的错误，默认是 false。</p>
<h4 id="declaration"><a href="#declaration" class="headerlink" title="declaration"></a>declaration</h4><p> declaration 的值为 true 或 false，用来指定是否在编译的时候生成响应的”.d.ts”声明文件。如果设为 true，编译每个 ts 文件之后会生成一个 js 文件和一个声明文件。但是 declaration 和 allowJs 不能同时设为 true。</p>
<h4 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h4><p>sourceMap 的值为 true 或 false，用来指定编译时是否生成.map 文件。</p>
<h4 id="outFile"><a href="#outFile" class="headerlink" title="outFile"></a>outFile</h4><p>outFile 用于指定将输出文件合并为一个文件，它的值为一个文件路径名，比如设置为<code>&quot;./dist/main.js&quot;</code>，则输出的文件为一个 main.js 文件。但是要注意，只有设置 module 的值为 amd 和 system 模块时才支持这个配置。</p>
<h4 id="outDir"><a href="#outDir" class="headerlink" title="outDir"></a>outDir</h4><p>outDir 用来指定输出文件夹，值为一个文件夹路径字符串，输出的文件都将放置在这个文件夹。</p>
<h4 id="rootDir"><a href="#rootDir" class="headerlink" title="rootDir"></a>rootDir</h4><p>用来指定编译文件的根目录，编译器会在根目录查找入口文件，如果编译器发现 1 以 rootDir 的值作为根目录查找入口文件并不会把所有文件加载进去的话会报错，但是不会停止编译。</p>
<h4 id="removeComments"><a href="#removeComments" class="headerlink" title="removeComments"></a>removeComments</h4><p>removeComments 值为 true 或 false，用于指定是否将编译后的文件中的注释删掉，设为 true 的话即删掉注释，默认为 false。</p>
<h4 id="isolatedModules"><a href="#isolatedModules" class="headerlink" title="isolatedModules"></a>isolatedModules</h4><p>isolatedModules 的值为 true 或 false，指定是否将每个文件作为单独的模块，默认为 true，它不可以和 declaration 同时设定。</p>
<h4 id="alwaysStrict"><a href="#alwaysStrict" class="headerlink" title="alwaysStrict"></a>alwaysStrict</h4><p>alwaysStrict 的值为 true 或 false，指定始终以严格模式检查每个模块，并且在编译之后的 JS 文件中加入<code>&quot;use strict&quot;</code>字符串，用来告诉浏览器该 JS 为严格模式。</p>
<h4 id="strictNullChecks"><a href="#strictNullChecks" class="headerlink" title="strictNullChecks"></a>strictNullChecks</h4><p>strictNullChecks 的值为 true 或 false，当设为 true 时，null 和 undefined 值不能赋值给非这两种类型的值，别的类型的值也不能赋给它们。 除了 any 类型，还有个例外就是 undefined 可以赋值给 void 类型。</p>
<h4 id="strict"><a href="#strict" class="headerlink" title="strict"></a>strict</h4><p>strict 的值为 true 或 false，用于指定是否启动所有类型检查，如果设为 true 则会同时开启前面这几个严格类型检查，默认为 false。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title>从零搭建docker+jenkins+node.js自动化部署环境</title>
    <url>/2020/07/29/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAdocker-jenkins-node-js%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="1、docker部分"><a href="#1、docker部分" class="headerlink" title="1、docker部分"></a>1、docker部分</h2><h3 id="1-1、docker简介"><a href="#1-1、docker简介" class="headerlink" title="1.1、docker简介"></a>1.1、docker简介</h3><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口</p>
<h3 id="1-2、docker架构"><a href="#1-2、docker架构" class="headerlink" title="1.2、docker架构"></a>1.2、docker架构</h3><p>简单的说，docker就是一个轻量级的linux系统。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。docker架构如图所示：<br><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729185837.png" alt=""></p>
<h3 id="1-3、docker虚拟机管理命令"><a href="#1-3、docker虚拟机管理命令" class="headerlink" title="1.3、docker虚拟机管理命令"></a>1.3、docker虚拟机管理命令</h3><p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729185955.png" alt=""></p>
<a id="more"></a>

<h3 id="1-4、安装docker"><a href="#1-4、安装docker" class="headerlink" title="1.4、安装docker"></a>1.4、安装docker</h3><p>更新软件库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum update -y</span><br></pre></td></tr></table></figure>

<p>安装docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker -y</span><br></pre></td></tr></table></figure>

<h3 id="1-5、启动docker服务"><a href="#1-5、启动docker服务" class="headerlink" title="1.5、启动docker服务"></a>1.5、启动docker服务</h3><p>启动docker服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure>
<p>其它相关命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service docker restart  &#x2F;&#x2F; 重启docker服务</span><br><span class="line">service docker stop     &#x2F;&#x2F; 停止docker服务</span><br></pre></td></tr></table></figure>

<h2 id="node部分"><a href="#node部分" class="headerlink" title="node部分"></a>node部分</h2><h3 id="1-1、创建koa项目"><a href="#1-1、创建koa项目" class="headerlink" title="1.1、创建koa项目"></a>1.1、创建koa项目</h3><p>通过koa框架写一个hello-world项目<br>app.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line"></span><br><span class="line">app.use(async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#39;Hello World&#39;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>
<h3 id="1-2、创建Dockerfile"><a href="#1-2、创建Dockerfile" class="headerlink" title="1.2、创建Dockerfile"></a>1.2、创建Dockerfile</h3><p>然后在项目的根目录下新建一个Dockerfile文件</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>Dockerfile</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dockerfile</span></span><br><span class="line"><span class="comment"># 使用node做为镜像</span></span><br><span class="line"><span class="string">FROM</span> <span class="string">node</span></span><br><span class="line"><span class="comment"># 在容器中创建该目录</span></span><br><span class="line"><span class="string">RUN</span> <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">/home/project</span></span><br><span class="line"><span class="comment"># 设置容器的工作目录为该目录</span></span><br><span class="line"><span class="string">WORKDIR</span> <span class="string">/home/project</span> </span><br><span class="line"><span class="comment"># 向外提供3000端口</span></span><br><span class="line"><span class="string">EXPOSE</span> <span class="number">3000</span></span><br><span class="line"><span class="comment"># 容器创建完成后执行的命令</span></span><br><span class="line"><span class="string">CMD</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">--registry=https://registry.npm.taobao.org</span> <span class="string">&amp;&amp;</span> <span class="string">node</span> <span class="string">./start.js</span></span><br></pre></td></tr></table></figure>

<p>将该项目发布到github上，为之后的jenkins部署做前提准备</p>
<h2 id="3、jenkins部分"><a href="#3、jenkins部分" class="headerlink" title="3、jenkins部分"></a>3、jenkins部分</h2><ul>
<li><p>查询jenkins镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search jenkins</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取最新的jenkins镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull jenkins:latest</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动jenkins</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run -d -u 0 --privileged  --name myjenkins -p 5000:8080 -v &#x2F;root&#x2F;myjenkins:&#x2F;var&#x2F;jenkins_home jenkins</span><br><span class="line"></span><br><span class="line">&lt;!-- docker run -d -p 80:8080 -p 50000:50000 -v jenkins:&#x2F;var&#x2F;jenkins_home -v &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime --name jenkins jenkins:latest --&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这里逐条解释下各参数的意义。</p>
<ul>
<li><code>-u 0</code>: 指的是传入root账号ID，覆盖容器中内置的账号</li>
<li><code>v /root/jenkins:/var/jenkins_home</code> : 指的是 将docker容器内的目录/var/jenkins_home映射到宿主机 /root/jenkins目录上</li>
<li><code>--name jenkins</code> : 将容器命名为 jenkins</li>
<li><code>-p 5000:8080</code> : 端口映射，将容器的8080端口映射到宿主机的5000端口</li>
<li><code>--privileged</code> : 赋予最高权限</li>
</ul>
<p>运行一个镜像为jenkins:latest的容器，命名为jenkins，使用root账号覆盖容器中的账号，赋予最高权限，将容器的<br>/var/jenkins_home映射到宿主机的<br>/root/jenkins目录下，映射容器中8080端口到宿主机5000端口</p>
<p>启动后输入命令docker ps -a查看所有容器，可以看到jenkins已成功启动。</p>
<ul>
<li>配置Jenkins</li>
</ul>
<p>在浏览器输入<a href="http://ip:5000进入Jenkins登录页面。页面会提示你到服务器的指定位置获取初始化密码">http://ip:5000进入Jenkins登录页面。页面会提示你到服务器的指定位置获取初始化密码</a></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729193457.png" alt=""></p>
<p><strong>获取密码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;root&#x2F;jenkins&#x2F;secrets&#x2F;initialAdminPassword</span><br></pre></td></tr></table></figure>

<p><strong>在页面输入密码，点击Continue，进入插件安装页面。我们点击左边的Install suggested plugins，安装推荐插件就好。</strong></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729193708.png" alt=""></p>
<p><strong>安装好插件后，系统会提示建立管理员账户。</strong></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729193738.png" alt=""></p>
<p><strong>输入账号密码信息后点击保存（信息要填完），来到首页</strong></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729194719.png" alt=""></p>
<p><strong>配置jenkins，进入系统管理页面，管理插件</strong></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729194739.png" alt=""></p>
<p><strong>选择 ssh插件，</strong></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729194803.png" alt=""></p>
<p>直接安装，等待安装完成，回到首页，</p>
<p><strong>来到 系统管理 -&gt; 系统配置</strong></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729194829.png" alt=""></p>
<p><strong>拖到最下Publish over SSH这</strong></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729194904.png" alt=""></p>
<p><strong>选择高级，输入服务器IP，用户名，密码，然后点击 Test Configuration</strong></p>
<p>显示 Success 则说明配置没问题。然后保存，回到首页</p>
<p><strong>新建一个项目</strong></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729194936.png" alt=""></p>
<p><strong>输入项目名称</strong></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729195003.png" alt=""></p>
<p><strong>选择源码管理，使用git管理，输入github仓库地址，添加github用户</strong></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729195138.png" alt=""><br><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729195202.png" alt=""><br><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729195237.png" alt=""></p>
<p><strong>完成来到选择构建环境，</strong></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729195259.png" alt=""></p>
<p><strong>执行的命令</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker stop nodeapp || true \</span><br><span class="line"> &amp;&amp; sudo docker rm nodeapp || true \</span><br><span class="line"> &amp;&amp; cd &#x2F;root&#x2F;jenkins_node1&#x2F;workspace&#x2F;node  \</span><br><span class="line"> &amp;&amp; sudo docker build --rm --no-cache&#x3D;true  -t node  - &lt; Dockerfile \</span><br><span class="line"> &amp;&amp; sudo docker run -d --privileged&#x3D;true --name nodeapp -p 3000:3000 -v &#x2F;root&#x2F;jenkins_node1&#x2F;workspace&#x2F;node:&#x2F;home&#x2F;project node</span><br></pre></td></tr></table></figure>

<p><strong>保存后，点击立即构建</strong><br>构建成功后，可以在宿主机的目录/root/jenkins_node1/workspace/node下看到你的项目文件了</p>
<p>在浏览器输入 docker服务器地址 localhost:3000 即可访问到页面信息</p>
<p>启动失败的，可以查看日志来确定一下失败的原因</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs nodeapp</span><br></pre></td></tr></table></figure>


]]></content>
  </entry>
  <entry>
    <title>linux安装jenkins</title>
    <url>/2020/07/30/linux%E5%AE%89%E8%A3%85java-jdk%E4%B8%8Ejenkins/</url>
    <content><![CDATA[<h2 id="安装jdk8"><a href="#安装jdk8" class="headerlink" title="安装jdk8"></a>安装jdk8</h2><p>先查看系统是否已有自带的jdk</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa |grep java</span><br><span class="line"></span><br><span class="line">rpm -qa |grep jdk</span><br><span class="line"></span><br><span class="line">rpm -qa |grep gcj</span><br></pre></td></tr></table></figure>

<p>如果没有输出信息，则说明系统没有安装。如果有输出信息，则执行下面的命令卸载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep java | xargs rpm -e --nodeps</span><br></pre></td></tr></table></figure>
<p><a href="http://mirror.esuni.jp/jenkins/updates/update-center.json" target="_blank" rel="noopener">http://mirror.esuni.jp/jenkins/updates/update-center.json</a></p>
<a id="more"></a>

<p>列出所有可安装的rpm软件包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list java-1.8*</span><br></pre></td></tr></table></figure>
<p>此时会输出一大堆软件包列表。</p>
<p>安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install java-1.8.0-openjdk* -y</span><br></pre></td></tr></table></figure>

<p>验证是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<p>到此安装成功。可见yum已经自动为我们配置好了java环境变量，很方便吧。</p>
<h2 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h2><p><a href="https://www.jenkins.io/doc/book/installing/#red-hat-centos" target="_blank" rel="noopener">jenkins</a><br><a href="https://www.jianshu.com/p/180fb11a5b96" target="_blank" rel="noopener">参考2</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;jenkins.repo http:&#x2F;&#x2F;pkg.jenkins.io&#x2F;redhat&#x2F;jenkins.repo</span><br><span class="line">sudo rpm --import http:&#x2F;&#x2F;pkg.jenkins.io&#x2F;redhat&#x2F;jenkins.io.key</span><br><span class="line">sudo yum install jenkins</span><br></pre></td></tr></table></figure>

<p><strong>配置权限</strong><br>为了不因为权限出现各种问题，这里直接使用root</p>
<p>修改用户为root</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;jenkins</span><br><span class="line"></span><br><span class="line">#修改配置</span><br><span class="line">$JENKINS_USER&#x3D;&quot;root&quot;</span><br></pre></td></tr></table></figure>
<p>修改目录权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown -R root:root &#x2F;var&#x2F;lib&#x2F;jenkins</span><br><span class="line">chown -R root:root &#x2F;var&#x2F;cache&#x2F;jenkins</span><br><span class="line">chown -R root:root &#x2F;var&#x2F;log&#x2F;jenkins</span><br></pre></td></tr></table></figure>
<p>重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service jenkins restart</span><br><span class="line">ps -ef | grep jenkins</span><br></pre></td></tr></table></figure>


<p>使用以下命令启动Jenkins服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl start jenkins</span><br></pre></td></tr></table></figure>

<p>使用以下命令检查Jenkins服务的状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo systemctl status jenkins</span><br></pre></td></tr></table></figure>


<h2 id="Jenkins-使用国内镜像快速安装（rpm安装）"><a href="#Jenkins-使用国内镜像快速安装（rpm安装）" class="headerlink" title="Jenkins 使用国内镜像快速安装（rpm安装）"></a>Jenkins 使用国内镜像快速安装（rpm安装）</h2><h3 id="下载rpm包"><a href="#下载rpm包" class="headerlink" title="下载rpm包"></a>下载rpm包</h3><p>是目前最新 jenkins LTS版本: 可以在去 清华大学镜像站 看一下，替换成最新的链接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;jenkins&#x2F;redhat-stable&#x2F;jenkins-2.204.3-1.1.noarch.rpm</span><br></pre></td></tr></table></figure>

<h3 id="安装并启动"><a href="#安装并启动" class="headerlink" title="安装并启动"></a>安装并启动</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo yum install jenkins-2.204.3-1.1.noarch.rpm</span><br></pre></td></tr></table></figure>

<h3 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h3><p>jenkins 默认8080端口，如果和别的程序冲突，可以修改端口号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;sysconfig&#x2F;jenkins</span><br></pre></td></tr></table></figure>

<h3 id="开启服务"><a href="#开启服务" class="headerlink" title="开启服务"></a>开启服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start jenkins.service</span><br></pre></td></tr></table></figure>

<h3 id="获取访问秘钥，复制下来，接下来要验证"><a href="#获取访问秘钥，复制下来，接下来要验证" class="headerlink" title="获取访问秘钥，复制下来，接下来要验证"></a>获取访问秘钥，复制下来，接下来要验证</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;secrets&#x2F;initialAdminPassword</span><br></pre></td></tr></table></figure>

<h3 id="修改默认镜像源"><a href="#修改默认镜像源" class="headerlink" title="修改默认镜像源"></a>修改默认镜像源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;var&#x2F;lib&#x2F;jenkins&#x2F;hudson.model.UpdateCenter.xml</span><br></pre></td></tr></table></figure>

<p>将 url 修改为 清华大学官方镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&#39;1.1&#39; encoding&#x3D;&#39;UTF-8&#39;?&gt;</span><br><span class="line">&lt;sites&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;id&gt;default&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;url&gt;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;jenkins&#x2F;updates&#x2F;update-center.json&lt;&#x2F;url&gt;</span><br><span class="line">  &lt;&#x2F;site&gt;</span><br><span class="line">&lt;&#x2F;sites&gt;</span><br></pre></td></tr></table></figure>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;ip地址:端口号</span><br></pre></td></tr></table></figure>

<h2 id="Docker-快速安装Jenkins实用教程"><a href="#Docker-快速安装Jenkins实用教程" class="headerlink" title="Docker 快速安装Jenkins实用教程"></a>Docker 快速安装Jenkins实用教程</h2><h3 id="查找镜像"><a href="#查找镜像" class="headerlink" title="查找镜像"></a>查找镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search jenkins</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731110630.png" alt=""></p>
<h3 id="下载Jenkins镜像文件"><a href="#下载Jenkins镜像文件" class="headerlink" title="下载Jenkins镜像文件"></a>下载Jenkins镜像文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull jenkins&#x2F;jenkins</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731110705.png" alt=""></p>
<h3 id="创建Jenkins挂载目录并授权"><a href="#创建Jenkins挂载目录并授权" class="headerlink" title="创建Jenkins挂载目录并授权"></a>创建Jenkins挂载目录并授权</h3><p>我们在服务器上先创建一个jenkins工作目录 /var/jenkins_node，赋予相应权限，稍后我们将jenkins容器目录挂载到这个目录上，这样我们就可以很方便地对容器内的配置文件进行修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p &#x2F;var&#x2F;jenkins_node</span><br><span class="line">chmod 777 &#x2F;var&#x2F;jenkins_node</span><br></pre></td></tr></table></figure>

<h3 id="创建并启动容器"><a href="#创建并启动容器" class="headerlink" title="创建并启动容器"></a>创建并启动容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 10240:8080 -p 10241:50000 -v &#x2F;var&#x2F;jenkins_node:&#x2F;var&#x2F;jenkins_home -v &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime --name myjenkins jenkins&#x2F;jenkins</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>-d</code> 后台运行镜像</p>
</li>
<li><p><code>-p 10240:8080</code> 将镜像的8080端口映射到服务器的10240端口。</p>
</li>
<li><p><code>-p 10241:50000</code> 将镜像的50000端口映射到服务器的10241端口</p>
</li>
<li><p><code>-v /var/jenkins_node:/var/jenkins_home</code> /var/jenkins_home目录为容器jenkins工作目录，我们将硬盘上的一个目录挂载到这个位置，方便后续更新镜像后继续使用原来的工作目录。这里我们设置的就是上面我们创建的 /var/jenkins_node目录</p>
</li>
<li><p><code>-v /etc/localtime:/etc/localtime</code> 让容器使用和服务器同样的时间设置。</p>
</li>
<li><p><code>--name myjenkins</code> 给容器起一个别名</p>
</li>
</ul>
<h3 id="查看容器状态"><a href="#查看容器状态" class="headerlink" title="查看容器状态"></a>查看容器状态</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731111050.png" alt=""></p>
<h3 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker logs myjenkins</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731111130.png" alt=""></p>
<h3 id="配置镜像加速"><a href="#配置镜像加速" class="headerlink" title="配置镜像加速"></a>配置镜像加速</h3><p>可供选择的jenkins2 插件镜像列表：<br>Jenkins 所有镜像列表： <a href="http://mirrors.jenkins-ci.org/status.html" target="_blank" rel="noopener">http://mirrors.jenkins-ci.org/status.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">比如日本的镜像：</span><br><span class="line">http:&#x2F;&#x2F;mirror.esuni.jp&#x2F;jenkins&#x2F;,</span><br><span class="line">http:&#x2F;&#x2F;ftp.yz.yamagata-u.ac.jp&#x2F;pub&#x2F;misc&#x2F;jenkins&#x2F;，</span><br><span class="line">http:&#x2F;&#x2F;ftp.tsukuba.wide.ad.jp&#x2F;software&#x2F;jenkins&#x2F;</span><br><span class="line">德国的镜像：</span><br><span class="line">http:&#x2F;&#x2F;jenkins.mirror.isppower.de&#x2F; ，</span><br><span class="line">http:&#x2F;&#x2F;mirror.yandex.ru&#x2F;mirrors&#x2F;jenkins&#x2F;</span><br><span class="line">官方的镜像：</span><br><span class="line">http:&#x2F;&#x2F;mirrors.jenkins-ci.org&#x2F;， </span><br><span class="line">http:&#x2F;&#x2F;archives.jenkins-ci.org&#x2F;</span><br></pre></td></tr></table></figure>

<p>推荐清华大学镜像：<br><a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;var&#x2F;jenkins_node</span><br></pre></td></tr></table></figure>
<p>修改 <code>hudson.model.UpdateCenter.xml</code>里的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&#39;1.1&#39; encoding&#x3D;&#39;UTF-8&#39;?&gt;</span><br><span class="line">&lt;sites&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;id&gt;default&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;url&gt;https:&#x2F;&#x2F;updates.jenkins.io&#x2F;update-center.json&lt;&#x2F;url&gt;</span><br><span class="line">  &lt;&#x2F;site&gt;</span><br><span class="line">&lt;&#x2F;sites&gt;</span><br></pre></td></tr></table></figure>
<p>将 url 修改为 清华大学官方镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&#39;1.1&#39; encoding&#x3D;&#39;UTF-8&#39;?&gt;</span><br><span class="line">&lt;sites&gt;</span><br><span class="line">  &lt;site&gt;</span><br><span class="line">    &lt;id&gt;default&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;url&gt;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;jenkins&#x2F;updates&#x2F;update-center.json&lt;&#x2F;url&gt;</span><br><span class="line">  &lt;&#x2F;site&gt;</span><br><span class="line">&lt;&#x2F;sites&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731111426.png" alt=""></p>
<h3 id="访问-1"><a href="#访问-1" class="headerlink" title="访问"></a>访问</h3><p>你的ip地址加上端口号<br><a href="http://ip地址:1024" target="_blank" rel="noopener">http://ip地址:1024</a></p>
<h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>如果我们不配置镜像加速，那么很有可能会出现： Jenkins 一直卡在 启动界面 Please wait while Jenkins is getting ready to work …</p>
]]></content>
      <tags>
        <tag>部署</tag>
        <tag>安装</tag>
      </tags>
  </entry>
  <entry>
    <title>从零搭建docker+jenkins+vue自动化部署环境</title>
    <url>/2020/07/29/%E4%BB%8E%E9%9B%B6%E6%90%AD%E5%BB%BAdocker-jenkins-vue%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="1、docker部分"><a href="#1、docker部分" class="headerlink" title="1、docker部分"></a>1、docker部分</h2><h3 id="1-1、docker简介"><a href="#1-1、docker简介" class="headerlink" title="1.1、docker简介"></a>1.1、docker简介</h3><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口</p>
<h3 id="1-2、docker架构"><a href="#1-2、docker架构" class="headerlink" title="1.2、docker架构"></a>1.2、docker架构</h3><p>简单的说，docker就是一个轻量级的linux系统。Docker 容器通过 Docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。docker架构如图所示：<br><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729185837.png" alt=""></p>
<h3 id="1-3、docker虚拟机管理命令"><a href="#1-3、docker虚拟机管理命令" class="headerlink" title="1.3、docker虚拟机管理命令"></a>1.3、docker虚拟机管理命令</h3><p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729185955.png" alt=""></p>
<h3 id="1-4、安装docker"><a href="#1-4、安装docker" class="headerlink" title="1.4、安装docker"></a>1.4、安装docker</h3><p>更新软件库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum update -y</span><br></pre></td></tr></table></figure>

<p>安装docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker -y</span><br></pre></td></tr></table></figure>

<h3 id="1-5、启动docker服务"><a href="#1-5、启动docker服务" class="headerlink" title="1.5、启动docker服务"></a>1.5、启动docker服务</h3><p>启动docker服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service docker start</span><br></pre></td></tr></table></figure>
<p>其它相关命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service docker restart  &#x2F;&#x2F; 重启docker服务</span><br><span class="line">service docker stop     &#x2F;&#x2F; 停止docker服务</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="2、jenkins部分"><a href="#2、jenkins部分" class="headerlink" title="2、jenkins部分"></a>2、jenkins部分</h2><ul>
<li><p>查询jenkins镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search jenkins</span><br></pre></td></tr></table></figure>
</li>
<li><p>拉取最新的jenkins镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull jenkins:latest</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>启动jenkins<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo docker run -d -u 0 --privileged  --name jenkins_node1 -p 5000:8080 -v &#x2F;root&#x2F;jenkins:&#x2F;var&#x2F;jenkins_home jenkins:latest</span><br><span class="line"></span><br><span class="line">&lt;!-- docker run -d -p 80:8080 -p 50000:50000 -v jenkins:&#x2F;var&#x2F;jenkins_home -v &#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime --name jenkins jenkins:latest --&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这里逐条解释下各参数的意义。</p>
<ul>
<li><code>-u 0</code>: 指的是传入root账号ID，覆盖容器中内置的账号</li>
<li><code>v /root/jenkins:/var/jenkins_home</code> : 指的是 将docker容器内的目录/var/jenkins_home映射到宿主机 /root/jenkins目录上</li>
<li><code>--name jenkins</code> : 将容器命名为 jenkins</li>
<li><code>-p 5000:8080</code> : 端口映射，将容器的8080端口映射到宿主机的5000端口</li>
<li><code>--privileged</code> : 赋予最高权限</li>
</ul>
<p>运行一个镜像为jenkins:latest的容器，命名为jenkins，使用root账号覆盖容器中的账号，赋予最高权限，将容器的<br>/var/jenkins_home映射到宿主机的<br>/root/jenkins目录下，映射容器中8080端口到宿主机5000端口</p>
<p>启动后输入命令docker ps -a查看所有容器，可以看到jenkins已成功启动。</p>
<p>不出意外你现在可以打开你的服务器地址 <a href="http://xxxxxxx:端口号">http://xxxxxxx:端口号</a> 就能看到这个界面：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729214950.png" alt=""></p>
<p>打开你所创建的jenkins目录进入到jenkins-home<br>/home/jenkins/jenkins-home</p>
<p>进入 secrets 目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat initialAdminPassword</span><br></pre></td></tr></table></figure>

<p>然后把里面的文本复制出来填到管理员密码中</p>
<p>接下来需要安装两个插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NodeJS Plugin</span><br><span class="line">Publish Over SSH</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729215127.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729215146.png" alt=""></p>
<p>然后我们滑到最下方</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729215328.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729215413.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729215434.png" alt=""></p>
<h2 id="开始创建项目部署"><a href="#开始创建项目部署" class="headerlink" title="开始创建项目部署"></a>开始创建项目部署</h2><p><a href="https://cli.vuejs.org/guide/deployment.html#bitbucket-cloud" target="_blank" rel="noopener" title="官方参考">官方参考</a></p>
<h3 id="1、首先在项目根目录创建一个nginx-conf文件"><a href="#1、首先在项目根目录创建一个nginx-conf文件" class="headerlink" title="1、首先在项目根目录创建一个nginx.conf文件"></a>1、首先在项目根目录创建一个nginx.conf文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user  nginx;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log warn;</span><br><span class="line">pid        &#x2F;var&#x2F;run&#x2F;nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line">  worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">  include       &#x2F;etc&#x2F;nginx&#x2F;mime.types;</span><br><span class="line">  default_type  application&#x2F;octet-stream;</span><br><span class="line">  log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line">  access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log  main;</span><br><span class="line">  sendfile        on;</span><br><span class="line">  keepalive_timeout  65;</span><br><span class="line">  server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.lovelp.xin;  # 域名</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">      root   &#x2F;app;  # 指向目录</span><br><span class="line">      index  index.html;</span><br><span class="line">      try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">    &#125;</span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">      root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2、在项目根目录创建一个Dockerfile文件"><a href="#2、在项目根目录创建一个Dockerfile文件" class="headerlink" title="2、在项目根目录创建一个Dockerfile文件"></a>2、在项目根目录创建一个Dockerfile文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM node</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line"></span><br><span class="line">COPY package*.json .&#x2F;</span><br><span class="line">RUN npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class="line">RUN cnpm install</span><br><span class="line">COPY .&#x2F; &#x2F;app</span><br><span class="line">RUN npm run build:prod</span><br><span class="line"></span><br><span class="line">FROM nginx</span><br><span class="line">RUN mkdir &#x2F;app</span><br><span class="line">COPY --from&#x3D;0 &#x2F;app&#x2F;dist &#x2F;app</span><br><span class="line">COPY nginx.conf &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>
<h3 id="3、在项目根目录创建一个setup-sh来帮助我们执行脚本"><a href="#3、在项目根目录创建一个setup-sh来帮助我们执行脚本" class="headerlink" title="3、在项目根目录创建一个setup.sh来帮助我们执行脚本"></a>3、在项目根目录创建一个setup.sh来帮助我们执行脚本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;env bash</span><br><span class="line">image_version&#x3D;&#96;date +%Y%m%d%H%M&#96;;</span><br><span class="line"># 关闭shop_admin容器</span><br><span class="line">docker stop shop_admin || true;</span><br><span class="line"># 删除shop_admin容器</span><br><span class="line">docker rm shop_admin || true;</span><br><span class="line"># 删除shop&#x2F;admin镜像</span><br><span class="line">docker rmi --force $(docker images | grep shop&#x2F;admin | awk &#39;&#123;print $3&#125;&#39;)</span><br><span class="line"># 构建shop&#x2F;admin:$image_version镜像</span><br><span class="line">docker build . -t shop&#x2F;admin:$image_version;</span><br><span class="line"># 查看镜像列表</span><br><span class="line">docker images;</span><br><span class="line"># 基于shop&#x2F;admin 镜像 构建一个容器 shop_admin</span><br><span class="line">docker run -p 9527:80 -d --name shop_admin shop&#x2F;admin:$image_version;</span><br><span class="line"># 查看日志</span><br><span class="line">docker logs shop_admin;</span><br><span class="line">#删除build过程中产生的镜像    #docker image prune -a -f</span><br><span class="line">docker rmi $(docker images -f &quot;dangling&#x3D;true&quot; -q)</span><br><span class="line"># 对空间进行自动清理</span><br><span class="line">docker system prune -a -f</span><br></pre></td></tr></table></figure>

<p>###　4、最后我们需要在jenkins上创建项目<br><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729215944.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729220004.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729220029.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200729220042.png" alt=""></p>
<p>最后我们就可以愉快的 Build Now 了</p>
]]></content>
  </entry>
  <entry>
    <title>通过Docker快速搭建各种环境（全攻略）</title>
    <url>/2020/07/31/%E9%80%9A%E8%BF%87Docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="Docker-基础教程"><a href="#Docker-基础教程" class="headerlink" title="Docker 基础教程"></a>Docker 基础教程</h2><h3 id="配置国内镜像加速器"><a href="#配置国内镜像加速器" class="headerlink" title="配置国内镜像加速器"></a>配置国内镜像加速器</h3><p>Docker 配置国内镜像加速器，加速下载速度</p>
<p>Docker 默认是从官方镜像地址 Docker Hub 下下载镜像，由于服务器在国外的缘故，导致经常下载速度非常慢。为了提升镜像的下载速度，我们可以手动配置国内镜像加速器，让下载速度飚起来。</p>
<p>国内的镜像加速器选项较多，如：阿里云，DaoCloud 等。</p>
<p>本文主要说说如何配置阿里云的镜像加速器。</p>
<h4 id="一、获取加速信息"><a href="#一、获取加速信息" class="headerlink" title="一、获取加速信息"></a>一、获取加速信息</h4><ul>
<li><p>1、首先你需要注册一个阿里云账号，没有的话，通过下面的连接跳转注册：<br><a href="https://dev.aliyun.com/" target="_blank" rel="noopener">https://dev.aliyun.com/</a></p>
</li>
<li><p>2、跳转镜像加速页 <a href="https://cr.console.aliyun.com/，获取加速配置信息：" target="_blank" rel="noopener">https://cr.console.aliyun.com/，获取加速配置信息：</a></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123229.png" alt=""></p>
<h4 id="二、配置-Docker"><a href="#二、配置-Docker" class="headerlink" title="二、配置 Docker"></a>二、配置 Docker</h4><p><strong>确定 Docker Client 版本</strong></p>
<p>在配置之前，首先需要确定 Docker Client 的版本，推荐是 1.10.0+:</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123341.png" alt=""></p>
<p><strong>配置镜像加速器</strong><br>通过修改 daemon 配置文件 <code>/etc/docker/daemon.json</code> 来使用加速器：</p>
<p>执行下面命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;bjtzu1jb.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="三、验证速度"><a href="#三、验证速度" class="headerlink" title="三、验证速度"></a>三、验证速度</h4><p>以下载 mongodb 为例，看下速度：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123517.png" alt=""></p>
<p>配置了加速器过后，速度终于飚起来了。</p>
<h3 id="Docker-下载镜像"><a href="#Docker-下载镜像" class="headerlink" title="Docker 下载镜像"></a>Docker 下载镜像</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>大家都知道，镜像是 Docker 三大核心概念中最重要的。如果我们想要在本地运行容器，就必须保证本地存在对应的镜像。所以，第一步，我们需要下载镜像。当我们尝试下载镜像时，Docker 会尝试先从默认的镜像仓库（默认使用 Docker Hub 公共仓库）去下载，当然了，用户也可以自定义配置想要下载的镜像仓库。</p>
<h4 id="二、下载镜像"><a href="#二、下载镜像" class="headerlink" title="二、下载镜像"></a>二、下载镜像</h4><p>镜像是运行容器的前提，我们可以使用 <code>docker pull [IMAGE_NAME]:[TAG]</code>命令来下载镜像，其中 <code>IMAGE_NAME</code> 表示的是镜像的名称，而 <code>TAG</code> 是镜像的标签，也就是说我们需要通过 “镜像 + 标签” 的方式来下载镜像。</p>
<blockquote>
<p>注意：您也可以不显式地指定 TAG, 它会默认下载 latest 标签，也就是下载仓库中最新版本的镜像。这里并不推荐您下载 latest 标签，因为该镜像的内容会跟踪镜像的最新版本，并随之变化，所以它是不稳定的。在生产环境中，可能会出现莫名其妙的 bug, 推荐您最好还是显示的指定具体的 TAG。</p>
</blockquote>
<p>举个例子，如我们想要下载一个 <code>Mysql 5.7</code> 镜像，可以通过命令来下载：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<p>会看到控制台输出内容如下：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123820.png" alt=""></p>
<p>当有 <strong>Downloaded</strong> 字符串输出的时候，说明下载成功了！！</p>
<h4 id="三、验证镜像"><a href="#三、验证镜像" class="headerlink" title="三、验证镜像"></a>三、验证镜像</h4><p>让我们来验证一下，本地是否存在 Mysql5.7 的镜像，运行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123939.png" alt=""></p>
<p>可以看到本地的确存在该镜像，确实是下载成功了！</p>
<h4 id="四、下载镜像相关细节"><a href="#四、下载镜像相关细节" class="headerlink" title="四、下载镜像相关细节"></a>四、下载镜像相关细节</h4><p>再说说上面下载镜像的过程：<br><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124023.png" alt=""></p>
<p>通过下载过程，可以看到，一个镜像一般是由多个层（layer） 组成，类似 f7e2b70d04ae这样的串表示层的唯一 ID。</p>
<p>您可能会想，如果多个不同的镜像中，同时包含了同一个层（layer）,这样重复下载，岂不是导致了存储空间的浪费么?</p>
<p>实际上，Docker 并不会这么傻会去下载重复的层（layer）,Docker 在下载之前，会去检测本地是否会有同样 ID 的层，如果本地已经存在了，就直接使用本地的就好了。</p>
<h3 id="Docker-查看镜像信息"><a href="#Docker-查看镜像信息" class="headerlink" title="Docker 查看镜像信息"></a>Docker 查看镜像信息</h3><h4 id="一、images-命令列出镜像"><a href="#一、images-命令列出镜像" class="headerlink" title="一、images 命令列出镜像"></a>一、images 命令列出镜像</h4><p>通过使用如下两个命令，列出本机已有的镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124249.png" alt=""></p>
<p>对上述红色标注的字段做一下解释：</p>
<ul>
<li><strong>REPOSITORY</strong>: 来自于哪个仓库；</li>
<li><strong>TAG</strong>: 镜像的标签信息，比如 5.7、latest 表示不同的版本信息；</li>
<li><strong>IMAGE ID</strong>: 镜像的 ID, 如果您看到两个 ID 完全相同，那么实际上，它们指向的是同一个镜像，只是标签名称不同罢了；</li>
<li><strong>CREATED</strong>: 镜像最后的更新时间；</li>
<li><strong>SIZE</strong>: 镜像的大小，优秀的镜像一般体积都比较小，这也是我更倾向于使用轻量级的 alpine 版本的原因</li>
</ul>
<h4 id="二、使用-tag-命令为镜像添加标签"><a href="#二、使用-tag-命令为镜像添加标签" class="headerlink" title="二、使用 tag 命令为镜像添加标签"></a>二、使用 tag 命令为镜像添加标签</h4><p>通常情况下，为了方便在后续工作中，快速地找到某个镜像，我们可以使用 docker tag 命令，为本地镜像添加一个新的标签。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124505.png" alt=""></p>
<p>为 <code>docker.io/mysql</code> 镜像，添加新的镜像标签 <code>allen_mysql:5.7</code>。然后使用 <code>docker images</code> 命令，查看本地镜像：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124556.png" alt=""></p>
<p>可以看到，本地多了一个 allen_mysql:5.7 的镜像。细心的你一定还会发现，allen_mysql:5.7 和 docker.io/mysql:5.7 的镜像 ID 是一模一样的，说明它们是同一个镜像，只是别名不同而已。</p>
<p>docker tag 命令功能更像是, 为指定镜像添加快捷方式一样。</p>
<h4 id="三、使用-inspect-命令查看镜像详细信息"><a href="#三、使用-inspect-命令查看镜像详细信息" class="headerlink" title="三、使用 inspect 命令查看镜像详细信息"></a>三、使用 inspect 命令查看镜像详细信息</h4><p>通过 <code>docker inspect</code> 命令，我们可以获取镜像的详细信息，其中，包括创建者，各层的数字摘要等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect docker.io&#x2F;mysql:5.7</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124709.png" alt=""></p>
<p>docker inspect 返回的是 JSON 格式的信息，如果您想获取其中指定的一项内容，可以通过 -f 来指定，如获取镜像大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect -f &#123;&#123;&quot;.Size&quot;&#125;&#125; docker.io&#x2F;mysql:5.7</span><br></pre></td></tr></table></figure>

<h3 id="Docker-搜索镜像"><a href="#Docker-搜索镜像" class="headerlink" title="Docker 搜索镜像"></a>Docker 搜索镜像</h3><h4 id="一、search-命令"><a href="#一、search-命令" class="headerlink" title="一、search 命令"></a>一、search 命令</h4><p>您可以通过下面命令进行搜索：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search [option] keyword</span><br></pre></td></tr></table></figure>

<p>比如，您想搜索仓库中 mysql 相关的镜像，可以输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure>

<h4 id="二、search-子命令"><a href="#二、search-子命令" class="headerlink" title="二、search 子命令"></a>二、search 子命令</h4><p>命令行输入 <code>docker search --help</code>, 输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Usage:  docker search [OPTIONS] TERM</span><br><span class="line"></span><br><span class="line">Search the Docker Hub for images</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --help            Print usage</span><br><span class="line">      --limit int       Max number of search results (default 25)</span><br><span class="line">      --no-index        Don&#39;t truncate output</span><br><span class="line">      --no-trunc        Don&#39;t truncate output</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>search</code> 支持的子命令有：</p>
<ul>
<li><code>-f, --filter filter</code>: 过滤输出的内容；</li>
<li><code>--limit int</code>：指定搜索内容展示个数;</li>
<li><code>--no-index</code>: 不截断输出内容；</li>
<li><code>--no-trunc</code>：不截断输出内容；</li>
</ul>
<p>比如我们想搜索官方提供的 mysql 镜像，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search --filter&#x3D;is-offical&#x3D;true mysql</span><br></pre></td></tr></table></figure>

<p>比如，我们想搜索 Stars 数超过 100 的 mysql 镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search --filter&#x3D;stars&#x3D;100 mysql</span><br></pre></td></tr></table></figure>

<h3 id="Docker-删除-amp-清理镜像"><a href="#Docker-删除-amp-清理镜像" class="headerlink" title="Docker 删除&amp;清理镜像"></a>Docker 删除&amp;清理镜像</h3><h4 id="一、通过标签删除镜像"><a href="#一、通过标签删除镜像" class="headerlink" title="一、通过标签删除镜像"></a>一、通过标签删除镜像</h4><p>以下两种命令均可删除镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi [image]</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image rm [image]</span><br></pre></td></tr></table></figure>

<p>支持的子命令如下：</p>
<ul>
<li><code>-f, -force</code>: 强制删除镜像，即便有容器引用该镜像；</li>
<li><code>-no-prune</code>: 不要删除未带标签的父镜像；</li>
</ul>
<p>例如，我们想删除上章节创建的 allen_mysql:5.7 镜像，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi allen_mysql:5.7</span><br></pre></td></tr></table></figure>

<h4 id="二、通过-ID-删除镜像"><a href="#二、通过-ID-删除镜像" class="headerlink" title="二、通过 ID 删除镜像"></a>二、通过 ID 删除镜像</h4><p>除了通过标签名称来删除镜像，我们还可以通过制定镜像 ID, 来删除镜像，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker rmi ee7cbd482336</span><br></pre></td></tr></table></figure>
<p>一旦制定了通过 ID 来删除镜像，它会先尝试删除所有指向该镜像的标签，然后在删除镜像本身。</p>
<h4 id="三、删除镜像的限制"><a href="#三、删除镜像的限制" class="headerlink" title="三、删除镜像的限制"></a>三、删除镜像的限制</h4><p>删除镜像很简单，但也不是我们何时何地都能删除的，它存在一些限制条件。</p>
<p>当通过该镜像创建的容器未被销毁时，镜像是无法被删除的。</p>
<p>正确的做法应该是：</p>
<ul>
<li>先删除引用这个镜像的容器；</li>
<li>再删除这个镜像；</li>
</ul>
<h4 id="四、清理镜像"><a href="#四、清理镜像" class="headerlink" title="四、清理镜像"></a>四、清理镜像</h4><p>我们在使用 Docker 一段时间后，系统一般都会残存一些临时的、没有被使用的镜像文件，可以通过以下命令进行清理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>
<p>它支持的子命令有：</p>
<ul>
<li><code>-a, --all</code>: 删除所有没有用的镜像，而不仅仅是临时文件；</li>
<li><code>-f, --force</code>：强制删除镜像文件，无需弹出提示确认；</li>
</ul>
<p>另外，执行完 docker image prune 命令后，还是告诉我们释放了多少存储空间！</p>
<h3 id="Docker-创建镜像"><a href="#Docker-创建镜像" class="headerlink" title="Docker 创建镜像"></a>Docker 创建镜像</h3><p>Docker 创建镜像主要有三种：</p>
<ul>
<li>基于已有的镜像创建；</li>
<li>基于 Dockerfile 来创建；</li>
<li>基于本地模板来导入；</li>
</ul>
<p>我们将主要介绍常用的 1，2 两种。</p>
<h4 id="一、基于已有的镜像创建"><a href="#一、基于已有的镜像创建" class="headerlink" title="一、基于已有的镜像创建"></a>一、基于已有的镜像创建</h4><p>通过如下命令来创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container commit</span><br></pre></td></tr></table></figure>

<p>支持的子命令如下：</p>
<ul>
<li><code>-a, --author=&quot;&quot;</code>: 作者信息；</li>
<li><code>-c, --change=[]</code>: 可以在提交的时候执行 Dockerfile 指令，如 <code>CMD、ENTRYPOINT、ENV、EXPOSE、LABEL、ONBUILD、- USER、VOLUME、WORIR</code> 等；</li>
<li><code>-m, --message=&quot;&quot;</code>: 提交信息；</li>
<li><code>-p, --pause=true</code>: 提交时，暂停容器运行。</li>
</ul>
<p>接下来，基于本地已有的 Ubuntu 镜像，创建一个新的镜像：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731125918.png" alt=""></p>
<p>首先，让我将它运行起来，并在其中创建一个 test.txt 文件：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731125939.png" alt=""></p>
<p>命令如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it docker.io&#x2F;ubuntu:latest &#x2F;bin&#x2F;bash</span><br><span class="line">root@a0a0c8cfec3a:&#x2F;# touch test.txt</span><br><span class="line">root@a0a0c8cfec3a:&#x2F;# exit</span><br></pre></td></tr></table></figure>

<p>创建完 test.txt 文件后，需要记住标注的容器 ID: a0a0c8cfec3a, 用它来提交一个新的镜像(PS: 你也可以通过名称来提交镜像，这里只演示通过 ID 的方式)。</p>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker container commit -m &quot;Added test.txt file&quot; -a &quot;Allen&quot; a0a0c8cfec3a test:0.1</span><br></pre></td></tr></table></figure>

<p>提交成功后，会返回新创建的镜像 ID 信息，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130151.png" alt=""></p>
<p>再次查看本地镜像信息，可以看到新创建的 test:0.1 镜像了：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130309.png" alt=""></p>
<h4 id="二、基于-Dockerfile-来创建镜像"><a href="#二、基于-Dockerfile-来创建镜像" class="headerlink" title="二、基于 Dockerfile 来创建镜像"></a>二、基于 Dockerfile 来创建镜像</h4><p>通过 Dockerfile 的方式来创建镜像，是最常见的一种方式了，也是比较推荐的方式。Dockerfile 是一个文本指令文件，它描述了是如何基于一个父镜像，来创建一个新镜像的过程。</p>
<p>下面让我们来编写一个简单的 Dockerfile 文件，它描述了基于 Ubuntu 父镜像，安装 Python3 环境的镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM docker.io/ubuntu:latest</span><br><span class="line"></span><br><span class="line">LABEL version="1.0" maintainer="Allen &lt;weiwosuo@github&gt;"</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; \</span><br><span class="line">    apt-get install -y python3 &amp;&amp; \</span><br><span class="line">    apt-get clean &amp;&amp; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure>

<p>创建完成后，通过这个 Dockerfile 文件，来构建新的镜像，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image build -t python:3 .</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：命令的最后有个点，如果不加的话，会构建不成功 ！</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130453.png" alt=""></p>
<p>编译成功后，再次查看本地镜像信息，就可以看到新构建的 python:3 镜像了。</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130557.png" alt=""></p>
<h3 id="Docker-导出-amp-加载镜像"><a href="#Docker-导出-amp-加载镜像" class="headerlink" title="Docker 导出&amp;加载镜像"></a>Docker 导出&amp;加载镜像</h3><p>当我们需要将镜像分享给别人时，可以将镜像导出成 tar 包，别人直接通过加载这个 tar 包，快速地将镜像引入到本地镜像库。</p>
<p>要想使用这两个功能，主要是通过如下两个命令：</p>
<ul>
<li>docker save</li>
<li>docker load</li>
</ul>
<h4 id="一、导出镜像"><a href="#一、导出镜像" class="headerlink" title="一、导出镜像"></a>一、导出镜像</h4><p>查看本地镜像如下：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130743.png" alt=""></p>
<p>例如，我们想要将 python:3 镜像导出来，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker save -o python_3.tar python:3</span><br></pre></td></tr></table></figure>

<p>执行成功后，查看当前目录：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130821.png" alt=""></p>
<p>可以看到 python_3.tar 镜像文件已经生成。接下来，你可以将它通过复制的方式，分享给别人了！</p>
<h4 id="二、加载镜像"><a href="#二、加载镜像" class="headerlink" title="二、加载镜像"></a>二、加载镜像</h4><p>别人拿到了这个 tar 包后，要如何导入到本地的镜像库呢？</p>
<p>通过执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load -i python_3.tar</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker load &lt; python_3.tar</span><br></pre></td></tr></table></figure>

<p>导入成功后，查看本地镜像信息，你就可以获得别人分享的镜像了！</p>
<h2 id="常用环境安装篇"><a href="#常用环境安装篇" class="headerlink" title="常用环境安装篇"></a>常用环境安装篇</h2><h3 id="Mysql-环境"><a href="#Mysql-环境" class="headerlink" title="Mysql 环境"></a>Mysql 环境</h3><h4 id="一、下载-Mysql-镜像"><a href="#一、下载-Mysql-镜像" class="headerlink" title="一、下载 Mysql 镜像"></a>一、下载 Mysql 镜像</h4><p>这里以 Mysql 5.7 为例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>
<p>下载完成后，通过 docker images 检查一下镜像是否下载成功:</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731131108.png" alt=""></p>
<h4 id="二、正式运行-Mysql-容器："><a href="#二、正式运行-Mysql-容器：" class="headerlink" title="二、正式运行 Mysql 容器："></a>二、正式运行 Mysql 容器：</h4><p>正式运行 Mysql 容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mysql \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;config&#x2F;mysqld.cnf:&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;data&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456 \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-d</code>：以后台的方式运行；</li>
<li><code>--name mysql</code>：指定容器的名称为 mysql;</li>
<li><code>-p 3306:3306</code> 将容器的 3306 端口挂载到宿主机的 3306 端口上；</li>
<li><code>-e MYSQL_ROOT_PASSWORD=123456</code>：指定 root 的密码为 123456</li>
<li><code>-v /usr/local/docker/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf</code>: 将容器中 /etc/mysql/mysql.conf.d/mysqld.cnf 配置文件挂载到宿主机的 /usr/local/docker/mysql/config/mysqld.cnf 文件上；</li>
<li><code>-v /usr/local/docker/mysql/data:/var/lib/mysql</code>: 将容器中 /var/lib/mysql 数据目录挂载到宿主机的 /usr/local/docker/mysql/data 目录下；</li>
</ul>
<p>执行命令完成后，查看下容器是否启动：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731131907.png" alt=""></p>
<h4 id="三、通过-Mysql-客户端连接一下试试"><a href="#三、通过-Mysql-客户端连接一下试试" class="headerlink" title="三、通过 Mysql 客户端连接一下试试"></a>三、通过 Mysql 客户端连接一下试试</h4><p>通过 MySQL 客户端连接刚刚创建的 mysql, 看看能否连接成功：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731131944.png" alt=""></p>
<p>连接成功了！</p>
<h4 id="相关问题补充"><a href="#相关问题补充" class="headerlink" title="相关问题补充"></a>相关问题补充</h4><p><strong>时区不对问题</strong></p>
<p>在向数据库插入数据时，总是发现时间比系统时间少 8 个小时，这是因为 Mysql 的时区并不是我们想要的东八区。</p>
<p>解决方案：我们可以在上面说到的，挂载到宿主机的 Mysql 配置文件 mysqld.cnf 中，添加如下参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">default-time-zone &#x3D; &#39;+08:00&#39;</span><br></pre></td></tr></table></figure>

<p>添加改配置后，重启 MySQL 容器, 再插入数据，就发现时间正常了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker restart your_mysql_container_name</span><br></pre></td></tr></table></figure>

<h3 id="Redis-环境"><a href="#Redis-环境" class="headerlink" title="Redis 环境"></a>Redis 环境</h3><h4 id="一、下载-Redis-镜像"><a href="#一、下载-Redis-镜像" class="headerlink" title="一、下载 Redis 镜像"></a>一、下载 Redis 镜像</h4><p>首先拉取 Redis 镜像, 这里我选择的是 <code>redis:alpine</code> 轻量级镜像版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull redis:alpine</span><br></pre></td></tr></table></figure>
<p>下载完成后，通过 docker images 确认镜像是否已经下载到本地：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132144.png" alt=""></p>
<h4 id="二、运行-Redis-容器"><a href="#二、运行-Redis-容器" class="headerlink" title="二、运行 Redis 容器"></a>二、运行 Redis 容器</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">--name redis \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data \</span><br><span class="line">-d redis:alpine \</span><br><span class="line">redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf --appendonly yes --requirepass &quot;mypassword&quot;</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<ul>
<li><code>-p 6379:6379</code>: 将容器的 6379 端口映射到宿主机的 6379 端口；</li>
<li><code>-v /usr/local/docker/redis/data:/data</code> : 将容器中的 /data 数据存储目录, 挂载到宿主机中 /usr/local/docker/redis/data 目录下；</li>
<li><code>-v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf</code> ： 将容器中 /etc/redis/redis.conf 配置文件，挂载到宿主机的 /usr/local/docker/redis/redis.conf 文件上；</li>
<li><code>redis-server --appendonly yes --requirepass &quot;mypassword&quot;</code>: 在容器执行 redis-server 启动命令，并打开 redis 持久化配置, 以及设置密码;</li>
</ul>
<p>命令运行完成后，查看容器是否启动成功：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132300.png" alt=""></p>
<h4 id="三、连接刚刚创建好的容器"><a href="#三、连接刚刚创建好的容器" class="headerlink" title="三、连接刚刚创建好的容器"></a>三、连接刚刚创建好的容器</h4><p>执行如下命令，连接 redis：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it redis:alpine redis-cli -h 172.17.0.1</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132330.png" alt=""></p>
<h3 id="MongDB-环境"><a href="#MongDB-环境" class="headerlink" title="MongDB 环境"></a>MongDB 环境</h3><h4 id="一、下载-MongoDB-镜像"><a href="#一、下载-MongoDB-镜像" class="headerlink" title="一、下载 MongoDB 镜像"></a>一、下载 MongoDB 镜像</h4><p>这里以 mongo 4 版本为例，下载镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mongo:4</span><br></pre></td></tr></table></figure>

<p>下载完成后，确认一下镜像是否下载成功:</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132416.png" alt=""></p>
<h4 id="二、运行-MongoDB-镜像"><a href="#二、运行-MongoDB-镜像" class="headerlink" title="二、运行 MongoDB 镜像"></a>二、运行 MongoDB 镜像</h4><p>下载成功后，运行 mongoDB 镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mongo \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mongo&#x2F;configdb:&#x2F;data&#x2F;configdb \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mongo&#x2F;data:&#x2F;data&#x2F;db \</span><br><span class="line">-p 27017:27017 \</span><br><span class="line">mongo:4 \</span><br><span class="line">--auth</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-d</code>: 以后台的方式运行；</li>
<li><code>--name mongo</code>: 指定容器名称为 mongo;</li>
<li><code>-v /usr/local/docker/mongo/configdb:/data/configdb</code>: 将容器中 /data/configdb 目录挂载到宿主机的 /usr/local/docker/mongo/configdb 目录下；</li>
<li><code>-v /usr/local/docker/mongo/data:/data/db</code>: 将容器中 /data/db 数据目录挂载到宿主机的 /usr/local/docker/mongo/data 目录下；</li>
<li>-p <code>27017:27017</code>: 将容器的 27017 端口映射到宿主机的 27017 端口；</li>
</ul>
<p>执行命令完成后，查看下容器是否启动：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132541.png" alt=""></p>
<h4 id="三、添加管理员账号"><a href="#三、添加管理员账号" class="headerlink" title="三、添加管理员账号"></a>三、添加管理员账号</h4><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it mongo mongo admin</span><br></pre></td></tr></table></figure>

<p>然后，创建一个拥有最高权限 root 账号:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db.createUser(&#123; user: &#39;admin&#39;, pwd: &#39;123456&#39;, roles: [ &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125; ] &#125;);</span><br></pre></td></tr></table></figure>

<p>创建成功后，你会看到 Successfully added user:</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132627.png" alt=""></p>
<h4 id="四、用新创建的-root-账户连接，测试一下"><a href="#四、用新创建的-root-账户连接，测试一下" class="headerlink" title="四、用新创建的 root 账户连接，测试一下"></a>四、用新创建的 root 账户连接，测试一下</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --rm --link mongo:mongo mongo mongo -u admin -p 123456 --authenticationDatabase admin mongo&#x2F;admin</span><br></pre></td></tr></table></figure>
<p>连接成功后，我们可以执行相关 sql：</p>
<p><strong>显示所有的数据库：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure>

<p><strong>使用某个数据库：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use admin</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132734.png" alt=""></p>
<p>输入命令 exit，退出连接！</p>
<h3 id="Ngnix-环境"><a href="#Ngnix-环境" class="headerlink" title="Ngnix 环境"></a>Ngnix 环境</h3><h4 id="一、下载-Nginx-镜像"><a href="#一、下载-Nginx-镜像" class="headerlink" title="一、下载 Nginx 镜像"></a>一、下载 Nginx 镜像</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull nginx:alpine</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS：我这里用的是 alipne 轻量级的镜像.</p>
</blockquote>
<p>下载完成后，通过 docker images 命令检查一下镜像是否下载成功：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132929.png" alt=""></p>
<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d \ </span><br><span class="line">-p 80:80 \ </span><br><span class="line">--name nginx \</span><br><span class="line">-v &#x2F;docker&#x2F;nginx&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \</span><br><span class="line">-v &#x2F;docker&#x2F;nginx&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d \</span><br><span class="line">-v &#x2F;docker&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx \</span><br><span class="line">nginx:alpine</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>-d</code>: 以后台方式运行镜像；</li>
<li><code>--name</code>: 指定容器的名称为 nginx;</li>
<li><code>-p 80:80</code>：将容器的 80 端口映射到主机的 80 端口；</li>
<li>`-v /docker/nginx/nginx.conf:/etc/nginx/nginx.conf：将容器中的 /etc/nginx/nginx.conf 文件挂载到宿主机中的 /docker/nginx/nginx.conf 文件；</li>
<li><code>-v /docker/nginx/conf.d:/etc/nginx/conf.d</code>：将容器中 /etc/nginx/conf.d 目录挂载到宿主机中的 conf.d 目录下；</li>
<li><code>-v /docker/nginx/logs:/var/log/nginx</code>：将容器中的 /var/log/nginx 目录挂载到宿主机中的 /docker/nginx/logs 目录下, 用以查看 Nginx 日志；</li>
</ul>
<p>运行命令成功后，直接访问公网 IP 的 80 端口</p>
<p>后续可以在 conf.d/default.config 中添加反向代理相关配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name www.example.top; #你的申请过证书的域名</span><br><span class="line">    client_max_body_size 64M;</span><br><span class="line">    fastcgi_read_timeout 3600;</span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    try_files $uri $uri&#x2F; @rewrite;</span><br><span class="line">    # ssl on;</span><br><span class="line">    ssl_certificate     &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;certs&#x2F;www.example.top&#x2F;example.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;certs&#x2F;www.example.top&#x2F;example.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        add_header Content-Security-Policy upgrade-insecure-requests;</span><br><span class="line">        proxy_set_header HOST $host;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;172.17.0.5:9001&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="通过-Docker-搭建反向代理-Ngnix，并配置-Https-SSL-证书"><a href="#通过-Docker-搭建反向代理-Ngnix，并配置-Https-SSL-证书" class="headerlink" title="通过 Docker 搭建反向代理 Ngnix，并配置 Https SSL 证书"></a>通过 Docker 搭建反向代理 Ngnix，并配置 Https SSL 证书</h2><p><a href="https://www.exception.site/docker/how-to-config-ssl-with-docker-nginx" target="_blank" rel="noopener">https://www.exception.site/docker/how-to-config-ssl-with-docker-nginx</a></p>
<h2 id="动态设置环境变量"><a href="#动态设置环境变量" class="headerlink" title="动态设置环境变量"></a>动态设置环境变量</h2><p>Dockerfile </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPOSE 30010</span><br><span class="line"></span><br><span class="line">ARG node_env # 新增加</span><br><span class="line">ENV NODE_ENV&#x3D;$node_env  # 新增加</span><br><span class="line">CMD npm run $&#123;NODE_ENV&#125; # 修改</span><br></pre></td></tr></table></figure>

<p>下面对上面的代码做个解释</p>
<ul>
<li>通过 <code>ARG</code> 指令定义了一个变量，用户可以在构建时通过使用 <code>--build-arg =</code> 标志的 <code>docker build</code> 命令将其传递给构建器 <code>ARG node_env</code></li>
<li>在 Dockerfile 中使用 ENV 引用这个变量<code>ENV NODE_ENV=$node_env</code></li>
<li>这一步就是使用了 <code>CMD npm run ${NODE_ENV}</code></li>
</ul>
<p>剩下的就是在构建镜像时动态传入参数了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker image build --build-arg node_env&#x3D;dev -t my-koa-app . # 构建测试环境</span><br><span class="line">$ docker image build --build-arg node_env&#x3D;pro -t my-koa-app . # 构建生产环境</span><br></pre></td></tr></table></figure>


<h2 id="用-Docker-搭建-nodejs-应用"><a href="#用-Docker-搭建-nodejs-应用" class="headerlink" title="用 Docker 搭建 nodejs 应用"></a>用 Docker 搭建 nodejs 应用</h2><h3 id="创建koa项目"><a href="#创建koa项目" class="headerlink" title="创建koa项目"></a>创建koa项目</h3><p>通过koa框架写一个hello-world项目<br>app.js</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line"></span><br><span class="line">app.use(async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#39;Hello World&#39;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<h3 id="创建-Dockerfile-文件"><a href="#创建-Dockerfile-文件" class="headerlink" title="创建 Dockerfile 文件"></a>创建 Dockerfile 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM node:12.16.3-alpine</span><br><span class="line"></span><br><span class="line">LABEL maintainer&#x3D;&quot;SvenDowideit@home.org.au&quot;</span><br><span class="line"></span><br><span class="line"># 在容器中创建一个目录</span><br><span class="line">RUN mkdir -p &#x2F;usr&#x2F;src&#x2F;testApp&#x2F;</span><br><span class="line"></span><br><span class="line"># 定位到容器的工作目录</span><br><span class="line">WORKDIR &#x2F;usr&#x2F;src&#x2F;testApp&#x2F;</span><br><span class="line"></span><br><span class="line"># RUN&#x2F;COPY 是分层的，package.json 提前，只要没修改，就不会重新安装包</span><br><span class="line">COPY .&#x2F;package*.json &#x2F;usr&#x2F;src&#x2F;testApp&#x2F;</span><br><span class="line"></span><br><span class="line">#安装依赖</span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"># 把当前目录下的所有文件拷贝到 Image 的 &#x2F;usr&#x2F;src&#x2F;testApp&#x2F; 目录下</span><br><span class="line">COPY . &#x2F;usr&#x2F;src&#x2F;testApp&#x2F;</span><br><span class="line"></span><br><span class="line">#暴露端口</span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line">#容器启动后执行的命令</span><br><span class="line">CMD node app.js</span><br></pre></td></tr></table></figure>

<h3 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h3><p>有了 Dockerfile 以后，我们可以运行下面的命令构建前端镜像并命名为 my-koa-app：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t my-koa-app .</span><br></pre></td></tr></table></figure>

<h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>最后，让我们从镜像启动容器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">-p 3006:3000 \</span><br><span class="line">-d --name koaApp \</span><br><span class="line">my-koa-app</span><br></pre></td></tr></table></figure>

<p>这样子我们就能从 3006 端口去访问我们的 node 应用。</p>
<h3 id="应用运行优化"><a href="#应用运行优化" class="headerlink" title="应用运行优化"></a>应用运行优化</h3><p>当然， Node 是公认的不稳定，经常会出现服务器内存溢出，而崩溃退出。</p>
<p>我们针对这一点，可以对 koa 启动命令做优化。引入 pm2 插件，通过 pm2 来启动 express 应用。</p>
<blockquote>
<p>使用命令 <code>pm2 start app.js</code> 之后, pm2 默认在后台运行, 如果使用了 Docker 后,容器运行并立即退出,需要手动给“ pm2 ”指定参数 <code>--no-daemon</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM node:12.1.3-alpine</span><br><span class="line"></span><br><span class="line">LABEL maintainer&#x3D;&quot;SvenDowideit@home.org.au&quot;</span><br><span class="line"></span><br><span class="line"># 在容器中创建一个目录</span><br><span class="line">RUN mkdir -p &#x2F;usr&#x2F;src&#x2F;testApp&#x2F;</span><br><span class="line"></span><br><span class="line"># 定位到容器的工作目录</span><br><span class="line">WORKDIR &#x2F;usr&#x2F;src&#x2F;testApp&#x2F;</span><br><span class="line"></span><br><span class="line">RUN npm install -g pm2</span><br><span class="line"></span><br><span class="line"># RUN&#x2F;COPY 是分层的，package.json 提前，只要没修改，就不会重新安装包</span><br><span class="line">COPY .&#x2F;package*.json &#x2F;usr&#x2F;src&#x2F;testApp&#x2F;</span><br><span class="line"></span><br><span class="line">#安装依赖</span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"># 把当前目录下的所有文件拷贝到 Image 的 &#x2F;usr&#x2F;src&#x2F;testApp&#x2F; 目录下</span><br><span class="line">COPY . &#x2F;usr&#x2F;src&#x2F;testApp&#x2F;</span><br><span class="line"></span><br><span class="line">#暴露端口</span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line">#容器启动后执行的命令</span><br><span class="line">CMD pm2 start app.js --no-daemon</span><br></pre></td></tr></table></figure>



<h2 id="用-Docker-搭建-vue-应用-案例一"><a href="#用-Docker-搭建-vue-应用-案例一" class="headerlink" title="用 Docker 搭建 vue 应用 (案例一)"></a>用 Docker 搭建 vue 应用 (案例一)</h2><h3 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h3><p>网上很多docker部署vue项目的教程，其中很多的文章不乏都是先将vue项目执行npm run build 在本地进行打包，传到自己的仓库去，然后到服务器去拉取我们的代码，获取dist文件，再将该文件挂载到dockr容器内。其实这种操作应当是有缺陷的，我们应当把打包的操作也放到docker的镜像里面去操作。</p>
<h3 id="准备好vue项目"><a href="#准备好vue项目" class="headerlink" title="准备好vue项目"></a>准备好vue项目</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue create vueTest</span><br></pre></td></tr></table></figure>

<h3 id="创建-Dockerfile-文件-1"><a href="#创建-Dockerfile-文件-1" class="headerlink" title="创建 Dockerfile 文件"></a>创建 Dockerfile 文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM node:12.16.3-alpine AS builder</span><br><span class="line"></span><br><span class="line"># 将容器的工作目录设置为&#x2F;app(当前目录，如果&#x2F;app不存在，WORKDIR会创建&#x2F;app文件夹)</span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line"></span><br><span class="line">COPY .&#x2F;package*.json &#x2F;app&#x2F; </span><br><span class="line"></span><br><span class="line">#安装依赖</span><br><span class="line">RUN npm config set registry &quot;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;&quot; \</span><br><span class="line">  &amp;&amp; npm install </span><br><span class="line">COPY . &#x2F;app</span><br><span class="line">RUN npm run build </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定nginx配置项目，--from&#x3D;builder 指的是从上一次 build 的结果中提取了编译结果</span><br><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line">#将打包后的文件复制到nginx中</span><br><span class="line">COPY --from&#x3D;builder app&#x2F;dist &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</span><br><span class="line"></span><br><span class="line">#用本地的 default.conf 配置来替换nginx镜像里的默认配置。</span><br><span class="line">COPY --from&#x3D;builder app&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</span><br><span class="line"></span><br><span class="line">#暴露容器80端口</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure>

<p>可以看到，在这里将打包操作也放到Dokcerfile里面进行操作了。</p>
<p><strong>该条命令是将我们在镜像里面打包生成的dist文件放进容器内nginx的web目录下面。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY --from&#x3D;builder app&#x2F;dist &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>该条命令是将我们项目目录下面的nginx.conf文件复制到容器内nginx的配置文件的目录下面，从而覆盖原有的配置文件。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">COPY --from&#x3D;builder app&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="创建-nginx-conf-文件"><a href="#创建-nginx-conf-文件" class="headerlink" title="创建 nginx.conf 文件"></a>创建 nginx.conf 文件</h3><p>在项目根目录下创建nginx文件，该文件夹下新建文件nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    # 开启 gzip</span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_buffers 16 64k;</span><br><span class="line">    gzip_http_version 1.1;</span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    gzip_types text&#x2F;plain application&#x2F;x-javascript application&#x2F;javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png;</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 根目录</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 解决HTML5 History 模式</span><br><span class="line">        try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-dockerignore-文件"><a href="#创建-dockerignore-文件" class="headerlink" title="创建 .dockerignore 文件"></a>创建 .dockerignore 文件</h3><p>在项目根目录下创建.dockerignore，用与忽略镜像打包文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure>

<h3 id="制作镜像-1"><a href="#制作镜像-1" class="headerlink" title="制作镜像"></a>制作镜像</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker image build -t vuetest:1.0 .</span><br></pre></td></tr></table></figure>
<p>-t 是给镜像命名 . 是基于当前目录的Dockerfile来构建镜像</p>
<h3 id="启动容器-1"><a href="#启动容器-1" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-p 3000:80 \</span><br><span class="line">-d --name vueTest \</span><br><span class="line">vuetest</span><br></pre></td></tr></table></figure>

<ul>
<li><code>docker run</code> 基于镜像启动一个容器</li>
<li><code>-p 3000:80</code> 端口映射，将宿主的3000端口映射到容器的80端口</li>
<li><code>-d</code> 后台方式运行</li>
<li><code>--name</code> 容器名 查看 docker 进程</li>
</ul>
<p>可以发现名为 vueTest的容器已经运行起来。此时访问 http://{ip}:3000 应该就能访问到该vue应用:</p>
]]></content>
  </entry>
</search>
