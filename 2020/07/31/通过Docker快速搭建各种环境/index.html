<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Docker 基础教程配置国内镜像加速器Docker 配置国内镜像加速器，加速下载速度 Docker 默认是从官方镜像地址 Docker Hub 下下载镜像，由于服务器在国外的缘故，导致经常下载速度非常慢。为了提升镜像的下载速度，我们可以手动配置国内镜像加速器，让下载速度飚起来。 国内的镜像加速器选项较多，如：阿里云，DaoCloud 等。 本文主要说说如何配置阿里云的镜像加速器。 一、获取加速信">
<meta property="og:type" content="article">
<meta property="og:title" content="通过Docker快速搭建各种环境（全攻略）">
<meta property="og:url" content="http://yoursite.com/2020/07/31/%E9%80%9A%E8%BF%87Docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83/index.html">
<meta property="og:site_name" content="记忆的时间差">
<meta property="og:description" content="Docker 基础教程配置国内镜像加速器Docker 配置国内镜像加速器，加速下载速度 Docker 默认是从官方镜像地址 Docker Hub 下下载镜像，由于服务器在国外的缘故，导致经常下载速度非常慢。为了提升镜像的下载速度，我们可以手动配置国内镜像加速器，让下载速度飚起来。 国内的镜像加速器选项较多，如：阿里云，DaoCloud 等。 本文主要说说如何配置阿里云的镜像加速器。 一、获取加速信">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123229.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123341.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123517.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123820.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123939.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124023.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124249.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124505.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124556.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124709.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731125918.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731125939.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130151.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130309.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130453.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130557.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130743.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130821.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731131108.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731131907.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731131944.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132144.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132300.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132330.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132416.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132541.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132627.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132734.png">
<meta property="og:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132929.png">
<meta property="article:published_time" content="2020-07-31T04:24:44.000Z">
<meta property="article:modified_time" content="2020-07-31T04:24:44.000Z">
<meta property="article:author" content="king">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123229.png">

<link rel="canonical" href="http://yoursite.com/2020/07/31/%E9%80%9A%E8%BF%87Docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>通过Docker快速搭建各种环境（全攻略） | 记忆的时间差</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">记忆的时间差</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">实践是检验真理的唯一标准</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-作品">

    <a href="/project/" rel="section"><i class="fa fa-fw fa-th"></i>作品</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/31/%E9%80%9A%E8%BF%87Docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%90%84%E7%A7%8D%E7%8E%AF%E5%A2%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tx.jpg">
      <meta itemprop="name" content="king">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="记忆的时间差">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          通过Docker快速搭建各种环境（全攻略）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-07-31 12:24:44" itemprop="dateCreated datePublished" datetime="2020-07-31T12:24:44+08:00">2020-07-31</time>
            </span>

          
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
              <span>15k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
              <span>14 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Docker-基础教程"><a href="#Docker-基础教程" class="headerlink" title="Docker 基础教程"></a>Docker 基础教程</h2><h3 id="配置国内镜像加速器"><a href="#配置国内镜像加速器" class="headerlink" title="配置国内镜像加速器"></a>配置国内镜像加速器</h3><p>Docker 配置国内镜像加速器，加速下载速度</p>
<p>Docker 默认是从官方镜像地址 Docker Hub 下下载镜像，由于服务器在国外的缘故，导致经常下载速度非常慢。为了提升镜像的下载速度，我们可以手动配置国内镜像加速器，让下载速度飚起来。</p>
<p>国内的镜像加速器选项较多，如：阿里云，DaoCloud 等。</p>
<p>本文主要说说如何配置阿里云的镜像加速器。</p>
<h4 id="一、获取加速信息"><a href="#一、获取加速信息" class="headerlink" title="一、获取加速信息"></a>一、获取加速信息</h4><ul>
<li><p>1、首先你需要注册一个阿里云账号，没有的话，通过下面的连接跳转注册：<br><a href="https://dev.aliyun.com/" target="_blank" rel="noopener">https://dev.aliyun.com/</a></p>
</li>
<li><p>2、跳转镜像加速页 <a href="https://cr.console.aliyun.com/，获取加速配置信息：" target="_blank" rel="noopener">https://cr.console.aliyun.com/，获取加速配置信息：</a></p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123229.png" alt=""></p>
<a id="more"></a>

<h4 id="二、配置-Docker"><a href="#二、配置-Docker" class="headerlink" title="二、配置 Docker"></a>二、配置 Docker</h4><p><strong>确定 Docker Client 版本</strong></p>
<p>在配置之前，首先需要确定 Docker Client 的版本，推荐是 1.10.0+:</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123341.png" alt=""></p>
<p><strong>配置镜像加速器</strong><br>通过修改 daemon 配置文件 <code>/etc/docker/daemon.json</code> 来使用加速器：</p>
<p>执行下面命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p &#x2F;etc&#x2F;docker</span><br><span class="line">sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-&#39;EOF&#39;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https:&#x2F;&#x2F;bjtzu1jb.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h4 id="三、验证速度"><a href="#三、验证速度" class="headerlink" title="三、验证速度"></a>三、验证速度</h4><p>以下载 mongodb 为例，看下速度：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123517.png" alt=""></p>
<p>配置了加速器过后，速度终于飚起来了。</p>
<h3 id="Docker-下载镜像"><a href="#Docker-下载镜像" class="headerlink" title="Docker 下载镜像"></a>Docker 下载镜像</h3><h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>大家都知道，镜像是 Docker 三大核心概念中最重要的。如果我们想要在本地运行容器，就必须保证本地存在对应的镜像。所以，第一步，我们需要下载镜像。当我们尝试下载镜像时，Docker 会尝试先从默认的镜像仓库（默认使用 Docker Hub 公共仓库）去下载，当然了，用户也可以自定义配置想要下载的镜像仓库。</p>
<h4 id="二、下载镜像"><a href="#二、下载镜像" class="headerlink" title="二、下载镜像"></a>二、下载镜像</h4><p>镜像是运行容器的前提，我们可以使用 <code>docker pull [IMAGE_NAME]:[TAG]</code>命令来下载镜像，其中 <code>IMAGE_NAME</code> 表示的是镜像的名称，而 <code>TAG</code> 是镜像的标签，也就是说我们需要通过 “镜像 + 标签” 的方式来下载镜像。</p>
<blockquote>
<p>注意：您也可以不显式地指定 TAG, 它会默认下载 latest 标签，也就是下载仓库中最新版本的镜像。这里并不推荐您下载 latest 标签，因为该镜像的内容会跟踪镜像的最新版本，并随之变化，所以它是不稳定的。在生产环境中，可能会出现莫名其妙的 bug, 推荐您最好还是显示的指定具体的 TAG。</p>
</blockquote>
<p>举个例子，如我们想要下载一个 <code>Mysql 5.7</code> 镜像，可以通过命令来下载：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>

<p>会看到控制台输出内容如下：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123820.png" alt=""></p>
<p>当有 <strong>Downloaded</strong> 字符串输出的时候，说明下载成功了！！</p>
<h4 id="三、验证镜像"><a href="#三、验证镜像" class="headerlink" title="三、验证镜像"></a>三、验证镜像</h4><p>让我们来验证一下，本地是否存在 Mysql5.7 的镜像，运行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731123939.png" alt=""></p>
<p>可以看到本地的确存在该镜像，确实是下载成功了！</p>
<h4 id="四、下载镜像相关细节"><a href="#四、下载镜像相关细节" class="headerlink" title="四、下载镜像相关细节"></a>四、下载镜像相关细节</h4><p>再说说上面下载镜像的过程：<br><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124023.png" alt=""></p>
<p>通过下载过程，可以看到，一个镜像一般是由多个层（layer） 组成，类似 f7e2b70d04ae这样的串表示层的唯一 ID。</p>
<p>您可能会想，如果多个不同的镜像中，同时包含了同一个层（layer）,这样重复下载，岂不是导致了存储空间的浪费么?</p>
<p>实际上，Docker 并不会这么傻会去下载重复的层（layer）,Docker 在下载之前，会去检测本地是否会有同样 ID 的层，如果本地已经存在了，就直接使用本地的就好了。</p>
<h3 id="Docker-查看镜像信息"><a href="#Docker-查看镜像信息" class="headerlink" title="Docker 查看镜像信息"></a>Docker 查看镜像信息</h3><h4 id="一、images-命令列出镜像"><a href="#一、images-命令列出镜像" class="headerlink" title="一、images 命令列出镜像"></a>一、images 命令列出镜像</h4><p>通过使用如下两个命令，列出本机已有的镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>或：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image ls</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124249.png" alt=""></p>
<p>对上述红色标注的字段做一下解释：</p>
<ul>
<li><strong>REPOSITORY</strong>: 来自于哪个仓库；</li>
<li><strong>TAG</strong>: 镜像的标签信息，比如 5.7、latest 表示不同的版本信息；</li>
<li><strong>IMAGE ID</strong>: 镜像的 ID, 如果您看到两个 ID 完全相同，那么实际上，它们指向的是同一个镜像，只是标签名称不同罢了；</li>
<li><strong>CREATED</strong>: 镜像最后的更新时间；</li>
<li><strong>SIZE</strong>: 镜像的大小，优秀的镜像一般体积都比较小，这也是我更倾向于使用轻量级的 alpine 版本的原因</li>
</ul>
<h4 id="二、使用-tag-命令为镜像添加标签"><a href="#二、使用-tag-命令为镜像添加标签" class="headerlink" title="二、使用 tag 命令为镜像添加标签"></a>二、使用 tag 命令为镜像添加标签</h4><p>通常情况下，为了方便在后续工作中，快速地找到某个镜像，我们可以使用 docker tag 命令，为本地镜像添加一个新的标签。如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124505.png" alt=""></p>
<p>为 <code>docker.io/mysql</code> 镜像，添加新的镜像标签 <code>allen_mysql:5.7</code>。然后使用 <code>docker images</code> 命令，查看本地镜像：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124556.png" alt=""></p>
<p>可以看到，本地多了一个 allen_mysql:5.7 的镜像。细心的你一定还会发现，allen_mysql:5.7 和 docker.io/mysql:5.7 的镜像 ID 是一模一样的，说明它们是同一个镜像，只是别名不同而已。</p>
<p>docker tag 命令功能更像是, 为指定镜像添加快捷方式一样。</p>
<h4 id="三、使用-inspect-命令查看镜像详细信息"><a href="#三、使用-inspect-命令查看镜像详细信息" class="headerlink" title="三、使用 inspect 命令查看镜像详细信息"></a>三、使用 inspect 命令查看镜像详细信息</h4><p>通过 <code>docker inspect</code> 命令，我们可以获取镜像的详细信息，其中，包括创建者，各层的数字摘要等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect docker.io&#x2F;mysql:5.7</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731124709.png" alt=""></p>
<p>docker inspect 返回的是 JSON 格式的信息，如果您想获取其中指定的一项内容，可以通过 -f 来指定，如获取镜像大小：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f &#123;&#123;&quot;.Size&quot;&#125;&#125; docker.io&#x2F;mysql:5.7</span><br></pre></td></tr></table></figure>

<h3 id="Docker-搜索镜像"><a href="#Docker-搜索镜像" class="headerlink" title="Docker 搜索镜像"></a>Docker 搜索镜像</h3><h4 id="一、search-命令"><a href="#一、search-命令" class="headerlink" title="一、search 命令"></a>一、search 命令</h4><p>您可以通过下面命令进行搜索：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search [option] keyword</span><br></pre></td></tr></table></figure>

<p>比如，您想搜索仓库中 mysql 相关的镜像，可以输入如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure>

<h4 id="二、search-子命令"><a href="#二、search-子命令" class="headerlink" title="二、search 子命令"></a>二、search 子命令</h4><p>命令行输入 <code>docker search --help</code>, 输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Usage:  docker search [OPTIONS] TERM</span><br><span class="line"></span><br><span class="line">Search the Docker Hub for images</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --help            Print usage</span><br><span class="line">      --limit int       Max number of search results (default 25)</span><br><span class="line">      --no-index        Don&#39;t truncate output</span><br><span class="line">      --no-trunc        Don&#39;t truncate output</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>search</code> 支持的子命令有：</p>
<ul>
<li><code>-f, --filter filter</code>: 过滤输出的内容；</li>
<li><code>--limit int</code>：指定搜索内容展示个数;</li>
<li><code>--no-index</code>: 不截断输出内容；</li>
<li><code>--no-trunc</code>：不截断输出内容；</li>
</ul>
<p>比如我们想搜索官方提供的 mysql 镜像，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search --filter&#x3D;is-offical&#x3D;true mysql</span><br></pre></td></tr></table></figure>

<p>比如，我们想搜索 Stars 数超过 100 的 mysql 镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search --filter&#x3D;stars&#x3D;100 mysql</span><br></pre></td></tr></table></figure>

<h3 id="Docker-删除-amp-清理镜像"><a href="#Docker-删除-amp-清理镜像" class="headerlink" title="Docker 删除&amp;清理镜像"></a>Docker 删除&amp;清理镜像</h3><h4 id="一、通过标签删除镜像"><a href="#一、通过标签删除镜像" class="headerlink" title="一、通过标签删除镜像"></a>一、通过标签删除镜像</h4><p>以下两种命令均可删除镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [image]</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [image]</span><br></pre></td></tr></table></figure>

<p>支持的子命令如下：</p>
<ul>
<li><code>-f, -force</code>: 强制删除镜像，即便有容器引用该镜像；</li>
<li><code>-no-prune</code>: 不要删除未带标签的父镜像；</li>
</ul>
<p>例如，我们想删除上章节创建的 allen_mysql:5.7 镜像，命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi allen_mysql:5.7</span><br></pre></td></tr></table></figure>

<h4 id="二、通过-ID-删除镜像"><a href="#二、通过-ID-删除镜像" class="headerlink" title="二、通过 ID 删除镜像"></a>二、通过 ID 删除镜像</h4><p>除了通过标签名称来删除镜像，我们还可以通过制定镜像 ID, 来删除镜像，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi ee7cbd482336</span><br></pre></td></tr></table></figure>
<p>一旦制定了通过 ID 来删除镜像，它会先尝试删除所有指向该镜像的标签，然后在删除镜像本身。</p>
<h4 id="三、删除镜像的限制"><a href="#三、删除镜像的限制" class="headerlink" title="三、删除镜像的限制"></a>三、删除镜像的限制</h4><p>删除镜像很简单，但也不是我们何时何地都能删除的，它存在一些限制条件。</p>
<p>当通过该镜像创建的容器未被销毁时，镜像是无法被删除的。</p>
<p>正确的做法应该是：</p>
<ul>
<li>先删除引用这个镜像的容器；</li>
<li>再删除这个镜像；</li>
</ul>
<h4 id="四、清理镜像"><a href="#四、清理镜像" class="headerlink" title="四、清理镜像"></a>四、清理镜像</h4><p>我们在使用 Docker 一段时间后，系统一般都会残存一些临时的、没有被使用的镜像文件，可以通过以下命令进行清理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image prune</span><br></pre></td></tr></table></figure>
<p>它支持的子命令有：</p>
<ul>
<li><code>-a, --all</code>: 删除所有没有用的镜像，而不仅仅是临时文件；</li>
<li><code>-f, --force</code>：强制删除镜像文件，无需弹出提示确认；</li>
</ul>
<p>另外，执行完 docker image prune 命令后，还是告诉我们释放了多少存储空间！</p>
<h3 id="Docker-创建镜像"><a href="#Docker-创建镜像" class="headerlink" title="Docker 创建镜像"></a>Docker 创建镜像</h3><p>Docker 创建镜像主要有三种：</p>
<ul>
<li>基于已有的镜像创建；</li>
<li>基于 Dockerfile 来创建；</li>
<li>基于本地模板来导入；</li>
</ul>
<p>我们将主要介绍常用的 1，2 两种。</p>
<h4 id="一、基于已有的镜像创建"><a href="#一、基于已有的镜像创建" class="headerlink" title="一、基于已有的镜像创建"></a>一、基于已有的镜像创建</h4><p>通过如下命令来创建：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container commit</span><br></pre></td></tr></table></figure>

<p>支持的子命令如下：</p>
<ul>
<li><code>-a, --author=&quot;&quot;</code>: 作者信息；</li>
<li><code>-c, --change=[]</code>: 可以在提交的时候执行 Dockerfile 指令，如 <code>CMD、ENTRYPOINT、ENV、EXPOSE、LABEL、ONBUILD、- USER、VOLUME、WORIR</code> 等；</li>
<li><code>-m, --message=&quot;&quot;</code>: 提交信息；</li>
<li><code>-p, --pause=true</code>: 提交时，暂停容器运行。</li>
</ul>
<p>接下来，基于本地已有的 Ubuntu 镜像，创建一个新的镜像：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731125918.png" alt=""></p>
<p>首先，让我将它运行起来，并在其中创建一个 test.txt 文件：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731125939.png" alt=""></p>
<p>命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it docker.io&#x2F;ubuntu:latest &#x2F;bin&#x2F;bash</span><br><span class="line">root@a0a0c8cfec3a:&#x2F;# touch test.txt</span><br><span class="line">root@a0a0c8cfec3a:&#x2F;# exit</span><br></pre></td></tr></table></figure>

<p>创建完 test.txt 文件后，需要记住标注的容器 ID: a0a0c8cfec3a, 用它来提交一个新的镜像(PS: 你也可以通过名称来提交镜像，这里只演示通过 ID 的方式)。</p>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container commit -m &quot;Added test.txt file&quot; -a &quot;Allen&quot; a0a0c8cfec3a test:0.1</span><br></pre></td></tr></table></figure>

<p>提交成功后，会返回新创建的镜像 ID 信息，如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130151.png" alt=""></p>
<p>再次查看本地镜像信息，可以看到新创建的 test:0.1 镜像了：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130309.png" alt=""></p>
<h4 id="二、基于-Dockerfile-来创建镜像"><a href="#二、基于-Dockerfile-来创建镜像" class="headerlink" title="二、基于 Dockerfile 来创建镜像"></a>二、基于 Dockerfile 来创建镜像</h4><p>通过 Dockerfile 的方式来创建镜像，是最常见的一种方式了，也是比较推荐的方式。Dockerfile 是一个文本指令文件，它描述了是如何基于一个父镜像，来创建一个新镜像的过程。</p>
<p>下面让我们来编写一个简单的 Dockerfile 文件，它描述了基于 Ubuntu 父镜像，安装 Python3 环境的镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM docker.io/ubuntu:latest</span><br><span class="line"></span><br><span class="line">LABEL version="1.0" maintainer="Allen &lt;weiwosuo@github&gt;"</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; \</span><br><span class="line">    apt-get install -y python3 &amp;&amp; \</span><br><span class="line">    apt-get clean &amp;&amp; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/*</span><br></pre></td></tr></table></figure>

<p>创建完成后，通过这个 Dockerfile 文件，来构建新的镜像，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t python:3 .</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：命令的最后有个点，如果不加的话，会构建不成功 ！</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130453.png" alt=""></p>
<p>编译成功后，再次查看本地镜像信息，就可以看到新构建的 python:3 镜像了。</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130557.png" alt=""></p>
<h3 id="Docker-导出-amp-加载镜像"><a href="#Docker-导出-amp-加载镜像" class="headerlink" title="Docker 导出&amp;加载镜像"></a>Docker 导出&amp;加载镜像</h3><p>当我们需要将镜像分享给别人时，可以将镜像导出成 tar 包，别人直接通过加载这个 tar 包，快速地将镜像引入到本地镜像库。</p>
<p>要想使用这两个功能，主要是通过如下两个命令：</p>
<ul>
<li>docker save</li>
<li>docker load</li>
</ul>
<h4 id="一、导出镜像"><a href="#一、导出镜像" class="headerlink" title="一、导出镜像"></a>一、导出镜像</h4><p>查看本地镜像如下：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130743.png" alt=""></p>
<p>例如，我们想要将 python:3 镜像导出来，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save -o python_3.tar python:3</span><br></pre></td></tr></table></figure>

<p>执行成功后，查看当前目录：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731130821.png" alt=""></p>
<p>可以看到 python_3.tar 镜像文件已经生成。接下来，你可以将它通过复制的方式，分享给别人了！</p>
<h4 id="二、加载镜像"><a href="#二、加载镜像" class="headerlink" title="二、加载镜像"></a>二、加载镜像</h4><p>别人拿到了这个 tar 包后，要如何导入到本地的镜像库呢？</p>
<p>通过执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i python_3.tar</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load &lt; python_3.tar</span><br></pre></td></tr></table></figure>

<p>导入成功后，查看本地镜像信息，你就可以获得别人分享的镜像了！</p>
<h3 id="容器使用"><a href="#容器使用" class="headerlink" title="容器使用"></a>容器使用</h3><h4 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h4><p>如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure>

<h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>-i</code>: 交互式操作。</li>
<li><code>-t</code>: 终端。</li>
<li><code>ubuntu</code>: ubuntu 镜像。</li>
<li><code>/bin/bash</code>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li>
</ul>
<p>要退出终端，直接输入 exit:</p>
<h4 id="启动已停止运行的容器"><a href="#启动已停止运行的容器" class="headerlink" title="启动已停止运行的容器"></a>启动已停止运行的容器</h4><p>查看所有的容器命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p>使用 <code>docker start</code> 启动一个已停止的容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start b750bbbcfd88</span><br></pre></td></tr></table></figure>
<h4 id="后台运行"><a href="#后台运行" class="headerlink" title="后台运行"></a>后台运行</h4><p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 <code>-d</code> 指定容器的运行模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -itd --name ubuntu-test ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<p>注：加了 -d 参数默认不会进入容器，想要进入容器需要使用指令 docker exec</p>
<h4 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h4><p>停止容器的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure>
<p>停止的容器可以通过 docker restart 重启：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart &lt;容器 ID&gt;</span><br></pre></td></tr></table></figure>
<h4 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h4><p>在使用 <code>-d</code> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p>
<p><strong>docker exec：</strong><br>推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it 243c32535da7 &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>
<h4 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h4><p><strong>导出容器</strong><br>如果要导出本地某个容器，可以使用 docker export 命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker export 1e560fca3906 &gt; ubuntu.tar</span><br></pre></td></tr></table></figure>
<p><strong>导入容器</strong></p>
<p>可以使用 <code>docker import</code> 从容器快照文件中再导入为镜像，以下实例将快照文件 <code>ubuntu.tar</code> 导入到镜像 <code>test/ubuntu:v1:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1</span><br></pre></td></tr></table></figure>

<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><p>删除容器使用 <code>docker rm</code> 命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f 1e560fca3906</span><br></pre></td></tr></table></figure>

<h4 id="清理容器"><a href="#清理容器" class="headerlink" title="清理容器"></a>清理容器</h4><p>下面的命令可以清理掉所有处于终止状态的容器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure>

<h4 id="查看容器日志"><a href="#查看容器日志" class="headerlink" title="查看容器日志"></a>查看容器日志</h4><figure class="highlight docker"><figcaption><span>logs [ID或者名字]``` 可以查看容器内部的标准输出。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">``` js</span><br><span class="line">docker logs -f bf08b7f2cd89</span><br></pre></td></tr></table></figure>

<h4 id="检查容器详细信息inspect"><a href="#检查容器详细信息inspect" class="headerlink" title="检查容器详细信息inspect"></a>检查容器详细信息inspect</h4><p>使用 <code>docker inspect</code> 来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect wizardly_chandrasekhar</span><br></pre></td></tr></table></figure>


<h2 id="常用环境安装篇"><a href="#常用环境安装篇" class="headerlink" title="常用环境安装篇"></a>常用环境安装篇</h2><h3 id="Mysql-环境"><a href="#Mysql-环境" class="headerlink" title="Mysql 环境"></a>Mysql 环境</h3><h4 id="一、下载-Mysql-镜像"><a href="#一、下载-Mysql-镜像" class="headerlink" title="一、下载 Mysql 镜像"></a>一、下载 Mysql 镜像</h4><p>这里以 Mysql 5.7 为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:5.7</span><br></pre></td></tr></table></figure>
<p>下载完成后，通过 docker images 检查一下镜像是否下载成功:</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731131108.png" alt=""></p>
<h4 id="二、正式运行-Mysql-容器："><a href="#二、正式运行-Mysql-容器：" class="headerlink" title="二、正式运行 Mysql 容器："></a>二、正式运行 Mysql 容器：</h4><p>正式运行 Mysql 容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mysql \</span><br><span class="line">-p 3306:3306 \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;config&#x2F;mysqld.cnf:&#x2F;etc&#x2F;mysql&#x2F;mysql.conf.d&#x2F;mysqld.cnf \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mysql&#x2F;data&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD&#x3D;123456 \</span><br><span class="line">mysql:5.7</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-d</code>：以后台的方式运行；</li>
<li><code>--name mysql</code>：指定容器的名称为 mysql;</li>
<li><code>-p 3306:3306</code> 将容器的 3306 端口挂载到宿主机的 3306 端口上；</li>
<li><code>-e MYSQL_ROOT_PASSWORD=123456</code>：指定 root 的密码为 123456</li>
<li><code>-v /usr/local/docker/mysql/config/mysqld.cnf:/etc/mysql/mysql.conf.d/mysqld.cnf</code>: 将容器中 /etc/mysql/mysql.conf.d/mysqld.cnf 配置文件挂载到宿主机的 /usr/local/docker/mysql/config/mysqld.cnf 文件上；</li>
<li><code>-v /usr/local/docker/mysql/data:/var/lib/mysql</code>: 将容器中 /var/lib/mysql 数据目录挂载到宿主机的 /usr/local/docker/mysql/data 目录下；</li>
</ul>
<p>执行命令完成后，查看下容器是否启动：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731131907.png" alt=""></p>
<h4 id="三、通过-Mysql-客户端连接一下试试"><a href="#三、通过-Mysql-客户端连接一下试试" class="headerlink" title="三、通过 Mysql 客户端连接一下试试"></a>三、通过 Mysql 客户端连接一下试试</h4><p>通过 MySQL 客户端连接刚刚创建的 mysql, 看看能否连接成功：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731131944.png" alt=""></p>
<p>连接成功了！</p>
<h4 id="相关问题补充"><a href="#相关问题补充" class="headerlink" title="相关问题补充"></a>相关问题补充</h4><p><strong>时区不对问题</strong></p>
<p>在向数据库插入数据时，总是发现时间比系统时间少 8 个小时，这是因为 Mysql 的时区并不是我们想要的东八区。</p>
<p>解决方案：我们可以在上面说到的，挂载到宿主机的 Mysql 配置文件 mysqld.cnf 中，添加如下参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">default-time-zone &#x3D; &#39;+08:00&#39;</span><br></pre></td></tr></table></figure>

<p>添加改配置后，重启 MySQL 容器, 再插入数据，就发现时间正常了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart your_mysql_container_name</span><br></pre></td></tr></table></figure>

<h3 id="Redis-环境"><a href="#Redis-环境" class="headerlink" title="Redis 环境"></a>Redis 环境</h3><h4 id="一、下载-Redis-镜像"><a href="#一、下载-Redis-镜像" class="headerlink" title="一、下载 Redis 镜像"></a>一、下载 Redis 镜像</h4><p>首先拉取 Redis 镜像, 这里我选择的是 <code>redis:alpine</code> 轻量级镜像版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis:alpine</span><br></pre></td></tr></table></figure>
<p>下载完成后，通过 docker images 确认镜像是否已经下载到本地：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132144.png" alt=""></p>
<h4 id="二、运行-Redis-容器"><a href="#二、运行-Redis-容器" class="headerlink" title="二、运行 Redis 容器"></a>二、运行 Redis 容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-p 6379:6379 \</span><br><span class="line">--name redis \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;redis&#x2F;redis.conf:&#x2F;etc&#x2F;redis&#x2F;redis.conf \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;redis&#x2F;data:&#x2F;data \</span><br><span class="line">-d redis:alpine \</span><br><span class="line">redis-server &#x2F;etc&#x2F;redis&#x2F;redis.conf --appendonly yes --requirepass &quot;mypassword&quot;</span><br></pre></td></tr></table></figure>

<p>命令说明：</p>
<ul>
<li><code>-p 6379:6379</code>: 将容器的 6379 端口映射到宿主机的 6379 端口；</li>
<li><code>-v /usr/local/docker/redis/data:/data</code> : 将容器中的 /data 数据存储目录, 挂载到宿主机中 /usr/local/docker/redis/data 目录下；</li>
<li><code>-v /usr/local/docker/redis/redis.conf:/etc/redis/redis.conf</code> ： 将容器中 /etc/redis/redis.conf 配置文件，挂载到宿主机的 /usr/local/docker/redis/redis.conf 文件上；</li>
<li><code>redis-server --appendonly yes --requirepass &quot;mypassword&quot;</code>: 在容器执行 redis-server 启动命令，并打开 redis 持久化配置, 以及设置密码;</li>
</ul>
<p>命令运行完成后，查看容器是否启动成功：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132300.png" alt=""></p>
<h4 id="三、连接刚刚创建好的容器"><a href="#三、连接刚刚创建好的容器" class="headerlink" title="三、连接刚刚创建好的容器"></a>三、连接刚刚创建好的容器</h4><p>执行如下命令，连接 redis：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it redis:alpine redis-cli -h 172.17.0.1</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132330.png" alt=""></p>
<h3 id="MongDB-环境"><a href="#MongDB-环境" class="headerlink" title="MongDB 环境"></a>MongDB 环境</h3><h4 id="一、下载-MongoDB-镜像"><a href="#一、下载-MongoDB-镜像" class="headerlink" title="一、下载 MongoDB 镜像"></a>一、下载 MongoDB 镜像</h4><p>这里以 mongo 4 版本为例，下载镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mongo:4</span><br></pre></td></tr></table></figure>

<p>下载完成后，确认一下镜像是否下载成功:</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132416.png" alt=""></p>
<h4 id="二、运行-MongoDB-镜像"><a href="#二、运行-MongoDB-镜像" class="headerlink" title="二、运行 MongoDB 镜像"></a>二、运行 MongoDB 镜像</h4><p>下载成功后，运行 mongoDB 镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--name mongo \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mongo&#x2F;configdb:&#x2F;data&#x2F;configdb \</span><br><span class="line">-v &#x2F;usr&#x2F;local&#x2F;docker&#x2F;mongo&#x2F;data:&#x2F;data&#x2F;db \</span><br><span class="line">-p 27017:27017 \</span><br><span class="line">mongo:4 \</span><br><span class="line">--auth</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-d</code>: 以后台的方式运行；</li>
<li><code>--name mongo</code>: 指定容器名称为 mongo;</li>
<li><code>-v /usr/local/docker/mongo/configdb:/data/configdb</code>: 将容器中 /data/configdb 目录挂载到宿主机的 /usr/local/docker/mongo/configdb 目录下；</li>
<li><code>-v /usr/local/docker/mongo/data:/data/db</code>: 将容器中 /data/db 数据目录挂载到宿主机的 /usr/local/docker/mongo/data 目录下；</li>
<li>-p <code>27017:27017</code>: 将容器的 27017 端口映射到宿主机的 27017 端口；</li>
</ul>
<p>执行命令完成后，查看下容器是否启动：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132541.png" alt=""></p>
<h4 id="三、添加管理员账号"><a href="#三、添加管理员账号" class="headerlink" title="三、添加管理员账号"></a>三、添加管理员账号</h4><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it mongo mongo admin</span><br></pre></td></tr></table></figure>

<p>然后，创建一个拥有最高权限 root 账号:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.createUser(&#123; user: &#39;admin&#39;, pwd: &#39;123456&#39;, roles: [ &#123; role: &quot;root&quot;, db: &quot;admin&quot; &#125; ] &#125;);</span><br></pre></td></tr></table></figure>

<p>创建成功后，你会看到 Successfully added user:</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132627.png" alt=""></p>
<h4 id="四、用新创建的-root-账户连接，测试一下"><a href="#四、用新创建的-root-账户连接，测试一下" class="headerlink" title="四、用新创建的 root 账户连接，测试一下"></a>四、用新创建的 root 账户连接，测试一下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --link mongo:mongo mongo mongo -u admin -p 123456 --authenticationDatabase admin mongo&#x2F;admin</span><br></pre></td></tr></table></figure>
<p>连接成功后，我们可以执行相关 sql：</p>
<p><strong>显示所有的数据库：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show dbs</span><br></pre></td></tr></table></figure>

<p><strong>使用某个数据库：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use admin</span><br></pre></td></tr></table></figure>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132734.png" alt=""></p>
<p>输入命令 exit，退出连接！</p>
<h3 id="Ngnix-环境"><a href="#Ngnix-环境" class="headerlink" title="Ngnix 环境"></a>Ngnix 环境</h3><h4 id="一、下载-Nginx-镜像"><a href="#一、下载-Nginx-镜像" class="headerlink" title="一、下载 Nginx 镜像"></a>一、下载 Nginx 镜像</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:alpine</span><br></pre></td></tr></table></figure>

<blockquote>
<p>PS：我这里用的是 alipne 轻量级的镜像.</p>
</blockquote>
<p>下载完成后，通过 docker images 命令检查一下镜像是否下载成功：</p>
<p><img src="https://raw.githubusercontent.com/freekingg/king-static/master/20200731132929.png" alt=""></p>
<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \ </span><br><span class="line">-p 80:80 \ </span><br><span class="line">--name nginx \</span><br><span class="line">-v &#x2F;docker&#x2F;nginx&#x2F;nginx.conf:&#x2F;etc&#x2F;nginx&#x2F;nginx.conf \</span><br><span class="line">-v &#x2F;docker&#x2F;nginx&#x2F;conf.d:&#x2F;etc&#x2F;nginx&#x2F;conf.d \</span><br><span class="line">-v &#x2F;docker&#x2F;nginx&#x2F;logs:&#x2F;var&#x2F;log&#x2F;nginx \</span><br><span class="line">nginx:alpine</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>-d</code>: 以后台方式运行镜像；</li>
<li><code>--name</code>: 指定容器的名称为 nginx;</li>
<li><code>-p 80:80</code>：将容器的 80 端口映射到主机的 80 端口；</li>
<li>`-v /docker/nginx/nginx.conf:/etc/nginx/nginx.conf：将容器中的 /etc/nginx/nginx.conf 文件挂载到宿主机中的 /docker/nginx/nginx.conf 文件；</li>
<li><code>-v /docker/nginx/conf.d:/etc/nginx/conf.d</code>：将容器中 /etc/nginx/conf.d 目录挂载到宿主机中的 conf.d 目录下；</li>
<li><code>-v /docker/nginx/logs:/var/log/nginx</code>：将容器中的 /var/log/nginx 目录挂载到宿主机中的 /docker/nginx/logs 目录下, 用以查看 Nginx 日志；</li>
</ul>
<p>运行命令成功后，直接访问公网 IP 的 80 端口</p>
<p>后续可以在 conf.d/default.config 中添加反向代理相关配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name www.example.top; #你的申请过证书的域名</span><br><span class="line">    client_max_body_size 64M;</span><br><span class="line">    fastcgi_read_timeout 3600;</span><br><span class="line">    error_page   500 502 503 504  &#x2F;50x.html;</span><br><span class="line">    root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">    try_files $uri $uri&#x2F; @rewrite;</span><br><span class="line">    # ssl on;</span><br><span class="line">    ssl_certificate     &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;certs&#x2F;www.example.top&#x2F;example.pem;</span><br><span class="line">    ssl_certificate_key &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;certs&#x2F;www.example.top&#x2F;example.key;</span><br><span class="line">    ssl_session_timeout 5m;</span><br><span class="line">    ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #按照这个协议配置</span><br><span class="line">    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;#按照这个套件配置</span><br><span class="line">    ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        add_header Content-Security-Policy upgrade-insecure-requests;</span><br><span class="line">        proxy_set_header HOST $host;</span><br><span class="line">        proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;172.17.0.5:9001&#x2F;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="通过-Docker-搭建反向代理-Ngnix，并配置-Https-SSL-证书"><a href="#通过-Docker-搭建反向代理-Ngnix，并配置-Https-SSL-证书" class="headerlink" title="通过 Docker 搭建反向代理 Ngnix，并配置 Https SSL 证书"></a>通过 Docker 搭建反向代理 Ngnix，并配置 Https SSL 证书</h2><p><a href="https://www.exception.site/docker/how-to-config-ssl-with-docker-nginx" target="_blank" rel="noopener">https://www.exception.site/docker/how-to-config-ssl-with-docker-nginx</a></p>
<h2 id="动态设置环境变量"><a href="#动态设置环境变量" class="headerlink" title="动态设置环境变量"></a>动态设置环境变量</h2><p>Dockerfile </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE 30010</span><br><span class="line"></span><br><span class="line">ARG node_env # 新增加</span><br><span class="line">ENV NODE_ENV&#x3D;$node_env  # 新增加</span><br><span class="line">CMD npm run $&#123;NODE_ENV&#125; # 修改</span><br></pre></td></tr></table></figure>

<p>下面对上面的代码做个解释</p>
<ul>
<li>通过 <code>ARG</code> 指令定义了一个变量，用户可以在构建时通过使用 <code>--build-arg =</code> 标志的 <code>docker build</code> 命令将其传递给构建器 <code>ARG node_env</code></li>
<li>在 Dockerfile 中使用 ENV 引用这个变量<code>ENV NODE_ENV=$node_env</code></li>
<li>这一步就是使用了 <code>CMD npm run ${NODE_ENV}</code></li>
</ul>
<p>剩下的就是在构建镜像时动态传入参数了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker image build --build-arg node_env&#x3D;dev -t my-koa-app . # 构建测试环境</span><br><span class="line">$ docker image build --build-arg node_env&#x3D;pro -t my-koa-app . # 构建生产环境</span><br></pre></td></tr></table></figure>


<h2 id="用-Docker-搭建-nodejs-应用"><a href="#用-Docker-搭建-nodejs-应用" class="headerlink" title="用 Docker 搭建 nodejs 应用"></a>用 Docker 搭建 nodejs 应用</h2><h3 id="创建koa项目"><a href="#创建koa项目" class="headerlink" title="创建koa项目"></a>创建koa项目</h3><p>通过koa框架写一个hello-world项目<br>app.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const Koa &#x3D; require(&#39;koa&#39;);</span><br><span class="line">const app &#x3D; new Koa();</span><br><span class="line"></span><br><span class="line">app.use(async ctx &#x3D;&gt; &#123;</span><br><span class="line">  ctx.body &#x3D; &#39;Hello World&#39;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br></pre></td></tr></table></figure>

<h3 id="创建-Dockerfile-文件"><a href="#创建-Dockerfile-文件" class="headerlink" title="创建 Dockerfile 文件"></a>创建 Dockerfile 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">FROM node:12.16.3-alpine</span><br><span class="line"></span><br><span class="line">LABEL maintainer&#x3D;&quot;SvenDowideit@home.org.au&quot;</span><br><span class="line"></span><br><span class="line"># 在容器中创建一个目录</span><br><span class="line">RUN mkdir -p &#x2F;app&#x2F;</span><br><span class="line"></span><br><span class="line"># 定位到容器的工作目录</span><br><span class="line">WORKDIR &#x2F;app&#x2F;</span><br><span class="line"></span><br><span class="line"># RUN&#x2F;COPY 是分层的，package.json 提前，只要没修改，就不会重新安装包</span><br><span class="line">COPY .&#x2F;package*.json &#x2F;app&#x2F;</span><br><span class="line"></span><br><span class="line">#安装依赖</span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"># 把当前目录下的所有文件拷贝到 Image 的 &#x2F;app&#x2F; 目录下</span><br><span class="line">COPY . &#x2F;app&#x2F;</span><br><span class="line"></span><br><span class="line">#暴露端口</span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line">#容器启动后执行的命令</span><br><span class="line">CMD node app.js</span><br></pre></td></tr></table></figure>

<h3 id="制作镜像"><a href="#制作镜像" class="headerlink" title="制作镜像"></a>制作镜像</h3><p>有了 Dockerfile 以后，我们可以运行下面的命令构建前端镜像并命名为 my-koa-app：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t my-koa-app .</span><br></pre></td></tr></table></figure>

<h3 id="启动容器-1"><a href="#启动容器-1" class="headerlink" title="启动容器"></a>启动容器</h3><p>最后，让我们从镜像启动容器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">docker run \</span><br><span class="line">-p 3006:3000 \</span><br><span class="line">-d --name koaApp \</span><br><span class="line">my-koa-app</span><br></pre></td></tr></table></figure>

<p>这样子我们就能从 3006 端口去访问我们的 node 应用。</p>
<h3 id="应用运行优化"><a href="#应用运行优化" class="headerlink" title="应用运行优化"></a>应用运行优化</h3><p>当然， Node 是公认的不稳定，经常会出现服务器内存溢出，而崩溃退出。</p>
<p>我们针对这一点，可以对 koa 启动命令做优化。引入 pm2 插件，通过 pm2 来启动 express 应用。</p>
<blockquote>
<p>使用命令 <code>pm2 start app.js</code> 之后, pm2 默认在后台运行, 如果使用了 Docker 后,容器运行并立即退出,需要手动给“ pm2 ”指定参数 <code>--no-daemon</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">FROM node:12.1.3-alpine</span><br><span class="line"></span><br><span class="line">LABEL maintainer&#x3D;&quot;SvenDowideit@home.org.au&quot;</span><br><span class="line"></span><br><span class="line"># 在容器中创建一个目录</span><br><span class="line">RUN mkdir -p &#x2F;app&#x2F;</span><br><span class="line"></span><br><span class="line"># 定位到容器的工作目录</span><br><span class="line">WORKDIR &#x2F;usr&#x2F;src&#x2F;testApp&#x2F;</span><br><span class="line"></span><br><span class="line">RUN npm install -g pm2</span><br><span class="line"></span><br><span class="line"># RUN&#x2F;COPY 是分层的，package.json 提前，只要没修改，就不会重新安装包</span><br><span class="line">COPY .&#x2F;package*.json &#x2F;app&#x2F;</span><br><span class="line"></span><br><span class="line">#安装依赖</span><br><span class="line">RUN npm install</span><br><span class="line"></span><br><span class="line"># 把当前目录下的所有文件拷贝到 Image 的 &#x2F;app&#x2F; 目录下</span><br><span class="line">COPY . &#x2F;app&#x2F;</span><br><span class="line"></span><br><span class="line">#暴露端口</span><br><span class="line">EXPOSE 3000</span><br><span class="line"></span><br><span class="line">#容器启动后执行的命令</span><br><span class="line">CMD pm2 start app.js --no-daemon</span><br></pre></td></tr></table></figure>



<h2 id="用-Docker-搭建-vue-应用-案例一"><a href="#用-Docker-搭建-vue-应用-案例一" class="headerlink" title="用 Docker 搭建 vue 应用 (案例一)"></a>用 Docker 搭建 vue 应用 (案例一)</h2><h3 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h3><p>网上很多docker部署vue项目的教程，其中很多的文章不乏都是先将vue项目执行npm run build 在本地进行打包，传到自己的仓库去，然后到服务器去拉取我们的代码，获取dist文件，再将该文件挂载到dockr容器内。其实这种操作应当是有缺陷的，我们应当把打包的操作也放到docker的镜像里面去操作。</p>
<h3 id="准备好vue项目"><a href="#准备好vue项目" class="headerlink" title="准备好vue项目"></a>准备好vue项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create vueTest</span><br></pre></td></tr></table></figure>

<h3 id="创建-Dockerfile-文件-1"><a href="#创建-Dockerfile-文件-1" class="headerlink" title="创建 Dockerfile 文件"></a>创建 Dockerfile 文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FROM node:12.16.3-alpine AS builder</span><br><span class="line"></span><br><span class="line"># 将容器的工作目录设置为&#x2F;app(当前目录，如果&#x2F;app不存在，WORKDIR会创建&#x2F;app文件夹)</span><br><span class="line">WORKDIR &#x2F;app </span><br><span class="line"></span><br><span class="line">COPY .&#x2F;package*.json &#x2F;app&#x2F; </span><br><span class="line"></span><br><span class="line">#安装依赖</span><br><span class="line">RUN npm config set registry &quot;https:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;&quot; \</span><br><span class="line">  &amp;&amp; npm install </span><br><span class="line">COPY . &#x2F;app</span><br><span class="line">RUN npm run build </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#指定nginx配置项目，--from&#x3D;builder 指的是从上一次 build 的结果中提取了编译结果</span><br><span class="line">FROM nginx</span><br><span class="line"></span><br><span class="line">#将打包后的文件复制到nginx中</span><br><span class="line">COPY --from&#x3D;builder app&#x2F;dist &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</span><br><span class="line"></span><br><span class="line">#用本地的 default.conf 配置来替换nginx镜像里的默认配置。</span><br><span class="line">COPY --from&#x3D;builder app&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</span><br><span class="line"></span><br><span class="line">#暴露容器80端口</span><br><span class="line">EXPOSE 80</span><br></pre></td></tr></table></figure>

<p>可以看到，在这里将打包操作也放到Dokcerfile里面进行操作了。</p>
<p><strong>该条命令是将我们在镜像里面打包生成的dist文件放进容器内nginx的web目录下面。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY --from&#x3D;builder app&#x2F;dist &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;</span><br></pre></td></tr></table></figure>

<p><strong>该条命令是将我们项目目录下面的nginx.conf文件复制到容器内nginx的配置文件的目录下面，从而覆盖原有的配置文件。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY --from&#x3D;builder app&#x2F;nginx.conf &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="创建-nginx-conf-文件"><a href="#创建-nginx-conf-文件" class="headerlink" title="创建 nginx.conf 文件"></a>创建 nginx.conf 文件</h3><p>在项目根目录下创建nginx文件，该文件夹下新建文件nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    # 开启 gzip</span><br><span class="line">    gzip  on;</span><br><span class="line">    gzip_min_length 1k;</span><br><span class="line">    gzip_buffers 16 64k;</span><br><span class="line">    gzip_http_version 1.1;</span><br><span class="line">    gzip_comp_level 9;</span><br><span class="line">    gzip_types text&#x2F;plain application&#x2F;x-javascript application&#x2F;javascript text&#x2F;css application&#x2F;xml text&#x2F;javascript application&#x2F;x-httpd-php image&#x2F;jpeg image&#x2F;gif image&#x2F;png;</span><br><span class="line">    gzip_vary on;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        # 根目录</span><br><span class="line">        root   &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 解决HTML5 History 模式</span><br><span class="line">        try_files $uri $uri&#x2F; &#x2F;index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-dockerignore-文件"><a href="#创建-dockerignore-文件" class="headerlink" title="创建 .dockerignore 文件"></a>创建 .dockerignore 文件</h3><p>在项目根目录下创建.dockerignore，用与忽略镜像打包文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.git</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br></pre></td></tr></table></figure>

<h3 id="制作镜像-1"><a href="#制作镜像-1" class="headerlink" title="制作镜像"></a>制作镜像</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t vuetest:1.0 .</span><br></pre></td></tr></table></figure>
<p>-t 是给镜像命名 . 是基于当前目录的Dockerfile来构建镜像</p>
<h3 id="启动容器-2"><a href="#启动容器-2" class="headerlink" title="启动容器"></a>启动容器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-p 3000:80 \</span><br><span class="line">-d --name vueTest \</span><br><span class="line">vuetest</span><br></pre></td></tr></table></figure>

<ul>
<li><code>docker run</code> 基于镜像启动一个容器</li>
<li><code>-p 3000:80</code> 端口映射，将宿主的3000端口映射到容器的80端口</li>
<li><code>-d</code> 后台方式运行</li>
<li><code>--name</code> 容器名 查看 docker 进程</li>
</ul>
<p>可以发现名为 vueTest的容器已经运行起来。此时访问 http://{ip}:3000 应该就能访问到该vue应用:</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/07/30/linux%E5%AE%89%E8%A3%85java-jdk%E4%B8%8Ejenkins/" rel="prev" title="linux安装jenkins">
      <i class="fa fa-chevron-left"></i> linux安装jenkins
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/03/nuxt%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E9%83%A8%E7%BD%B2/" rel="next" title="nuxt项目打包部署">
      nuxt项目打包部署 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-基础教程"><span class="nav-number">1.</span> <span class="nav-text">Docker 基础教程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#配置国内镜像加速器"><span class="nav-number">1.1.</span> <span class="nav-text">配置国内镜像加速器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、获取加速信息"><span class="nav-number">1.1.1.</span> <span class="nav-text">一、获取加速信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、配置-Docker"><span class="nav-number">1.1.2.</span> <span class="nav-text">二、配置 Docker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、验证速度"><span class="nav-number">1.1.3.</span> <span class="nav-text">三、验证速度</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-下载镜像"><span class="nav-number">1.2.</span> <span class="nav-text">Docker 下载镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、前言"><span class="nav-number">1.2.1.</span> <span class="nav-text">一、前言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、下载镜像"><span class="nav-number">1.2.2.</span> <span class="nav-text">二、下载镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、验证镜像"><span class="nav-number">1.2.3.</span> <span class="nav-text">三、验证镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、下载镜像相关细节"><span class="nav-number">1.2.4.</span> <span class="nav-text">四、下载镜像相关细节</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-查看镜像信息"><span class="nav-number">1.3.</span> <span class="nav-text">Docker 查看镜像信息</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、images-命令列出镜像"><span class="nav-number">1.3.1.</span> <span class="nav-text">一、images 命令列出镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、使用-tag-命令为镜像添加标签"><span class="nav-number">1.3.2.</span> <span class="nav-text">二、使用 tag 命令为镜像添加标签</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、使用-inspect-命令查看镜像详细信息"><span class="nav-number">1.3.3.</span> <span class="nav-text">三、使用 inspect 命令查看镜像详细信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-搜索镜像"><span class="nav-number">1.4.</span> <span class="nav-text">Docker 搜索镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、search-命令"><span class="nav-number">1.4.1.</span> <span class="nav-text">一、search 命令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、search-子命令"><span class="nav-number">1.4.2.</span> <span class="nav-text">二、search 子命令</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-删除-amp-清理镜像"><span class="nav-number">1.5.</span> <span class="nav-text">Docker 删除&amp;清理镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、通过标签删除镜像"><span class="nav-number">1.5.1.</span> <span class="nav-text">一、通过标签删除镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、通过-ID-删除镜像"><span class="nav-number">1.5.2.</span> <span class="nav-text">二、通过 ID 删除镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、删除镜像的限制"><span class="nav-number">1.5.3.</span> <span class="nav-text">三、删除镜像的限制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、清理镜像"><span class="nav-number">1.5.4.</span> <span class="nav-text">四、清理镜像</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-创建镜像"><span class="nav-number">1.6.</span> <span class="nav-text">Docker 创建镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、基于已有的镜像创建"><span class="nav-number">1.6.1.</span> <span class="nav-text">一、基于已有的镜像创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、基于-Dockerfile-来创建镜像"><span class="nav-number">1.6.2.</span> <span class="nav-text">二、基于 Dockerfile 来创建镜像</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-导出-amp-加载镜像"><span class="nav-number">1.7.</span> <span class="nav-text">Docker 导出&amp;加载镜像</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、导出镜像"><span class="nav-number">1.7.1.</span> <span class="nav-text">一、导出镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、加载镜像"><span class="nav-number">1.7.2.</span> <span class="nav-text">二、加载镜像</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器使用"><span class="nav-number">1.8.</span> <span class="nav-text">容器使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取镜像"><span class="nav-number">1.8.1.</span> <span class="nav-text">获取镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启动容器"><span class="nav-number">1.8.2.</span> <span class="nav-text">启动容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#启动已停止运行的容器"><span class="nav-number">1.8.3.</span> <span class="nav-text">启动已停止运行的容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#后台运行"><span class="nav-number">1.8.4.</span> <span class="nav-text">后台运行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#停止容器"><span class="nav-number">1.8.5.</span> <span class="nav-text">停止容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进入容器"><span class="nav-number">1.8.6.</span> <span class="nav-text">进入容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#导出和导入容器"><span class="nav-number">1.8.7.</span> <span class="nav-text">导出和导入容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除容器"><span class="nav-number">1.8.8.</span> <span class="nav-text">删除容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#清理容器"><span class="nav-number">1.8.9.</span> <span class="nav-text">清理容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查看容器日志"><span class="nav-number">1.8.10.</span> <span class="nav-text">查看容器日志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检查容器详细信息inspect"><span class="nav-number">1.8.11.</span> <span class="nav-text">检查容器详细信息inspect</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用环境安装篇"><span class="nav-number">2.</span> <span class="nav-text">常用环境安装篇</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mysql-环境"><span class="nav-number">2.1.</span> <span class="nav-text">Mysql 环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、下载-Mysql-镜像"><span class="nav-number">2.1.1.</span> <span class="nav-text">一、下载 Mysql 镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、正式运行-Mysql-容器："><span class="nav-number">2.1.2.</span> <span class="nav-text">二、正式运行 Mysql 容器：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、通过-Mysql-客户端连接一下试试"><span class="nav-number">2.1.3.</span> <span class="nav-text">三、通过 Mysql 客户端连接一下试试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相关问题补充"><span class="nav-number">2.1.4.</span> <span class="nav-text">相关问题补充</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis-环境"><span class="nav-number">2.2.</span> <span class="nav-text">Redis 环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、下载-Redis-镜像"><span class="nav-number">2.2.1.</span> <span class="nav-text">一、下载 Redis 镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、运行-Redis-容器"><span class="nav-number">2.2.2.</span> <span class="nav-text">二、运行 Redis 容器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、连接刚刚创建好的容器"><span class="nav-number">2.2.3.</span> <span class="nav-text">三、连接刚刚创建好的容器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MongDB-环境"><span class="nav-number">2.3.</span> <span class="nav-text">MongDB 环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、下载-MongoDB-镜像"><span class="nav-number">2.3.1.</span> <span class="nav-text">一、下载 MongoDB 镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二、运行-MongoDB-镜像"><span class="nav-number">2.3.2.</span> <span class="nav-text">二、运行 MongoDB 镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三、添加管理员账号"><span class="nav-number">2.3.3.</span> <span class="nav-text">三、添加管理员账号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四、用新创建的-root-账户连接，测试一下"><span class="nav-number">2.3.4.</span> <span class="nav-text">四、用新创建的 root 账户连接，测试一下</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ngnix-环境"><span class="nav-number">2.4.</span> <span class="nav-text">Ngnix 环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一、下载-Nginx-镜像"><span class="nav-number">2.4.1.</span> <span class="nav-text">一、下载 Nginx 镜像</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过-Docker-搭建反向代理-Ngnix，并配置-Https-SSL-证书"><span class="nav-number">3.</span> <span class="nav-text">通过 Docker 搭建反向代理 Ngnix，并配置 Https SSL 证书</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态设置环境变量"><span class="nav-number">4.</span> <span class="nav-text">动态设置环境变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用-Docker-搭建-nodejs-应用"><span class="nav-number">5.</span> <span class="nav-text">用 Docker 搭建 nodejs 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建koa项目"><span class="nav-number">5.1.</span> <span class="nav-text">创建koa项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-Dockerfile-文件"><span class="nav-number">5.2.</span> <span class="nav-text">创建 Dockerfile 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#制作镜像"><span class="nav-number">5.3.</span> <span class="nav-text">制作镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动容器-1"><span class="nav-number">5.4.</span> <span class="nav-text">启动容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用运行优化"><span class="nav-number">5.5.</span> <span class="nav-text">应用运行优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用-Docker-搭建-vue-应用-案例一"><span class="nav-number">6.</span> <span class="nav-text">用 Docker 搭建 vue 应用 (案例一)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#说在前面"><span class="nav-number">6.1.</span> <span class="nav-text">说在前面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备好vue项目"><span class="nav-number">6.2.</span> <span class="nav-text">准备好vue项目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-Dockerfile-文件-1"><span class="nav-number">6.3.</span> <span class="nav-text">创建 Dockerfile 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-nginx-conf-文件"><span class="nav-number">6.4.</span> <span class="nav-text">创建 nginx.conf 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建-dockerignore-文件"><span class="nav-number">6.5.</span> <span class="nav-text">创建 .dockerignore 文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#制作镜像-1"><span class="nav-number">6.6.</span> <span class="nav-text">制作镜像</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启动容器-2"><span class="nav-number">6.7.</span> <span class="nav-text">启动容器</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="king"
      src="/images/tx.jpg">
  <p class="site-author-name" itemprop="name">king</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">71</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">47</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/RocWangPeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RocWangPeng" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:383557980@qq.com" title="E-Mail → mailto:383557980@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">king</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">464k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:02</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
